<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>quarto-inputca3612b85ffd0194 – Deep Learning DNA: Surviving Architectures and Essential Principles</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script><script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap-f507c7d0488cb7630e20aad62ad8c2aa.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>

<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>
<script src="https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js" crossorigin="anonymous"></script>
<script>window.MathJax = {loader: {load: ['[tex]/boldsymbol']},tex: {packages: {'[+]': ['boldsymbol']}}};</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-sidebar docked">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../../notebooks/ko/part_1/01_딥러닝의 시작.html">part_1</a></li><li class="breadcrumb-item"><a href="../../../notebooks/ko/part_1/05_최적화와 시각화.html">5. 최적화와 시각화</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../../../">한국어</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Language</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../index_de.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Deutsch</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../index_en.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">English</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../index_es.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Español</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">한국어</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../index_zh.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">中文</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../notebooks/ko/part_1/00_서론.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">서론</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true">
 <span class="menu-text">part_1</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../notebooks/ko/part_1/01_딥러닝의 시작.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">1. 딥러닝의 시작</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../notebooks/ko/part_1/02_딥러닝의 수학.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">2. 딥러닝의 수학</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../notebooks/ko/part_1/03_딥러닝프레임워크.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">3. 딥러닝프레임워크</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../notebooks/ko/part_1/04_활성화함수.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">4. 활성화함수</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../notebooks/ko/part_1/05_최적화와 시각화.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">5. 최적화와 시각화</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../notebooks/ko/part_1/06_과적합과 해결 기법의 발전.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">6. 과적합과 해결 기법의 발전</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../notebooks/ko/part_1/07_합성곱 신경망의 진화.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">7. 합성곱 신경망의 진화</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../notebooks/ko/part_1/08_트랜스포머의 탄생.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">8. 트랜스포머의 탄생</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../notebooks/ko/part_1/09_트랜스포머의 진화.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">9. 트랜스포머의 진화</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../notebooks/ko/part_1/10_멀티모달 딥러닝: 다중 감각 융합의 시작.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">10. 멀티모달 딥러닝: 다중 감각 융합의 시작</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../notebooks/ko/part_1/11_멀티모달 딥러닝: 한계를 넘어선 지능.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">11. 멀티모달 딥러닝: 한계를 넘어선 지능</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true">
 <span class="menu-text">딥러닝의 최전선</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../notebooks/ko/딥러닝의 최전선/01_SLM: 작지만 강력한 언어모델.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">1. SLM: 작지만 강력한 언어모델</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../notebooks/ko/딥러닝의 최전선/02_자율주행.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">2. 자율주행</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#최적화와-시각화" id="toc-최적화와-시각화" class="nav-link active" data-scroll-target="#최적화와-시각화">5. 최적화와 시각화</a>
  <ul class="collapse">
  <li><a href="#파라미터-초기화의-발전과-현대적-접근" id="toc-파라미터-초기화의-발전과-현대적-접근" class="nav-link" data-scroll-target="#파라미터-초기화의-발전과-현대적-접근">5.1 파라미터 초기화의 발전과 현대적 접근</a>
  <ul class="collapse">
  <li><a href="#초기화-방법의-수학적-원리" id="toc-초기화-방법의-수학적-원리" class="nav-link" data-scroll-target="#초기화-방법의-수학적-원리">5.1.1 초기화 방법의 수학적 원리</a></li>
  <li><a href="#초기화-방법-실전-비교-분석" id="toc-초기화-방법-실전-비교-분석" class="nav-link" data-scroll-target="#초기화-방법-실전-비교-분석">5.1.2 초기화 방법: 실전 비교 분석</a></li>
  <li><a href="#실무적-권장사항-및-추가-고려-사항" id="toc-실무적-권장사항-및-추가-고려-사항" class="nav-link" data-scroll-target="#실무적-권장사항-및-추가-고려-사항">5.1.3 실무적 권장사항 및 추가 고려 사항</a></li>
  </ul></li>
  <li><a href="#최적화-알고리즘-딥러닝-학습의-핵심-엔진" id="toc-최적화-알고리즘-딥러닝-학습의-핵심-엔진" class="nav-link" data-scroll-target="#최적화-알고리즘-딥러닝-학습의-핵심-엔진">5.2 최적화 알고리즘: 딥러닝 학습의 핵심 엔진</a>
  <ul class="collapse">
  <li><a href="#최적화-알고리즘의-발전과-구현---계속되는-진화" id="toc-최적화-알고리즘의-발전과-구현---계속되는-진화" class="nav-link" data-scroll-target="#최적화-알고리즘의-발전과-구현---계속되는-진화">5.2.1 최적화 알고리즘의 발전과 구현 - 계속되는 진화</a></li>
  <li><a href="#최적화-훈련-비교" id="toc-최적화-훈련-비교" class="nav-link" data-scroll-target="#최적화-훈련-비교">5.2.2 최적화 훈련 비교</a></li>
  </ul></li>
  <li><a href="#최적화-과정의-시각화와-분석-딥러닝-학습의-블랙박스-들여다보기" id="toc-최적화-과정의-시각화와-분석-딥러닝-학습의-블랙박스-들여다보기" class="nav-link" data-scroll-target="#최적화-과정의-시각화와-분석-딥러닝-학습의-블랙박스-들여다보기">5.3 최적화 과정의 시각화와 분석: 딥러닝 학습의 블랙박스 들여다보기</a>
  <ul class="collapse">
  <li><a href="#손실-표면loss-landscape의-이해-딥러닝-모델의-지형도" id="toc-손실-표면loss-landscape의-이해-딥러닝-모델의-지형도" class="nav-link" data-scroll-target="#손실-표면loss-landscape의-이해-딥러닝-모델의-지형도">5.3.1 손실 표면(Loss Landscape)의 이해: 딥러닝 모델의 지형도</a></li>
  <li><a href="#손실-표면-분석의-심층-기법" id="toc-손실-표면-분석의-심층-기법" class="nav-link" data-scroll-target="#손실-표면-분석의-심층-기법">5.3.2 손실 표면 분석의 심층 기법</a></li>
  </ul></li>
  <li><a href="#최적화-과정-시각화-가우시안-함수로-엿보는-딥러닝-학습의-비밀" id="toc-최적화-과정-시각화-가우시안-함수로-엿보는-딥러닝-학습의-비밀" class="nav-link" data-scroll-target="#최적화-과정-시각화-가우시안-함수로-엿보는-딥러닝-학습의-비밀">5.4 최적화 과정 시각화: 가우시안 함수로 엿보는 딥러닝 학습의 비밀</a>
  <ul class="collapse">
  <li><a href="#가우시안-함수를-통한-근사적-분석-단순함-속에-숨겨진-통찰" id="toc-가우시안-함수를-통한-근사적-분석-단순함-속에-숨겨진-통찰" class="nav-link" data-scroll-target="#가우시안-함수를-통한-근사적-분석-단순함-속에-숨겨진-통찰">5.4.1 가우시안 함수를 통한 근사적 분석: 단순함 속에 숨겨진 통찰</a></li>
  <li><a href="#경로-시각화" id="toc-경로-시각화" class="nav-link" data-scroll-target="#경로-시각화">5.4.2 경로 시각화</a></li>
  </ul></li>
  <li><a href="#최적화-과정의-동적-분석-학습-궤적의-탐구" id="toc-최적화-과정의-동적-분석-학습-궤적의-탐구" class="nav-link" data-scroll-target="#최적화-과정의-동적-분석-학습-궤적의-탐구">5.5 최적화 과정의 동적 분석: 학습 궤적의 탐구</a>
  <ul class="collapse">
  <li><a href="#훈련-과정의-특징" id="toc-훈련-과정의-특징" class="nav-link" data-scroll-target="#훈련-과정의-특징">5.5.1 훈련 과정의 특징</a></li>
  <li><a href="#학습-안정성-분석-및-제어" id="toc-학습-안정성-분석-및-제어" class="nav-link" data-scroll-target="#학습-안정성-분석-및-제어">5.5.2 학습 안정성 분석 및 제어</a></li>
  <li><a href="#맺음말" id="toc-맺음말" class="nav-link" data-scroll-target="#맺음말">맺음말</a></li>
  <li><a href="#연습-문제" id="toc-연습-문제" class="nav-link" data-scroll-target="#연습-문제">연습 문제</a></li>
  <li><a href="#참고-자료" id="toc-참고-자료" class="nav-link" data-scroll-target="#참고-자료">참고 자료</a></li>
  </ul></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../../notebooks/ko/part_1/01_딥러닝의 시작.html">part_1</a></li><li class="breadcrumb-item"><a href="../../../notebooks/ko/part_1/05_최적화와 시각화.html">5. 최적화와 시각화</a></li></ol></nav></header>




<p><a href="https://colab.research.google.com/github/Quantum-Intelligence-Frontier/dldna/blob/main/notebooks/ko/part_1/05_최적화와 시각화.ipynb" target="_parent"> <img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"> </a></p>
<section id="최적화와-시각화" class="level1">
<h1>5. 최적화와 시각화</h1>
<blockquote class="blockquote">
<p>“이론과 실제 사이에는 이론과 실제의 차이보다 더 큰 차이가 있다.” - 얀 르쿤 (Yann LeCun), 2018 튜링상 수상자</p>
</blockquote>
<p>딥러닝 모델의 성공은 효과적인 최적화 알고리즘과 적절한 가중치 초기화 전략에 크게 의존합니다. 이 장에서는 딥러닝 모델 학습의 핵심 요소인 최적화와 초기화 방법을 심층적으로 탐구하고, 이 과정을 시각화를 통해 직관적으로 이해하는 방법을 제시합니다. 먼저, 신경망 학습의 초석이 되는 다양한 가중치 초기화 방법의 발전 과정과 그 수학적 원리를 살펴봅니다. 그런 다음, 경사하강법(Gradient Descent)을 시작으로, Adam, Lion, Sophia, AdaFactor 등 최신 최적화 알고리즘의 작동 원리와 성능을 비교 분석합니다. 특히, 이론적인 배경뿐만 아니라, 실제 딥러닝 모델 학습 과정에서 각 알고리즘이 어떻게 동작하는지 실험을 통해 확인합니다. 마지막으로, 고차원 손실 함수 공간(loss landscape)을 시각화하고 분석하는 다양한 기법들을 소개하고, 이를 통해 딥러닝 모델의 학습 동역학(learning dynamics)을 이해하는 심층적인 통찰력을 제공합니다.</p>
<section id="파라미터-초기화의-발전과-현대적-접근" class="level2">
<h2 class="anchored" data-anchor-id="파라미터-초기화의-발전과-현대적-접근">5.1 파라미터 초기화의 발전과 현대적 접근</h2>
<p>신경망의 파라미터 초기화는 모델의 수렴성, 학습 효율성, 그리고 최종 성능을 결정짓는 핵심 요소 중 하나입니다. 잘못된 초기화는 학습 실패의 주 원인이 될 수 있습니다. 파이토치(PyTorch)는 torch.nn.init 모듈을 통해 다양한 초기화 방법을 제공하며, 자세한 내용은 공식 문서에서](https://www.google.com/search?q=https://pytorch.org/docs/stable/nn.init.html)%EC%97%90%EC%84%9C%EC%97%90%EC%84%9C)) 확인할 수 있습니다. 초기화 방법의 발전 과정은 딥러닝 연구자들이 신경망 학습의 어려움을 극복해 온 역사를 반영합니다. 특히, 부적절한 초기화는 그래디언트 소실(vanishing gradient)이나 폭발(exploding gradient) 현상을 유발하여, 심층 신경망의 학습을 방해하는 주범으로 지목되었습니다. 최근에는 GPT-3, LaMDA와 같은 대규모 언어 모델(Large Language Models, LLMs)의 등장으로 초기화의 중요성이 더욱 강조되고 있습니다. 모델의 규모가 커질수록, 초기 파라미터의 분포가 학습 초기 단계에 미치는 영향이 증폭되기 때문입니다. 따라서, 모델의 특성과 규모에 맞는 적절한 초기화 전략을 선택하는 것이 딥러닝 모델 개발의 필수적인 단계가 되었습니다.</p>
<section id="초기화-방법의-수학적-원리" class="level3">
<h3 class="anchored" data-anchor-id="초기화-방법의-수학적-원리">5.1.1 초기화 방법의 수학적 원리</h3>
<p>신경망 초기화 방법의 발전은 깊이 있는 수학적 이론과 수많은 실험적 검증이 함께 이루어진 결과입니다. 각 초기화 방법은 특정한 문제 상황(예: 특정 활성화 함수의 사용, 네트워크의 깊이, 모델의 종류)을 해결하거나, 학습 동역학(learning dynamics)을 개선하기 위해 고안되었으며, 시대의 흐름에 따라 새로운 도전 과제에 대응하며 발전해 왔습니다.</p>
<p>다음은 이 책에서 중점적으로 비교하고 분석할 초기화 방법들입니다. (전체 구현 코드는 chapter_04/initialization/base.py 파일에 수록되어 있습니다.)</p>
<div id="cell-2" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="op">!</span>pip install dldna[colab] <span class="co"># in Colab</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co"># !pip install dldna[all] # in your local</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>load_ext autoreload</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>autoreload <span class="dv">2</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="cell-3" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.nn <span class="im">as</span> nn</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Set seed</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">7</span>)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>torch.manual_seed(<span class="dv">7</span>)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_05.initialization.base <span class="im">import</span> init_methods, init_weights_lecun, init_weights_scaled_orthogonal, init_weights_lmomentum <span class="co"># init_weights_emergence, init_weights_dynamic 삭제</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>init_methods <span class="op">=</span> {</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Historical/Educational Significance</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    <span class="st">'lecun'</span>: init_weights_lecun,        <span class="co"># The first systematic initialization proposed in 1998</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    <span class="st">'xavier_normal'</span>: nn.init.xavier_normal_, <span class="co"># Key to the revival of deep learning in 2010</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>    <span class="st">'kaiming_normal'</span>: nn.init.kaiming_normal_, <span class="co"># Standard for the ReLU era, 2015</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Modern Standard</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>    <span class="st">'orthogonal'</span>: nn.init.orthogonal_,  <span class="co"># Important in RNN/LSTM</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>    <span class="st">'scaled_orthogonal'</span>: init_weights_scaled_orthogonal, <span class="co"># Optimization of deep neural networks</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 2024 Latest Research</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>    <span class="st">'l-momentum'</span>: init_weights_lmomentum <span class="co"># L-Momentum Initialization</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<section id="전통적-초기화" class="level5">
<h5 class="anchored" data-anchor-id="전통적-초기화">전통적 초기화</h5>
<ul>
<li><p><strong>LeCun 초기화 (1998년):</strong> <span class="math inline">\(std = \sqrt{\frac{1}{n_{in}}}\)</span></p>
<ul>
<li>Yann LeCun이 1998년에 제안한 방법으로, 입력 차원(<span class="math inline">\(n_{in}\)</span>)만을 고려하여 가중치의 표준편차를 결정합니다. 각 뉴런의 출력이 입력 개수에 따라 크게 변하는 것을 방지하고자 했으나, 깊은 네트워크에서는 층이 깊어질수록 활성화 값의 분산이 감소하는 경향이 있었습니다. <em>이는 특히 tanh와 같은 시그모이드 계열 활성화 함수를 사용할 때 두드러졌습니다.</em></li>
</ul></li>
</ul>
</section>
<section id="현대적-초기화" class="level5">
<h5 class="anchored" data-anchor-id="현대적-초기화">현대적 초기화</h5>
<ul>
<li><p><strong>Xavier 초기화 (Glorot, 2010):</strong> <span class="math inline">\(std = \sqrt{\frac{2}{n_{in} + n_{out}}}\)</span></p>
<ul>
<li>Xavier Glorot와 Yoshua Bengio가 제안한 방법으로, 입력(<span class="math inline">\(n_{in}\)</span>)과 출력(<span class="math inline">\(n_{out}\)</span>) 차원을 모두 고려하여 그래디언트 소실/폭발 문제를 완화했습니다. 핵심은 각 층의 활성화 값과 그래디언트의 분산을 적절하게 유지하는 것입니다. <em>주로 sigmoid, tanh와 같은 포화형(saturating) 활성화 함수와 함께 사용될 때 효과적입니다.</em></li>
</ul></li>
<li><p><strong>Kaiming 초기화 (He, 2015):</strong> <span class="math inline">\(std = \sqrt{\frac{2}{n_{in}}}\)</span></p>
<ul>
<li>Kaiming He 등이 제안한 방법으로, ReLU 활성화 함수의 특성(음수 입력을 0으로 만듦)을 고려하여 설계되었습니다. ReLU는 활성화 값의 분산을 절반으로 줄이는 경향이 있어, 이를 보상하기 위해 Xavier 초기화보다 큰 분산(<span class="math inline">\(\sqrt{2}\)</span> 배)을 사용합니다. <em>이는 “죽은 뉴런(dead neuron)” 문제를 줄이고 깊은 네트워크에서도 안정적인 학습을 가능하게 하여, 현재 ReLU 계열 활성화 함수 사용 시 사실상의 표준(de facto standard)이 되었습니다.</em></li>
</ul></li>
</ul>
</section>
<section id="최신-초기화-2023년-이후" class="level5">
<h5 class="anchored" data-anchor-id="최신-초기화-2023년-이후">최신 초기화 (2023년 이후)</h5>
<ul>
<li><strong>L-Momentum Initialization (Zhuang, 2024)</strong>
<ul>
<li><p>L-Momentum Initialization은 2024년에 제안된 최신 초기화 방식으로, 기존 모멘텀 기반 최적화 알고리즘에서 영감을 받아 초기 가중치 행렬의 L-모멘텀을 제어합니다.</p></li>
<li><p><strong>수식:</strong></p>
<p><span class="math inline">\(W \sim U(-\sqrt{\frac{6}{n_{in}}}, \sqrt{\frac{6}{n_{in}}})\)</span> <span class="math inline">\(W = W \cdot \sqrt{\frac{\alpha}{Var(W)}}\)</span></p>
<p>여기서 <span class="math inline">\(U\)</span>는 균등 분포, <span class="math inline">\(\alpha\)</span>는 L-Momentum을 나타내는 값으로, Optimizer에서 사용하는 모멘텀 값의 제곱을 사용합니다.</p></li>
<li><p>목표는 초기 단계에서 그래디언트 변동성을 줄여 안정적 학습 경로를 제공하는 것입니다.</p></li>
<li><p>다양한 옵티마이저 및 활성화 함수에 적용 가능하며, 큰 학습률 사용과 빠른 수렴, 일반화 성능 개선에 기여한다는 실험 결과가 있습니다.</p></li>
</ul></li>
</ul>
</section>
<section id="수학적-원리" class="level5">
<h5 class="anchored">수학적 원리</h5>
<p>대부분의 현대적 초기화 방법은 다음 세 가지 핵심 원리를 (명시적 또는 암묵적으로) 따릅니다.</p>
<ol type="1">
<li><p><strong>분산 보존 (Variance Preservation):</strong> 순전파 시 활성화 값의 분산과 역전파 시 그래디언트의 분산이 층별로 일정하게 유지되어야 합니다.</p>
<p><span class="math inline">\(Var(y) \approx Var(x)\)</span></p>
<p>이는 신호가 너무 커지거나 작아지지 않도록 하여 안정적인 학습을 돕습니다.</p></li>
<li><p><strong>스펙트럴 제어 (Spectral Control):</strong> 가중치 행렬의 특이값(singular value) 분포를 제어하여, 학습 과정의 수치적 안정성을 확보해야 합니다.</p>
<p><span class="math inline">\(\sigma_{max}(W) / \sigma_{min}(W) \leq C\)</span></p>
<p>이는 특히, 순환 신경망(RNN)과 같이 가중치 행렬이 반복적으로 곱해지는 구조에서 중요합니다.</p></li>
<li><p><strong>표현력 최적화 (Expressivity Optimization):</strong> 가중치 행렬의 유효 랭크(effective rank)를 최대화하여, 네트워크가 충분한 표현력을 갖도록 해야 합니다.</p>
<p><span class="math inline">\(rank_{eff}(W) = \frac{\sum_i \sigma_i}{\max_i \sigma_i}\)</span> <em>최근 연구들은 이러한 원리들을 명시적으로 만족시키기 위해 노력하고 있습니다.</em></p></li>
</ol>
<p>결론적으로, 초기화 방법은 모델의 규모, 구조, 활성화 함수, 그리고 최적화 알고리즘과의 상호작용을 고려하여 신중하게 선택해야 합니다. 이는 모델의 학습 속도, 안정성, 그리고 최종 성능에 큰 영향을 미치기 때문입니다.</p>
<div class="callout callout-style-default callout-note callout-titled" title="클릭하여 내용 보기 (딥다이브: 심층 신경망 초기화의 수학적 원리와 최신 기법)">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-1-contents" aria-controls="callout-1" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
클릭하여 내용 보기 (딥다이브: 심층 신경망 초기화의 수학적 원리와 최신 기법)
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-1" class="callout-1-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<section id="심층-신경망-초기화의-수학적-원리와-최신-기법" class="level3">
<h3 class="anchored" data-anchor-id="심층-신경망-초기화의-수학적-원리와-최신-기법">심층 신경망 초기화의 수학적 원리와 최신 기법</h3>
<section id="분산-보존-원리-variance-preservation-principle" class="level4">
<h4 class="anchored" data-anchor-id="분산-보존-원리-variance-preservation-principle">1. 분산 보존 원리 (Variance Preservation Principle)</h4>
<section id="이론적-기반" class="level5">
<h5 class="anchored" data-anchor-id="이론적-기반">1.1 이론적 기반</h5>
<p>신경망의 깊이가 증가함에 따라 순전파(forward propagation) 및 역전파(backpropagation) 과정에서 신호의 통계적 특성(특히 분산)을 보존하는 것은 매우 중요합니다. 이는 신호가 소실(vanishing)되거나 폭발(exploding)하는 것을 방지하여 안정적인 학습을 가능하게 합니다.</p>
<p><span class="math inline">\(l\)</span>번째 층의 활성화 값을 <span class="math inline">\(h_l\)</span>, 가중치 행렬을 <span class="math inline">\(W_l\)</span>, 편향을 <span class="math inline">\(b_l\)</span>, 활성화 함수를 <span class="math inline">\(f\)</span>라고 할 때, 순전파는 다음과 같이 표현됩니다.</p>
<p><span class="math inline">\(h_l = f(W_l h_{l-1} + b_l)\)</span></p>
<p>입력 신호 <span class="math inline">\(h_{l-1} \in \mathbb{R}^{n_{in}}\)</span>의 각 요소가 평균 0, 분산 <span class="math inline">\(\sigma^2_{h_{l-1}}\)</span>을 갖는 독립적인 확률변수이고, 가중치 행렬 <span class="math inline">\(W_l \in \mathbb{R}^{n_{out} \times n_{in}}\)</span>의 각 요소가 평균 0, 분산 <span class="math inline">\(Var(W_l)\)</span>을 갖는 독립적인 확률변수이며, 편향 <span class="math inline">\(b_l = 0\)</span>이라고 가정하면, <em>활성화 함수가 선형이라고 가정할 때</em> 다음이 성립합니다.</p>
<p><span class="math inline">\(Var(h_l) = n_{in} Var(W_l) Var(h_{l-1})\)</span> (단, <span class="math inline">\(n_{in}\)</span>은 <span class="math inline">\(l\)</span>번째 층의 입력 차원)</p>
<p>활성화 값의 분산이 보존되려면, <span class="math inline">\(Var(h_l) = Var(h_{l-1})\)</span> 이어야 하므로, <span class="math inline">\(Var(W_l) = 1/n_{in}\)</span> 이어야 합니다.</p>
<p>역전파 시에는, 오차 신호 <span class="math inline">\(\delta_l = \frac{\partial L}{\partial h_l}\)</span> (단, <span class="math inline">\(L\)</span>은 손실 함수)에 대해 다음과 같은 관계가 성립합니다.</p>
<p><span class="math inline">\(\delta_{l-1} = W_l^T \delta_l\)</span> (활성화 함수가 선형이라고 가정)</p>
<p>따라서, 역전파 시 분산 보존을 위해서는 <span class="math inline">\(Var(\delta_{l-1}) = n_{out}Var(W_l)Var(\delta_l)\)</span> 이므로, <span class="math inline">\(Var(W_l) = 1/n_{out}\)</span> 이어야 합니다. (단, <span class="math inline">\(n_{out}\)</span>은 <span class="math inline">\(l\)</span>번째 층의 출력 차원)</p>
</section>
<section id="비선형-활성화-함수-확장" class="level5">
<h5 class="anchored" data-anchor-id="비선형-활성화-함수-확장">1.2 비선형 활성화 함수 확장</h5>
<p><strong>ReLU 활성화 함수</strong></p>
<p>ReLU 함수 (<span class="math inline">\(f(x) = max(0, x)\)</span>)는 입력의 절반을 0으로 만들기 때문에 활성화 값의 분산이 줄어드는 경향이 있습니다. Kaiming He는 이를 보정하기 위해 다음과 같은 분산 보존 식을 제안했습니다.</p>
<p><span class="math inline">\(Var(W_l) = \frac{2}{n_{in}} \quad (\text{ReLU 특화})\)</span></p>
<p>이는 ReLU를 통과하면서 발생하는 분산 감소를 2배 증가시켜 보상하는 것입니다.</p>
<p><strong>Leaky ReLU 활성화 함수</strong></p>
<p>Leaky ReLU (<span class="math inline">\(f(x) = max(\alpha x, x)\)</span>, <span class="math inline">\(\alpha\)</span>는 작은 상수)의 경우, 일반화된 공식은 다음과 같습니다.</p>
<p><span class="math inline">\(Var(W_l) = \frac{2}{(1 + \alpha^2) n_{in}}\)</span></p>
</section>
<section id="확률론적-접근-참고" class="level5">
<h5 class="anchored" data-anchor-id="확률론적-접근-참고">1.3 확률론적 접근 (참고)</h5>
<p>Fisher Information Matrix (FIM)의 역행렬을 사용하여 초기화하는 방법도 있습니다. FIM은 파라미터 공간에서의 곡률 정보를 담고 있어, 이를 활용하면 더 효율적인 초기화가 가능합니다. (더 자세한 내용은 참고 문헌 [4] Martens, 2020 참조).</p>
</section>
</section>
<section id="스펙트럴-제어-spectral-control" class="level4">
<h4 class="anchored" data-anchor-id="스펙트럴-제어-spectral-control">2. 스펙트럴 제어 (Spectral Control)</h4>
<section id="특이값-분해와-학습-역학" class="level5">
<h5 class="anchored" data-anchor-id="특이값-분해와-학습-역학">2.1 특이값 분해와 학습 역학</h5>
<p>가중치 행렬 <span class="math inline">\(W \in \mathbb{R}^{m \times n}\)</span>의 특이값 분해(Singular Value Decomposition, SVD)는 <span class="math inline">\(W = U\Sigma V^T\)</span> 로 표현됩니다. 여기서 <span class="math inline">\(\Sigma\)</span>는 대각 행렬이며, 대각 성분은 <span class="math inline">\(W\)</span>의 특이값 (<span class="math inline">\(\sigma_1 \geq \sigma_2 \geq ... \geq 0\)</span>)입니다. 가중치 행렬의 최대 특이값(<span class="math inline">\(\sigma_{max}\)</span>)이 너무 크면 그래디언트 폭발(exploding gradient)을, 최소 특이값(<span class="math inline">\(\sigma_{min}\)</span>)이 너무 작으면 그래디언트 소실(vanishing gradient)을 유발할 수 있습니다.</p>
<p>따라서, 특이값의 비율(조건수, condition number) <span class="math inline">\(\kappa = \sigma_{max}/\sigma_{min}\)</span> 을 제어하는 것이 중요합니다. <span class="math inline">\(\kappa\)</span>가 1에 가까울수록 안정적인 그래디언트 흐름이 보장됩니다.</p>
<p><strong>Theorem 2.1 (Saxe et al., 2014)</strong>: 직교 초기화(orthogonal initialization)된 심층 선형 신경망에서 각 층의 가중치 행렬 <span class="math inline">\(W_l\)</span>이 직교 행렬이면, 입력에 대한 출력의 야코비안 행렬(Jacobian matrix) <span class="math inline">\(J\)</span>의 Frobenius norm은 1로 유지됩니다.</p>
<p><span class="math inline">\(||J||_F = 1\)</span></p>
<p>이는 매우 깊은 네트워크에서도 그래디언트 소실 또는 폭발 문제를 완화하는 데 도움이 됩니다.</p>
</section>
<section id="동적-스펙트럴-정규화" class="level5">
<h5 class="anchored" data-anchor-id="동적-스펙트럴-정규화">2.2 동적 스펙트럴 정규화</h5>
<p>Miyato et al.(2018)은 GAN 학습의 안정성을 높이기 위해 가중치 행렬의 스펙트럴 노름(spectral norm, 최대 특이값)을 제한하는 Spectral Normalization 기법을 제안했습니다.</p>
<p><span class="math inline">\(W_{SN} = \frac{W}{\sigma_{max}(W)}\)</span></p>
<p>이 방식은 GAN 학습에서 특히 효과적이며, 최근에는 Vision Transformer 등 다른 모델에도 적용되고 있습니다.</p>
</section>
</section>
<section id="표현력-최적화-expressivity-optimization" class="level4">
<h4 class="anchored" data-anchor-id="표현력-최적화-expressivity-optimization">3. 표현력 최적화 (Expressivity Optimization)</h4>
<section id="유효-랭크-이론" class="level5">
<h5 class="anchored" data-anchor-id="유효-랭크-이론">3.1 유효 랭크 이론</h5>
<p>가중치 행렬 <span class="math inline">\(W\)</span>가 얼마나 다양한 특징(feature)을 표현할 수 있는지는 특이값 분포의 균일성으로 측정할 수 있습니다. 유효 랭크(effective rank)는 다음과 같이 정의됩니다.</p>
<p><span class="math inline">\(\text{rank}_{eff}(W) = \exp\left( -\sum_{i=1}^r p_i \ln p_i \right) \quad \text{where } p_i = \frac{\sigma_i}{\sum_j \sigma_j}\)</span></p>
<p>여기서 <span class="math inline">\(r\)</span>은 <span class="math inline">\(W\)</span>의 랭크, <span class="math inline">\(\sigma_i\)</span>는 <span class="math inline">\(i\)</span>번째 특이값, <span class="math inline">\(p_i\)</span>는 정규화된 특이값입니다. 유효 랭크는 특이값의 분포를 나타내는 지표로, 값이 클수록 특이값이 균등하게 분포되어 있음을 의미하며, 이는 곧 높은 표현력을 나타냅니다.</p>
</section>
<section id="초기화-전략-비교표" class="level5">
<h5 class="anchored" data-anchor-id="초기화-전략-비교표">3.2 초기화 전략 비교표</h5>
<table class="caption-top table">
<colgroup>
<col style="width: 15%">
<col style="width: 66%">
<col style="width: 7%">
<col style="width: 11%">
</colgroup>
<thead>
<tr class="header">
<th>초기화 방법</th>
<th>특이값 분포</th>
<th>유효 랭크</th>
<th>적합 아키텍처</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Xavier</td>
<td>비교적 빠르게 감소</td>
<td>낮음</td>
<td>얕은 MLP</td>
</tr>
<tr class="even">
<td>Kaiming</td>
<td>ReLU 활성화 함수에 맞게 조정 (상대적으로 덜 감소)</td>
<td>중간</td>
<td>CNN</td>
</tr>
<tr class="odd">
<td>Orthogonal</td>
<td>모든 특이값이 1로 동일</td>
<td>최고</td>
<td>RNN/Transformer</td>
</tr>
<tr class="even">
<td>Emergence-Promoting</td>
<td>네트워크 크기에 따라 조정, 상대적으로 완만하게 감소 (heavy-tailed distribution에 가까움)</td>
<td>높음</td>
<td>LLM</td>
</tr>
</tbody>
</table>
</section>
<section id="emergence-promoting-초기화" class="level5">
<h5 class="anchored" data-anchor-id="emergence-promoting-초기화">3.3 Emergence-Promoting 초기화</h5>
<p>Emergence-Promoting 초기화는 대규모 언어 모델(LLM)에서 창발적 능력(emergent abilities)을 촉진하기 위해 제안된 최신 기법입니다. 이 방법은 네트워크의 크기(특히 층의 깊이)에 따라 초기 가중치의 분산을 조정하여, 유효 랭크를 증가시키는 효과를 냅니다.</p>
<p>Chen et al.&nbsp;(2023)은 Transformer 모델에서 다음과 같은 scaling factor <span class="math inline">\(\nu_l\)</span>를 제안했습니다.</p>
<p><span class="math inline">\(\nu_l = \frac{1}{\sqrt{d_{in}}} \left( 1 + \frac{\ln l}{\ln d} \right)\)</span></p>
<p>여기서 <span class="math inline">\(d_{in}\)</span>은 입력 차원, <span class="math inline">\(l\)</span>은 층의 인덱스, <span class="math inline">\(d\)</span>는 모델의 깊이입니다. 이 scaling factor를 가중치 행렬의 표준 편차에 곱하여 초기화합니다. 즉, <span class="math inline">\(\nu_l\)</span> 를 곱한 <span class="math inline">\(\sqrt{2/n_{in}}\)</span>를 표준편차로 하는 정규분포에서 샘플링합니다.</p>
</section>
</section>
<section id="초기화와-최적화의-상호작용" class="level4">
<h4 class="anchored" data-anchor-id="초기화와-최적화의-상호작용">4. 초기화와 최적화의 상호작용</h4>
<section id="ntk-이론-확장" class="level5">
<h5 class="anchored" data-anchor-id="ntk-이론-확장">4.1 NTK 이론 확장</h5>
<p>Jacot et al.(2018)의 Neural Tangent Kernel (NTK) 이론은 “매우 넓은”(infinitely wide) 신경망의 학습 동역학을 분석하는 데 유용한 도구입니다. NTK 이론에 따르면, 초기화 시점에서 매우 넓은 신경망의 헤시안 행렬의 기댓값은 identity matrix에 비례합니다. 즉,</p>
<p><span class="math inline">\(\lim_{n_{in} \to \infty} \mathbb{E}[\nabla^2 \mathcal{L}] \propto I\)</span> (초기화 시점에서)</p>
<p>이는 Xavier 초기화가 넓은 신경망에서 최적에 가까운 초기화를 제공한다는 것을 시사합니다.</p>
</section>
<section id="메타-초기화-전략" class="level5">
<h5 class="anchored" data-anchor-id="메타-초기화-전략">4.2 메타 초기화 전략</h5>
<p>MetaInit (2023)과 같은 최근 연구에서는 메타러닝을 통해 주어진 아키텍처와 데이터셋에 맞는 최적의 초기화 분포를 학습하는 방법을 제안합니다.</p>
<p><span class="math inline">\(\theta_{init} = \arg\min_\theta \mathbb{E}_{\mathcal{T}}[\mathcal{L}(\phi_{fine-tune}(\theta, \mathcal{T}))]\)</span></p>
<p>여기서 <span class="math inline">\(\theta\)</span>는 초기화 파라미터, <span class="math inline">\(\mathcal{T}\)</span>는 학습 task, <span class="math inline">\(\phi\)</span>는 <span class="math inline">\(\theta\)</span>로 초기화된 모델을 fine-tuning하는 과정을 나타냅니다.</p>
</section>
</section>
<section id="참고-물리-기반-초기화-기법" class="level4">
<h4 class="anchored" data-anchor-id="참고-물리-기반-초기화-기법">5. (참고) 물리 기반 초기화 기법</h4>
<p>최근에는 물리학의 원리에서 영감을 받은 초기화 방법도 연구되고 있습니다. 예를 들어, 양자역학의 슈뢰딩거 방정식이나 유체역학의 나비에-스토크스 방정식을 모방하여 층간 정보 흐름을 최적화하는 방법이 제안되기도 합니다. 하지만, 이러한 방법들은 아직 연구 초기 단계이며, 실용성은 검증되지 않았습니다.</p>
</section>
<section id="실용적-권장-사항" class="level4">
<h4 class="anchored" data-anchor-id="실용적-권장-사항">6. 실용적 권장 사항</h4>
<ol type="1">
<li><strong>CNN 아키텍처:</strong> 일반적으로 Kaiming 초기화(He 초기화)와 배치 정규화(Batch Normalization)를 함께 사용하는 것이 좋습니다.</li>
<li><strong>트랜스포머:</strong> Scaled Orthogonal Initialization (특이값 조정) 또는 Xavier 초기화가 널리 사용됩니다.</li>
<li><strong>LLM:</strong> Emergence-Promoting 초기화와 같은, 대규모 모델에 특화된 초기화 방법을 고려해야 합니다.</li>
<li><strong>신경 ODE</strong>: 특별한 경우가 아니면 일반적인 방법을 사용합니다.</li>
</ol>
<hr>
</section>
</section>
<section id="참고-문헌" class="level3">
<h3 class="anchored" data-anchor-id="참고-문헌">참고 문헌</h3>
<ol type="1">
<li>He et al.&nbsp;“Delving Deep into Rectifiers: Surpassing Human-Level Performance on ImageNet Classification”, ICCV 2015</li>
<li>Saxe et al.&nbsp;“Exact solutions to the nonlinear dynamics of learning in deep linear neural networks”, ICLR 2014</li>
<li>Jacot et al.&nbsp;“Neural Tangent Kernel: Convergence and Generalization in Neural Networks”, NeurIPS 2018</li>
<li>Martens, J. “New insights and perspectives on the natural gradient method.” The Journal of Machine Learning Research, 2020.</li>
<li>Chen et al.&nbsp;“Towards Understanding Large Language Models: A Transformative Reading List”, arXiv preprint arXiv:2307.12980, 2023. (Emergence-Promoting Initialization 관련)</li>
<li>Miyato et al., “Spectral Normalization for Generative Adversarial Networks”, ICLR 2018</li>
</ol>
</section>
</div>
</div>
</div>
</section>
</section>
<section id="초기화-방법-실전-비교-분석" class="level3">
<h3 class="anchored" data-anchor-id="초기화-방법-실전-비교-분석">5.1.2 초기화 방법: 실전 비교 분석</h3>
<p>앞서 살펴본 다양한 초기화 방법들이 실제로 모델 학습에 어떤 영향을 미치는지 알아보기 위해, 간단한 모델을 사용하여 비교 실험을 진행하겠습니다. 각 초기화 방법이 적용된 모델을 동일한 조건에서 훈련시키고 그 결과를 분석하겠습니다. 평가 지표는 다음과 같습니다.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 17%">
<col style="width: 45%">
<col style="width: 37%">
</colgroup>
<thead>
<tr class="header">
<th>평가 지표</th>
<th>의미</th>
<th>바람직한 특성</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>오차율(%)</td>
<td>최종 모델의 예측 성능 (낮을수록 좋음)</td>
<td>낮을수록 좋음</td>
</tr>
<tr class="even">
<td>수렴 속도</td>
<td>학습 곡선의 기울기 (학습 안정성 지표)</td>
<td>낮을수록 (가파를수록) 빠른 수렴</td>
</tr>
<tr class="odd">
<td>평균 조건수</td>
<td>가중치 행렬의 수치적 안정성</td>
<td>낮을수록 (1에 가까울수록) 안정적</td>
</tr>
<tr class="even">
<td>스펙트럴 놈</td>
<td>가중치 행렬의 크기 (최대 특이값)</td>
<td>너무 크거나 작지 않은 적절한 값 필요</td>
</tr>
<tr class="odd">
<td>유효 랭크비</td>
<td>가중치 행렬의 표현력 (특이값 분포의 균일성)</td>
<td>높을수록 좋음</td>
</tr>
<tr class="even">
<td>실행 시간(s)</td>
<td>학습시간</td>
<td>낮을수록 좋음</td>
</tr>
</tbody>
</table>
<div id="cell-7" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_04.models.base <span class="im">import</span> SimpleNetwork</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_04.utils.data <span class="im">import</span> get_data_loaders, get_device</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_05.initialization.base <span class="im">import</span> init_methods</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_05.initialization.analysis <span class="im">import</span> analyze_initialization, create_detailed_analysis_table</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.nn <span class="im">as</span> nn</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>device <span class="op">=</span> get_device()</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Initialize data loaders</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>train_dataloader, test_dataloader <span class="op">=</span> get_data_loaders()</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Detailed analysis of initialization methods</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> analyze_initialization(</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    model_class<span class="op">=</span><span class="kw">lambda</span>: SimpleNetwork(act_func<span class="op">=</span>nn.PReLU()),</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    init_methods<span class="op">=</span>init_methods,</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    train_loader<span class="op">=</span>train_dataloader,</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>    test_loader<span class="op">=</span>test_dataloader,</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>    epochs<span class="op">=</span><span class="dv">3</span>,</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>    device<span class="op">=</span>device</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Print detailed analysis results table</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>create_detailed_analysis_table(results)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>
Initialization method: lecun</code></pre>
</div>
<div class="cell-output cell-output-display">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id":"f7415089fb524e58a3bc0648f03072a2","version_major":2,"version_minor":0,"quarto_mimetype":"application/vnd.jupyter.widget-view+json"}
</script>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>/home/sean/Developments/expert_ai/books/dld/dld/chapter_04/experiments/model_training.py:320: UserWarning: std(): degrees of freedom is &lt;= 0. Correction should be strictly less than the reduction factor (input numel divided by output numel). (Triggered internally at ../aten/src/ATen/native/ReduceOps.cpp:1823.)
  'std': param.data.std().item(),</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
Initialization method: xavier_normal</code></pre>
</div>
<div class="cell-output cell-output-display">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id":"29ce93b749b746c7a45214d8a3d878f9","version_major":2,"version_minor":0,"quarto_mimetype":"application/vnd.jupyter.widget-view+json"}
</script>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
Initialization method: kaiming_normal</code></pre>
</div>
<div class="cell-output cell-output-display">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id":"fd9357f07d154648991dcd18979512aa","version_major":2,"version_minor":0,"quarto_mimetype":"application/vnd.jupyter.widget-view+json"}
</script>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
Initialization method: orthogonal</code></pre>
</div>
<div class="cell-output cell-output-display">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id":"bdc4bd358cf64c8ea5002b02fad46550","version_major":2,"version_minor":0,"quarto_mimetype":"application/vnd.jupyter.widget-view+json"}
</script>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
Initialization method: scaled_orthogonal</code></pre>
</div>
<div class="cell-output cell-output-display">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id":"e80c4b3368c249dd8edd6b4f4d125d62","version_major":2,"version_minor":0,"quarto_mimetype":"application/vnd.jupyter.widget-view+json"}
</script>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
Initialization method: l-momentum</code></pre>
</div>
<div class="cell-output cell-output-display">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id":"622b899e8de849aba61c8cec8bd7e078","version_major":2,"version_minor":0,"quarto_mimetype":"application/vnd.jupyter.widget-view+json"}
</script>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Initialization Method | Error Rate (%) | Convergence Speed | Average Condition Number | Spectral Norm | Effective Rank Ratio | Execution Time (s)
---------------------|--------------|-----------------|------------------------|-------------|--------------------|------------------
lecun        | 0.48 | 0.33 | 5.86 | 1.42 | 0.89 | 30.5
xavier_normal | 0.49 | 0.33 | 5.53 | 1.62 | 0.89 | 30.2
kaiming_normal | 0.45 | 0.33 | 5.85 | 1.96 | 0.89 | 30.1
orthogonal   | 0.49 | 0.33 | 1.00 | 0.88 | 0.95 | 30.0
scaled_orthogonal | 2.30 | 1.00 | 1.00 | 0.13 | 0.95 | 30.0
l-momentum   | nan | 0.00 | 5.48 | 19.02 | 0.89 | 30.1</code></pre>
</div>
</div>
<p>실험 결과는 다음과 같은 표로 요약됩니다.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 16%">
<col style="width: 11%">
<col style="width: 13%">
<col style="width: 18%">
<col style="width: 10%">
<col style="width: 15%">
<col style="width: 14%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Initialization Method</th>
<th style="text-align: center;">Error Rate (%)</th>
<th style="text-align: center;">Convergence Speed</th>
<th style="text-align: center;">Average Condition Number</th>
<th style="text-align: center;">Spectral Norm</th>
<th style="text-align: center;">Effective Rank Ratio</th>
<th style="text-align: center;">Execution Time (s)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">lecun</td>
<td style="text-align: center;">0.48</td>
<td style="text-align: center;">0.33</td>
<td style="text-align: center;">5.66</td>
<td style="text-align: center;">1.39</td>
<td style="text-align: center;">0.89</td>
<td style="text-align: center;">23.3</td>
</tr>
<tr class="even">
<td style="text-align: left;">xavier_normal</td>
<td style="text-align: center;">0.48</td>
<td style="text-align: center;">0.33</td>
<td style="text-align: center;">5.60</td>
<td style="text-align: center;">1.64</td>
<td style="text-align: center;">0.89</td>
<td style="text-align: center;">23.2</td>
</tr>
<tr class="odd">
<td style="text-align: left;">kaiming_normal</td>
<td style="text-align: center;">0.45</td>
<td style="text-align: center;">0.33</td>
<td style="text-align: center;">5.52</td>
<td style="text-align: center;">1.98</td>
<td style="text-align: center;">0.89</td>
<td style="text-align: center;">23.2</td>
</tr>
<tr class="even">
<td style="text-align: left;">orthogonal</td>
<td style="text-align: center;">0.49</td>
<td style="text-align: center;">0.33</td>
<td style="text-align: center;">1.00</td>
<td style="text-align: center;">0.88</td>
<td style="text-align: center;">0.95</td>
<td style="text-align: center;">23.3</td>
</tr>
<tr class="odd">
<td style="text-align: left;">scaled_orthogonal</td>
<td style="text-align: center;">2.30</td>
<td style="text-align: center;">1.00</td>
<td style="text-align: center;">1.00</td>
<td style="text-align: center;">0.13</td>
<td style="text-align: center;">0.95</td>
<td style="text-align: center;">23.3</td>
</tr>
<tr class="even">
<td style="text-align: left;">l-momentum</td>
<td style="text-align: center;">nan</td>
<td style="text-align: center;">0.00</td>
<td style="text-align: center;">5.78</td>
<td style="text-align: center;">20.30</td>
<td style="text-align: center;">0.89</td>
<td style="text-align: center;">23.2</td>
</tr>
</tbody>
</table>
<p>실험 결과에서 주목할 점은 다음과 같습니다.</p>
<ol type="1">
<li><p><strong>Kaiming 초기화의 우수한 성능:</strong> Kaiming 초기화가 0.45%로 가장 낮은 오차율을 보였습니다. 이는 ReLU 활성화 함수와의 최적의 조합을 보여주는 결과로, Kaiming 초기화가 ReLU 계열 함수와 함께 사용될 때 효과적임을 재확인합니다.</p></li>
<li><p><strong>Orthogonal 계열의 안정성:</strong> Orthogonal 초기화는 조건수가 1.00으로 가장 뛰어난 수치적 안정성을 보였습니다. 이는 학습 과정에서 그래디언트가 왜곡되지 않고 잘 전파됨을 의미하며, 특히 순환 신경망(RNN)과 같이 가중치 행렬이 반복적으로 곱해지는 모델에서 중요합니다. <em>하지만, 이 실험에서는 오차율이 상대적으로 높게 나타났는데, 이는 실험에 사용된 모델(단순한 MLP)의 특성 때문일 수 있습니다.</em></p></li>
<li><p><strong>Scaled Orthogonal 초기화의 문제점:</strong> Scaled Orthogonal 초기화는 오차율이 2.30%로 매우 높게 나타났습니다. 이는 이 초기화 방법이 주어진 모델 및 데이터셋에 적합하지 않거나, 추가적인 하이퍼파라미터 조정이 필요함을 시사합니다. <em>스케일링 팩터(scaling factor)가 너무 작아서 학습이 제대로 이루어지지 않았을 가능성이 있습니다.</em></p></li>
<li><p><strong>L-Momentum 초기화의 불안정성</strong>: L-Momentum은 오차율과 수렴속도가 nan과 0.00으로, 학습이 전혀 되지 않았습니다. 스펙트럴 놈이 20.30으로 매우 높은 것은 가중치 초기값이 너무 커서 발산했을 가능성이 있습니다.</p></li>
</ol>
</section>
<section id="실무적-권장사항-및-추가-고려-사항" class="level3">
<h3 class="anchored" data-anchor-id="실무적-권장사항-및-추가-고려-사항">5.1.3 실무적 권장사항 및 추가 고려 사항</h3>
<p>딥러닝 모델 초기화는 모델의 아키텍처, 활성화 함수, 최적화 알고리즘, 그리고 데이터셋의 특성까지 고려하여 신중하게 선택해야 하는 <em>하이퍼파라미터</em>입니다. 다음은 실무에서 초기화 방법을 선택할 때 고려해야 할 사항들입니다.</p>
<section id="기본-원칙" class="level5">
<h5 class="anchored" data-anchor-id="기본-원칙">기본 원칙</h5>
<ul>
<li><strong>ReLU 계열 활성화 함수:</strong>
<ul>
<li><strong>Kaiming 초기화 (He 초기화):</strong> 현재 ReLU 및 그 변형(Leaky ReLU, ELU, SELU 등)을 사용할 때 가장 널리 사용되는 초기화 방법입니다. 실험 결과뿐만 아니라 이론적 배경(분산 보존)도 탄탄합니다.</li>
<li><strong>L-Momentum Initialization</strong>: 만약 Adam, AdamW와 같은 Momentum 계열의 옵티마이저를 사용한다면, 고려할 수 있습니다.</li>
</ul></li>
<li><strong>Sigmoid, Tanh 활성화 함수:</strong>
<ul>
<li><strong>Xavier 초기화 (Glorot 초기화):</strong> 이 활성화 함수들은 입력값이 너무 크거나 작으면 기울기가 소실되는 문제(vanishing gradient problem)가 발생할 수 있으므로, Xavier 초기화가 여전히 유효한 선택입니다.</li>
</ul></li>
<li><strong>순환 신경망 (RNN, LSTM, GRU):</strong>
<ul>
<li><strong>Orthogonal 초기화:</strong> 순환 연결(recurrent connection)을 갖는 RNN 계열 모델에서는 가중치 행렬의 특이값을 1 근처로 유지하는 것이 중요합니다. Orthogonal 초기화는 이를 보장하여, 그래디언트 폭발/소실 문제를 완화하고 장기 의존성(long-range dependency) 학습을 돕습니다.</li>
<li><em>주의: Orthogonal 초기화는 RNN의 hidden-to-hidden 가중치 행렬에 적용하고, input-to-hidden 가중치 행렬에는 다른 초기화 방법(예: Kaiming)을 사용하는 것이 일반적입니다.</em></li>
</ul></li>
</ul>
</section>
<section id="모델-규모-및-특성" class="level5">
<h5 class="anchored" data-anchor-id="모델-규모-및-특성">모델 규모 및 특성</h5>
<ul>
<li><strong>일반적인 심층 신경망 (50층 미만):</strong>
<ul>
<li>Kaiming 초기화 (ReLU 계열) 또는 Xavier 초기화 (Sigmoid/Tanh 계열)로 충분한 경우가 많습니다.</li>
</ul></li>
<li><strong>매우 깊은 신경망 (50층 이상):</strong>
<ul>
<li><strong>Residual connections (ResNet):</strong> 잔차 연결(residual connection)이 있는 경우, Kaiming 초기화가 잘 작동합니다.</li>
<li><strong>Residual connections (ResNet)이 없는 경우</strong>: 초기화에 더 신중해야 합니다. Scaled Orthogonal, Fixup Initialization 등 고려.</li>
</ul></li>
<li><strong>대규모 모델 (1B+ 파라미터):</strong>
<ul>
<li><strong>L-Momentum Initialization</strong></li>
<li><strong>Zero Initialization (특정 부분):</strong> Transformer 모델의 일부(예: attention layer의 output projection)를 0으로 초기화하는 것이 효과적일 수 있습니다. (참고: Megatron-LM)</li>
<li><em>주의: 대규모 모델은 학습이 불안정해지기 쉬우므로, 초기화 외에도 학습률 스케줄링, 그래디언트 클리핑, 정규화 기법 등을 신중하게 조합해야 합니다.</em></li>
</ul></li>
</ul>
</section>
<section id="추가-고려-사항" class="level5">
<h5 class="anchored" data-anchor-id="추가-고려-사항">추가 고려 사항</h5>
<ul>
<li><strong>배치 정규화 (Batch Normalization) / 레이어 정규화 (Layer Normalization):</strong> 정규화 기법은 초기화의 중요성을 <em>다소</em> 감소시키지만, 완전히 대체하지는 못합니다. 여전히 적절한 초기화를 선택하는 것이 좋습니다.</li>
<li><strong>전이 학습 (Transfer Learning):</strong> 사전 학습된(pretrained) 모델을 사용하는 경우, 사전 학습된 가중치를 그대로 사용하거나, 미세 조정(fine-tuning)하는 레이어에 대해서만 작은 학습률과 함께 Kaiming/Xavier 초기화를 적용하는 것이 일반적입니다.</li>
<li><strong>최적화 알고리즘:</strong> 사용하는 옵티마이저에 따라 궁합이 좋은 초기화 방식이 있습니다. 예를 들어 Adam 옵티마이저를 사용한다면 L-Momentum 초기화를 사용할 수 있습니다.</li>
<li><strong>실험 및 검증:</strong> 가장 좋은 초기화 방법은 문제와 데이터에 따라 달라질 수 있습니다. 따라서, 여러 초기화 방법을 시도해보고, 검증 데이터셋(validation set)에서 가장 좋은 성능을 보이는 방법을 선택하는 것이 중요합니다.</li>
</ul>
<p>초기화는 딥러닝 모델 학습의 “숨겨진 영웅”과 같습니다. 올바른 초기화는 모델 학습의 성패를 좌우할 수 있으며, 모델의 성능을 극대화하고 학습 시간을 단축하는 데 결정적인 역할을 합니다. 이 절에서 제시된 지침과 최신 연구 동향을 바탕으로, 여러분의 딥러닝 모델에 가장 적합한 초기화 전략을 찾으시길 바랍니다.</p>
</section>
</section>
</section>
<section id="최적화-알고리즘-딥러닝-학습의-핵심-엔진" class="level2">
<h2 class="anchored" data-anchor-id="최적화-알고리즘-딥러닝-학습의-핵심-엔진">5.2 최적화 알고리즘: 딥러닝 학습의 핵심 엔진</h2>
<blockquote class="blockquote">
<p><strong>도전과제:</strong> 경사하강법(Gradient Descent)이 지역 최솟값(local minima)에 빠지거나, 학습 속도가 너무 느린 문제를 어떻게 해결할 수 있을까?</p>
<p><strong>연구자의 고뇌:</strong> 단순히 학습률을 줄이는 것만으로는 충분하지 않았습니다. 어떤 경우에는 학습이 너무 느려져 시간이 오래 걸리고, 어떤 경우에는 발산하여 학습에 실패했습니다. 마치 안개 낀 산길을 더듬어 내려가는 것처럼, 최적점을 찾아가는 길은 험난했습니다. 모멘텀, RMSProp, Adam 등 다양한 최적화 알고리즘이 등장했지만, 여전히 모든 문제에 완벽하게 들어맞는 만능 해결책은 없었습니다.</p>
</blockquote>
<p>딥러닝의 눈부신 발전은 모델 구조의 혁신뿐만 아니라, <em>효율적인 최적화 알고리즘의 발전</em>과 함께 이루어졌습니다. 최적화 알고리즘은 손실 함수(loss function)의 최솟값을 찾아가는 과정을 자동화하고 가속화하는 핵심 엔진과 같습니다. <em>이 엔진이 얼마나 효율적으로, 그리고 안정적으로 작동하느냐에 따라 딥러닝 모델의 학습 속도와 최종 성능이 결정됩니다.</em></p>
<section id="최적화-알고리즘의-발전과-구현---계속되는-진화" class="level3">
<h3 class="anchored" data-anchor-id="최적화-알고리즘의-발전과-구현---계속되는-진화">5.2.1 최적화 알고리즘의 발전과 구현 - 계속되는 진화</h3>
<p>최적화 알고리즘은 지난 수십 년간, <em>마치 생명체가 진화하듯,</em> 세 가지 핵심 과제를 해결하며 발전해 왔습니다.</p>
<ol type="1">
<li><p><strong>계산 효율성(Computational Efficiency):</strong> 한정된 컴퓨팅 자원으로 최대한 빠르게 학습을 완료해야 합니다.</p></li>
<li><p><strong>일반화 성능(Generalization Performance):</strong> 훈련 데이터뿐만 아니라, 새로운 데이터에서도 좋은 성능을 내야 합니다.</p></li>
<li><p><strong>확장성(Scalability):</strong> 모델과 데이터의 크기가 커져도 안정적으로 작동해야 합니다.</p></li>
</ol>
<p>각각의 도전 과제는 새로운 알고리즘의 탄생으로 이어졌고, 더 나은 알고리즘을 찾기 위한 경쟁은 지금도 계속되고 있습니다.</p>
<section id="최적화-알고리즘의-역사" class="level5">
<h5 class="anchored" data-anchor-id="최적화-알고리즘의-역사">최적화 알고리즘의 역사</h5>
<ul>
<li><strong>1847년, 코시(Cauchy):</strong> 경사하강법(Gradient Descent)을 제안했습니다. 손실 함수의 기울기(gradient)를 따라 파라미터를 조금씩 조정하는 이 단순하면서도 강력한 아이디어는 현대 딥러닝 최적화의 초석이 되었습니다.</li>
<li><strong>1951년, 로빈스(Robbins)와 먼로(Monro):</strong> 확률적 경사하강법(Stochastic Gradient Descent, SGD)의 수학적 기반을 확립했습니다. SGD는 전체 데이터셋 대신 미니배치(mini-batch)를 사용하여 계산 효율성을 크게 향상시켰습니다.</li>
<li><strong>1986년, 루멜하트(Rumelhart):</strong> 역전파(Backpropagation) 알고리즘과 함께 모멘텀(Momentum) 방법을 제안했습니다. 모멘텀은 최적화 과정에 관성을 부여하여, SGD의 진동(oscillation) 문제를 완화하고 수렴 속도를 개선했습니다.</li>
<li><strong>2011년, 듀치(Duchi):</strong> AdaGrad(Adaptive Gradient) 알고리즘을 발표했습니다. AdaGrad는 파라미터별로 학습률을 다르게 조정하는 적응형 학습률(adaptive learning rate) 방법의 시초가 되었습니다.</li>
<li><strong>2012년, 힌튼(Hinton):</strong> RMSProp을 제안했습니다. (강의 노트에서 소개, 논문 발표는 X) RMSProp은 AdaGrad의 학습률 감소 문제를 개선하여, 더 안정적인 학습을 가능하게 했습니다.</li>
<li><strong>2014년, 킹마(Kingma)와 바(Ba):</strong> Adam(Adaptive Moment Estimation)을 발표했습니다. Adam은 모멘텀과 RMSProp의 장점을 결합하여, 현재 가장 널리 사용되는 최적화 알고리즘 중 하나가 되었습니다.</li>
</ul>
<p>최근의 최적화 알고리즘은 다음 세 가지 주요 방향으로 발전하고 있습니다.</p>
<ol type="1">
<li><strong>메모리 효율성:</strong> Lion, AdaFactor 등은 대규모 모델(특히 Transformer 기반)의 학습에 필요한 메모리 사용량을 줄이는 데 초점을 맞춥니다.</li>
<li><strong>분산 학습 최적화:</strong> LAMB, LARS 등은 여러 개의 GPU/TPU를 사용하여 대규모 모델을 병렬로 학습할 때 효율성을 높입니다.</li>
<li><strong>도메인/태스크 특화 최적화:</strong> Sophia, AdaBelief 등은 특정 문제 영역(예: 자연어 처리, 컴퓨터 비전) 또는 특정 모델 구조에 최적화된 성능을 제공합니다.</li>
</ol>
<p><em>특히, 대규모 언어 모델(LLM)과 멀티모달 모델의 등장으로 인해, 수십억, 수천억 개의 파라미터를 효율적으로 최적화하고, 제한된 메모리 환경에서 학습하며, 분산 환경에서 안정적으로 수렴시키는 것이 더욱 중요해졌습니다. 이러한 도전 과제는 8비트 최적화, ZeRO 최적화, 그래디언트 체크포인팅과 같은 새로운 기술들의 등장을 이끌었습니다.</em></p>
</section>
<section id="기본-최적화-알고리즘" class="level5">
<h5 class="anchored" data-anchor-id="기본-최적화-알고리즘">기본 최적화 알고리즘</h5>
<p>딥러닝에서 최적화 알고리즘은 손실 함수의 최솟값을 찾아가는, 즉 모델의 최적 파라미터를 찾아가는 핵심적인 역할을 수행합니다. 각 알고리즘은 고유한 특징과 장단점을 가지고 있으며, 문제의 특성과 모델의 구조에 따라 적합한 알고리즘을 선택하는 것이 중요합니다.</p>
<p><strong>SGD와 모멘텀</strong></p>
<p>확률적 경사 하강법(Stochastic Gradient Descent, SGD)은 가장 기본적이면서도 널리 사용되는 최적화 알고리즘입니다. 매 스텝마다 미니배치(mini-batch) 데이터를 사용하여 손실 함수의 그래디언트(gradient)를 계산하고, 그 반대 방향으로 파라미터를 업데이트합니다.</p>
<ul>
<li><p><strong>파라미터 업데이트 수식:</strong></p>
<p><span class="math display">\[w^{(t)} = w^{(t-1)} - \eta \cdot g^{(t)}\]</span></p>
<ul>
<li><span class="math inline">\(w^{(t)}\)</span>: <span class="math inline">\(t\)</span>번째 스텝에서의 파라미터 (가중치)</li>
<li><span class="math inline">\(\eta\)</span>: 학습률 (learning rate)</li>
<li><span class="math inline">\(g^{(t)}\)</span>: <span class="math inline">\(t\)</span>번째 스텝에서 계산된 그래디언트</li>
</ul></li>
</ul>
<p>모멘텀(Momentum)은 물리학의 운동량 개념을 도입하여 SGD를 개선한 방법입니다. 과거 그래디언트의 지수 가중 평균(exponential moving average)을 사용하여 최적화 경로에 관성을 부여함으로써, SGD의 진동 문제를 완화하고 수렴 속도를 높입니다.</p>
<ul>
<li><p><strong>모멘텀 업데이트 수식:</strong></p>
<p><span class="math display">\[v^{(t)} = \mu \cdot v^{(t-1)} + g^{(t)}\]</span></p>
<p><span class="math display">\[w^{(t)} = w^{(t-1)} - \eta \cdot v^{(t)}\]</span></p>
<ul>
<li><span class="math inline">\(\mu\)</span>: 모멘텀 계수 (일반적으로 0.9 또는 0.99)</li>
<li><span class="math inline">\(v^{(t)}\)</span>: <span class="math inline">\(t\)</span>번째 스텝에서의 속도(velocity)</li>
</ul></li>
</ul>
<p><em>학습에 사용되는 주요 최적화 알고리즘들의 구현 코드는 <code>chapter_05/optimizer/</code> 디렉토리에 포함되어 있습니다.</em> 다음은 SGD (모멘텀 포함) 알고리즘의 학습용 구현 예시입니다. 모든 최적화 알고리즘 클래스는 <code>BaseOptimizer</code> 클래스를 상속받아 학습 목적으로 간단히 구현되었습니다. (실제 PyTorch 등의 라이브러리에서는 효율성과 일반화를 위해 더 복잡하게 구현되어 있습니다.)</p>
<div id="cell-11" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> typing <span class="im">import</span> Iterable, List, Optional</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_05.optimizers.basic <span class="im">import</span> BaseOptimizer</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> SGD(BaseOptimizer):</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Implements SGD with momentum."""</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, params: Iterable[nn.Parameter], lr: <span class="bu">float</span>, </span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>                 maximize: <span class="bu">bool</span> <span class="op">=</span> <span class="va">False</span>, momentum: <span class="bu">float</span> <span class="op">=</span> <span class="fl">0.0</span>):</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>(params, lr)</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.maximize <span class="op">=</span> maximize</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.momentum <span class="op">=</span> momentum</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.momentum_buffer_list: List[Optional[torch.Tensor]] <span class="op">=</span> [<span class="va">None</span>] <span class="op">*</span> <span class="bu">len</span>(<span class="va">self</span>.params)</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>    <span class="at">@torch.no_grad</span>()</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> step(<span class="va">self</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i, p <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="va">self</span>.params):</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>            grad <span class="op">=</span> p.grad <span class="cf">if</span> <span class="kw">not</span> <span class="va">self</span>.maximize <span class="cf">else</span> <span class="op">-</span>p.grad</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="va">self</span>.momentum <span class="op">!=</span> <span class="fl">0.0</span>:</span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>                buf <span class="op">=</span> <span class="va">self</span>.momentum_buffer_list[i]</span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> buf <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>                    buf <span class="op">=</span> torch.clone(grad).detach()</span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span>:</span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>                    buf.mul_(<span class="va">self</span>.momentum).add_(grad, alpha<span class="op">=</span><span class="dv">1</span><span class="op">-</span><span class="va">self</span>.momentum)</span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a>                grad <span class="op">=</span> buf</span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.momentum_buffer_list[i] <span class="op">=</span> buf</span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true" tabindex="-1"></a>            p.add_(grad, alpha<span class="op">=-</span><span class="va">self</span>.lr)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p><strong>적응형 학습률 알고리즘 (Adaptive Learning Rate Algorithms)</strong></p>
<p><em>딥러닝 모델의 파라미터는 각자 다른 빈도와 중요도로 업데이트됩니다. 적응형 학습률 알고리즘은 이러한 파라미터별 특성에 맞춰 학습률을 개별적으로 조정하는 방법입니다.</em></p>
<ul>
<li><p><strong>AdaGrad (Adaptive Gradient, 2011):</strong></p>
<ul>
<li><p><strong>핵심 아이디어:</strong> 자주 업데이트되는 파라미터에는 작은 학습률을, 드물게 업데이트되는 파라미터에는 큰 학습률을 적용합니다.</p></li>
<li><p><strong>수식:</strong></p>
<p><span class="math inline">\(w^{(t)} = w^{(t-1)} - \frac{\eta}{\sqrt{G^{(t)} + \epsilon}} \cdot g^{(t)}\)</span></p>
<ul>
<li><span class="math inline">\(G^{(t)}\)</span>: 과거 그래디언트 제곱의 누적 합</li>
<li><span class="math inline">\(\epsilon\)</span>: 0으로 나누는 것을 방지하기 위한 작은 상수 (예: <span class="math inline">\(10^{-8}\)</span>)</li>
</ul></li>
<li><p><strong>장점:</strong> 희소한 데이터(sparse data)를 다룰 때 효과적입니다.</p></li>
<li><p><strong>단점:</strong> 학습이 진행될수록 학습률이 단조 감소하여, 학습이 조기에 멈출 수 있습니다.</p></li>
</ul></li>
<li><p><strong>RMSProp (Root Mean Square Propagation, 2012):</strong></p>
<ul>
<li><p><strong>핵심 아이디어:</strong> AdaGrad의 학습률 감소 문제를 해결하기 위해, 과거 그래디언트 제곱의 합 대신 지수 이동 평균(exponential moving average)을 사용합니다.</p></li>
<li><p><strong>수식:</strong></p>
<p><span class="math inline">\(v^{(t)} = \beta \cdot v^{(t-1)} + (1-\beta) \cdot (g^{(t)})^2\)</span></p>
<p><span class="math inline">\(w^{(t)} = w^{(t-1)} - \frac{\eta}{\sqrt{v^{(t)} + \epsilon}} \cdot g^{(t)}\)</span></p>
<ul>
<li><span class="math inline">\(\beta\)</span>: 과거 그래디언트 제곱의 영향력을 조절하는 감쇠율(decay rate) (일반적으로 0.9)</li>
</ul></li>
<li><p><strong>장점:</strong> AdaGrad보다 학습률 감소 문제가 완화되어, 더 오랫동안 효과적인 학습이 가능합니다.</p></li>
</ul></li>
</ul>
<p><strong>Adam (Adaptive Moment Estimation, 2014):</strong></p>
<p><em>Adam은 현재 가장 널리 사용되는 최적화 알고리즘 중 하나로, 모멘텀(Momentum)과 RMSProp의 아이디어를 결합한 방법입니다.</em></p>
<ul>
<li><p><strong>핵심 아이디어:</strong></p>
<ul>
<li>모멘텀: 과거 그래디언트의 지수 이동 평균(1차 모멘트)을 사용하여 관성 효과를 줍니다.</li>
<li>RMSProp: 과거 그래디언트 제곱의 지수 이동 평균(2차 모멘트)을 사용하여 파라미터별 학습률을 조정합니다.</li>
<li>편향 보정(Bias Correction): 초기 단계에서 1차 및 2차 모멘트가 0으로 편향되는 것을 보정합니다.</li>
</ul></li>
<li><p><strong>수식:</strong></p>
<p><span class="math inline">\(m^{(t)} = \beta\_1 \cdot m^{(t-1)} + (1-\beta\_1) \cdot g^{(t)}\)</span></p>
<p><span class="math inline">\(v^{(t)} = \beta\_2 \cdot v^{(t-1)} + (1-\beta\_2) \cdot (g^{(t)})^2\)</span></p>
<p><span class="math inline">\(\hat{m}^{(t)} = \frac{m^{(t)}}{1-\beta\_1^t}\)</span></p>
<p><span class="math inline">\(\hat{v}^{(t)} = \frac{v^{(t)}}{1-\beta\_2^t}\)</span></p>
<p><span class="math inline">\(w^{(t)} = w^{(t-1)} - \eta \cdot \frac{\hat{m}^{(t)}}{\sqrt{\hat{v}^{(t)}} + \epsilon}\)</span></p>
<ul>
<li><span class="math inline">\(\beta_1\)</span>: 1차 모멘트(모멘텀)의 감쇠율 (일반적으로 0.9)</li>
<li><span class="math inline">\(\beta_2\)</span>: 2차 모멘트(RMSProp)의 감쇠율 (일반적으로 0.999)</li>
</ul></li>
</ul>
<p>위에 제시된 최적화 알고리즘들은 각각 고유한 장단점을 가지며, 문제의 특성, 모델 구조, 데이터 등에 따라 적절한 알고리즘을 선택해야 합니다. Adam은 많은 경우에 좋은 성능을 보이지만, 때로는 SGD + Momentum 조합이 더 나은 일반화 성능을 보이거나, 특정 문제에서는 다른 적응형 학습률 알고리즘(예: RMSProp)이 더 효과적일 수 있습니다. 따라서, 실험을 통해 최적의 알고리즘을 찾는 것이 중요합니다.</p>
</section>
<section id="현대적-최적화-알고리즘-더-빠르고-더-효율적으로-더-큰-모델을-위해" class="level5">
<h5 class="anchored">현대적 최적화 알고리즘: 더 빠르고, 더 효율적으로, 더 큰 모델을 위해</h5>
<p>최근 딥러닝 모델과 데이터셋의 규모가 폭발적으로 증가하면서, <em>메모리 효율성, 빠른 수렴 속도, 그리고 대규모 분산 학습</em>을 지원하는 새로운 최적화 알고리즘에 대한 요구가 높아지고 있습니다. 다음은 이러한 요구에 부응하여 등장한 최신 알고리즘들입니다.</p>
<ul>
<li><p><strong>Lion (Evolved Sign Momentum, 2023):</strong></p>
<ul>
<li><strong>핵심 아이디어:</strong> Google Research에서 프로그램 탐색(program search)을 통해 발견한 알고리즘으로, Adam과 유사하게 모멘텀을 사용하지만, 그래디언트의 부호(sign)만을 사용하여 업데이트를 수행합니다. 즉, 그래디언트의 크기는 무시하고 방향만 고려합니다.</li>
<li><strong>장점:</strong>
<ul>
<li>Adam에 비해 메모리 사용량이 적습니다 (2차 모멘트를 저장할 필요가 없음).</li>
<li>모든 파라미터에 대해 동일한 크기의 업데이트를 수행하므로, 희소 그래디언트(sparse gradient)를 갖는 문제(예: 자연어 처리)에서 효과적입니다.</li>
<li>Adam보다 더 큰 학습률을 사용할 수 있습니다.</li>
<li>경험적으로, 많은 경우 AdamW보다 더 나은 성능을 보입니다.</li>
</ul></li>
<li><strong>단점:</strong>
<ul>
<li>그래디언트의 크기 정보를 무시하므로, 특정 문제에서는 Adam보다 느리게 수렴하거나 성능이 낮을 수 있습니다.</li>
<li>학습률 튜닝에 더 민감할 수 있습니다.</li>
<li>더 자세한 내용은 딥다이브를 참고하면 됩니다.</li>
</ul></li>
</ul></li>
<li><p><strong>Sophia (Second-order Clipped Stochastic Optimization, 2023):</strong></p>
<ul>
<li><strong>핵심 아이디어:</strong> 2차 미분 정보(헤시안 행렬)를 활용하지만, 계산 비용을 줄이기 위해 헤시안의 대각 성분만을 추정하여 사용하고, 업데이트에 클리핑(clipping)을 적용하여 안정성을 높입니다.</li>
<li><strong>장점:</strong> Adam 보다 빠른 수렴과 안정적인 학습</li>
<li><strong>단점:</strong> Adam보다 더 많은 하이퍼파라미터(예: 헤시안 추정 빈도, 클리핑 임계값)를 튜닝해야 합니다.</li>
<li>더 자세한 내용은 딥다이브를 참고하면 됩니다.</li>
</ul></li>
<li><p><strong>AdaFactor (2018):</strong></p>
<ul>
<li><strong>핵심 아이디어:</strong> 대규모 모델(특히 Transformer)의 메모리 사용량을 줄이기 위해 제안된 알고리즘으로, Adam에서 2차 모멘트 행렬을 저차원 행렬의 곱으로 근사합니다.</li>
<li><strong>장점:</strong> Adam에 비해 메모리 사용량이 significantly 적습니다.</li>
<li><strong>단점:</strong> 2차 모멘트 정보를 근사하기 때문에, 특정 문제에서는 Adam보다 성능이 낮을 수 있습니다.</li>
<li>더 자세한 내용은 딥다이브를 참고하면 됩니다.</li>
</ul></li>
</ul>
<p>최근 연구들은 위에서 소개된 알고리즘들(Lion, Sophia, AdaFactor)이 특정 조건에서 기존의 Adam/AdamW를 능가하는 성능을 보여줄 수 있음을 시사합니다.</p>
<ul>
<li><strong>Lion:</strong> 큰 배치 크기(large batch size)를 사용하는 학습에서 AdamW보다 빠르고, 메모리 사용량이 적으며, 더 나은 일반화 성능을 보이는 경향이 있습니다.</li>
<li><strong>Sophia:</strong> (특히 대규모 언어 모델의) 사전 학습(pre-training) 단계에서 Adam보다 더 빠르게 수렴하고, 더 낮은 perplexity(또는 더 높은 정확도)를 달성할 수 있습니다.</li>
<li><strong>AdaFactor:</strong> 메모리 사용량이 제한적인 환경에서 대규모 Transformer 모델을 학습할 때 Adam의 좋은 대안이 될 수 있습니다.</li>
</ul>
<p>하지만, 모든 문제에 대해 항상 최고의 성능을 보장하는 “만능” 최적화 알고리즘은 없습니다. 따라서, 실제 문제에 적용할 때에는 모델의 크기, 학습 데이터의 특성, 가용 자원(메모리, 컴퓨팅 파워), 분산 학습 여부 등을 종합적으로 고려하여 적절한 알고리즘을 선택하고, <em>반드시 실험과 검증을 통해 최적의 하이퍼파라미터를 찾아야 합니다.</em></p>
<p>이제 동작을 하는지 1 에포크 실험을 해보겠습니다.</p>
<div id="cell-14" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.nn <span class="im">as</span> nn</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_04.models.base <span class="im">import</span> SimpleNetwork</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_04.utils.data <span class="im">import</span> get_data_loaders, get_device</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_05.optimizers.basic <span class="im">import</span> Adam, SGD</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_05.optimizers.advanced <span class="im">import</span> Lion, Sophia</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_04.experiments.model_training <span class="im">import</span> train_model  <span class="co"># Corrected import</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>device <span class="op">=</span> get_device()</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> SimpleNetwork(act_func<span class="op">=</span>nn.ReLU(), hidden_shape<span class="op">=</span>[<span class="dv">512</span>, <span class="dv">64</span>]).to(device)</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Initialize SGD optimizer</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>optimizer <span class="op">=</span> SGD(params<span class="op">=</span>model.parameters(), lr<span class="op">=</span><span class="fl">1e-3</span>, momentum<span class="op">=</span><span class="fl">0.9</span>)</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a><span class="co"># # Initialize Adam optimizer</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a><span class="co"># optimizer = Adam(params=model.parameters(), lr=1e-3, beta1=0.9, beta2=0.999, eps=1e-8)</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a><span class="co"># # Initialize AdaGrad optimizer</span></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a><span class="co"># optimizer = AdaGrad(params=model.parameters(), lr=1e-2, eps=1e-10)</span></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a><span class="co"># # Initialize Lion optimizer</span></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a><span class="co"># optimizer = Lion(params=model.parameters(), lr=1e-4,  betas=(0.9, 0.99), weight_decay=0.0)</span></span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a><span class="co"># Initialize Sophia optimizer</span></span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a><span class="co"># optimizer = Sophia(params=model.parameters(), lr=1e-3, betas=(0.965, 0.99), rho=0.04, weight_decay=0.0, k=10)</span></span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true" tabindex="-1"></a>train_dataloader, test_dataloader <span class="op">=</span> get_data_loaders()</span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true" tabindex="-1"></a>train_model(model, train_dataloader, test_dataloader, device, optimizer<span class="op">=</span>optimizer, epochs<span class="op">=</span><span class="dv">1</span>, batch_size<span class="op">=</span><span class="dv">256</span>, save_dir<span class="op">=</span><span class="st">"./tmp/opts/ReLU"</span>, retrain<span class="op">=</span><span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>
Starting training for SimpleNetwork-ReLU.</code></pre>
</div>
<div class="cell-output cell-output-display">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id":"c406d6c56f5d409e87cd8759b19fd284","version_major":2,"version_minor":0,"quarto_mimetype":"application/vnd.jupyter.widget-view+json"}
</script>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Execution completed for SimpleNetwork-ReLU, Execution time = 7.4 secs</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="5">
<pre><code>{'epochs': [1],
 'train_losses': [2.2232478597005207],
 'train_accuracies': [0.20635],
 'test_losses': [2.128580910873413],
 'test_accuracies': [0.3466]}</code></pre>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled" title="클릭하여 내용 보기 (딥다이브: 현대 최적화 알고리즘의 심층 분석)">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-2-contents" aria-controls="callout-2" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
클릭하여 내용 보기 (딥다이브: 현대 최적화 알고리즘의 심층 분석)
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-2" class="callout-2-contents callout-collapse collapse">
<section id="현대-최적화-알고리즘의-심층-분석" class="level3 callout-body-container callout-body">
<h3 class="anchored" data-anchor-id="현대-최적화-알고리즘의-심층-분석">현대 최적화 알고리즘의 심층 분석</h3>
<section id="lion-evolved-sign-momentum" class="level4">
<h4 class="anchored" data-anchor-id="lion-evolved-sign-momentum">Lion (EvoLved Sign Momentum)</h4>
<p>Lion은 Google Research에서 AutoML 기법을 통해 발견한 최적화 알고리즘입니다. Adam과 유사하게 모멘텀을 사용하지만, 그래디언트의 크기 정보는 버리고 부호(sign)만 사용한다는 점이 가장 큰 특징입니다.</p>
<p><strong>핵심 아이디어:</strong></p>
<ul>
<li><strong>Sign Descent:</strong> 그래디언트의 부호만을 사용하여 업데이트 방향을 결정합니다. 이는 모든 파라미터에 대해 동일한 크기의 업데이트를 수행하도록 강제하여, 희소한 그래디언트(sparse gradient)를 갖는 문제(예: 자연어 처리)에서 효과적입니다.</li>
<li><strong>모멘텀:</strong> 이전 업데이트 방향을 고려하여 학습의 안정성과 속도를 높입니다.</li>
</ul>
<p><strong>수학적 원리:</strong></p>
<ol type="1">
<li><p><strong>업데이트 계산:</strong></p>
<p><span class="math inline">\(c\_t = \beta\_1 m\_{t-1} + (1 - \beta\_1) g\_t\)</span></p>
<ul>
<li><span class="math inline">\(c\_t\)</span>: 현재 단계의 업데이트 벡터. 모멘텀(<span class="math inline">\(m\_{t-1}\)</span>)과 현재 그래디언트(<span class="math inline">\(g\_t\)</span>)의 가중 평균입니다.</li>
<li><span class="math inline">\(\beta\_1\)</span>: 모멘텀의 지수 감소율 (일반적으로 0.9 또는 0.99).</li>
</ul></li>
<li><p><strong>가중치 업데이트:</strong></p>
<p><span class="math inline">\(w\_{t+1} = w\_t - \eta \cdot \text{sign}(c\_t)\)</span></p>
<ul>
<li><span class="math inline">\(\eta\)</span>: 학습률</li>
<li><span class="math inline">\(\text{sign}(c\_t)\)</span>: <span class="math inline">\(c\_t\)</span>의 각 요소의 부호 (+1 또는 -1). 0인 경우는 0.</li>
</ul></li>
<li><p><strong>모멘텀 업데이트:</strong></p>
<p><span class="math inline">\(m\_t = c\_t\)</span></p>
<ul>
<li>업데이트 계산에 사용된 값을 다음 스텝의 모멘텀으로 그대로 사용합니다.</li>
</ul></li>
</ol>
<p><strong>장점:</strong></p>
<ul>
<li><strong>메모리 효율성:</strong> Adam과 달리 2차 모멘트(분산)를 저장할 필요가 없어 메모리 사용량이 적습니다.</li>
<li><strong>계산 효율성:</strong> sign 연산은 곱셈보다 계산 비용이 저렴합니다.</li>
<li><strong>희소성에 강건:</strong> 모든 파라미터가 동일한 크기로 업데이트되므로, 희소한 그래디언트를 갖는 문제에서 효과적입니다.</li>
</ul>
<p><strong>단점:</strong></p>
<ul>
<li>그래디언트의 크기 정보를 무시하므로, 특정 문제에서는 Adam보다 느리게 수렴하거나 성능이 낮을 수 있습니다.</li>
<li>학습률 튜닝에 더 민감할 수 있습니다.</li>
</ul>
<p><strong>참고:</strong></p>
<ul>
<li>Lion은 L1 정규화와 유사한 효과를 갖는다는 분석이 있습니다. (자세한 내용은 추가 연구 필요)</li>
<li><a href="https://www.google.com/url?sa=E&amp;source=gmail&amp;q=https://arxiv.org/abs/2302.06675">Chen et al., 2023</a> 논문에서는 BERT-Large 모델 학습 시, Lion이 AdamW보다 최대 2배 빠른 수렴 속도를 보였고, 메모리 사용량도 감소했다고 보고했습니다. 하지만 이는 특정 실험 결과이며, 모든 경우에 일반화될 수는 없습니다.</li>
</ul>
</section>
<section id="sophia-second-order-clipped-stochastic-optimization" class="level4">
<h4 class="anchored" data-anchor-id="sophia-second-order-clipped-stochastic-optimization">Sophia (Second-order Clipped Stochastic Optimization)</h4>
<p>Sophia는 2차 미분 정보(헤시안 행렬)를 활용하여 학습 속도와 안정성을 높이는 최적화 알고리즘입니다. 하지만 헤시안 행렬을 직접 계산하는 것은 계산 비용이 매우 크기 때문에, Sophia는 헤시안의 대각 성분만을 <em>Hutchinson’s method</em>를 개선하여 추정합니다.</p>
<p><strong>핵심 아이디어:</strong></p>
<ul>
<li><strong>경량 헤시안 추정:</strong> Hutchinson’s method를 개선하여 헤시안 행렬의 대각 성분만을 효율적으로 추정합니다.
<ul>
<li>기존 Hutchinson’s method는 <span class="math inline">\(h\_t = \mathbb{E}[z\_t z\_t^T H\_t] = diag(H\_t)\)</span> 를 이용, 여기서 z는 랜덤벡터</li>
<li>개선: 공분산을 사용하여 분산을 줄입니다.</li>
</ul></li>
<li><strong>클리핑(Clipping):</strong> 추정된 헤시안을 사용하여 그래디언트를 업데이트하기 전에, 업데이트 크기를 제한(clip)하여 학습의 안정성을 높입니다.</li>
</ul>
<p><strong>수학적 원리:</strong></p>
<ol type="1">
<li><p><strong>Hessian Diagonal Estimation:</strong></p>
<ul>
<li><p>매 스텝, 랜덤 벡터 <span class="math inline">\(z\_t\)</span>를 샘플링합니다 (<span class="math inline">\(z\_t\)</span>의 각 원소는 {-1, +1}에서 균등 분포로 선택).</p></li>
<li><p>헤시안 대각선의 추정치 <span class="math inline">\(h\_t\)</span>를 다음과 같이 계산합니다.</p>
<p><span class="math inline">\(h\_t = \beta\_2 h\_{t-1} + (1 - \beta\_2) \text{diag}(H\_t z\_t) z\_t^T\)</span></p>
<p>(여기서 <span class="math inline">\(H\_t\)</span>는 t 스텝의 헤시안)</p></li>
<li><p>Sophia는 Hutchinson’s estimator의 분산을 줄이기 위해, 과거 추정치(<span class="math inline">\(h\_{t-1}\)</span>)를 활용하는 지수 이동 평균(EMA)을 사용합니다.</p></li>
</ul></li>
<li><p><strong>업데이트 계산:</strong></p>
<ul>
<li><span class="math inline">\(m\_t = \beta\_1 m\_{t-1} + (1 - \beta\_1) g\_t\)</span> (모멘텀)</li>
<li><span class="math inline">\(u\_t = \text{clip}(m\_t / (h\_t + \epsilon), \rho)\)</span>
<ul>
<li><span class="math inline">\(u\_t\)</span>: 헤시안으로 나눈 후 클리핑된 업데이트.</li>
<li><span class="math inline">\(\text{clip}(x, \rho) = \text{sign}(x) \cdot \min(|x|, \rho)\)</span>.</li>
<li><span class="math inline">\(\rho\)</span>: 클리핑 임계값 (하이퍼파라미터)</li>
<li><span class="math inline">\(h\_t + \epsilon\)</span> 은 <span class="math inline">\(h\_t\)</span>의 각 원소별로 <span class="math inline">\(\epsilon\)</span>이 더해지는 연산</li>
</ul></li>
</ul></li>
<li><p><strong>가중치 업데이트:</strong></p>
<p><span class="math inline">\(w\_{t+1} = w\_t - \eta \cdot u\_t\)</span></p>
<ul>
<li><span class="math inline">\(\eta\)</span>: 학습률</li>
</ul></li>
</ol>
<p><strong>장점:</strong></p>
<ul>
<li><strong>빠른 수렴:</strong> 2차 미분 정보를 활용하여 Adam보다 빠르게 수렴할 수 있습니다.</li>
<li><strong>안정성:</strong> 클리핑을 통해 학습의 안정성을 높입니다.</li>
</ul>
<p><strong>단점:</strong></p>
<ul>
<li>Adam보다 더 많은 하이퍼파라미터(<span class="math inline">\(\beta\_1\)</span>, <span class="math inline">\(\beta\_2\)</span>, <span class="math inline">\(\rho\)</span>)를 튜닝해야 합니다.</li>
<li>헤시안 추정의 정확도에 따라 성능이 달라질 수 있습니다.</li>
</ul>
<p><strong>참고:</strong></p>
<ul>
<li><a href="https://www.google.com/url?sa=E&amp;source=gmail&amp;q=https://arxiv.org/abs/2305.14342">Li et al., 2023</a> 논문에서는 Sophia가 언어 모델 사전 학습(pre-training)에서 Adam보다 적은 스텝 수로 더 낮은 손실(loss)을 달성했다고 보고했습니다. (정확도/perplexity 등의 metric 사용)</li>
</ul>
</section>
<section id="adafactor" class="level4">
<h4 class="anchored" data-anchor-id="adafactor">AdaFactor</h4>
<p>AdaFactor는 대규모 모델, 특히 트랜스포머(Transformer) 모델의 학습에 사용되는 메모리 효율적인 최적화 알고리즘입니다. Adam과 유사하게 적응형 학습률을 사용하지만, 2차 모멘트(분산)를 저장하는 방식을 개선하여 메모리 사용량을 크게 줄였습니다.</p>
<p><strong>핵심 아이디어:</strong></p>
<ul>
<li><strong>행렬 분해 (Matrix Factorization):</strong> 2차 모멘트 행렬을 두 개의 저차원 행렬(low-rank matrices)의 곱으로 근사하여 메모리 사용량을 줄입니다.</li>
</ul>
<p><strong>수학적 원리:</strong></p>
<p>Adam에서 <span class="math inline">\(n \times m\)</span> 크기의 가중치 행렬에 대한 2차 모멘트 행렬 <span class="math inline">\(v\_t\)</span>는 <span class="math inline">\(O(nm)\)</span> 크기의 메모리를 필요로 합니다. AdaFactor는 이 행렬을 다음과 같이 근사합니다.</p>
<ol type="1">
<li><p><strong>2차 모멘트 추정:</strong></p>
<ul>
<li><span class="math inline">\(v\_t\)</span> 대신, <span class="math inline">\(v\_t\)</span>의 각 행과 열의 합을 나타내는 두 개의 벡터 <span class="math inline">\(R\_t\)</span> (<span class="math inline">\(n \times 1\)</span>)와 <span class="math inline">\(C\_t\)</span> (<span class="math inline">\(m \times 1\)</span>)를 유지합니다.
<ul>
<li><span class="math inline">\(R\_t = \beta\_{2t} R\_{t-1} + (1 - \beta\_{2t}) (\text{row\_sum}(g\_t^2)/m)\)</span></li>
<li><span class="math inline">\(C\_t = \beta\_{2t} C\_{t-1} + (1 - \beta\_{2t}) (\text{col\_sum}(g\_t^2)/n)\)</span></li>
</ul></li>
<li><span class="math inline">\(R\_t\)</span>와 <span class="math inline">\(C\_t\)</span>는 각각 <span class="math inline">\(g\_t^2\)</span>의 행(row)과 열(column)의 합을 지수 이동 평균(exponential moving average)한 값입니다. (<span class="math inline">\(\beta\_{2t}\)</span>는 스케줄링)</li>
<li><span class="math inline">\(\hat{v\_t} = R\_t C\_t^T / (\text{sum}(R\_t) \cdot \text{sum}(C\_t))\)</span> 를 통해 근사</li>
</ul></li>
<li><p><strong>업데이트 계산:</strong></p>
<p><span class="math inline">\(u\_t =  g\_t / \sqrt{\hat{v\_t}}\)</span></p></li>
<li><p><strong>가중치 업데이트</strong> <span class="math inline">\(w\_{t+1} = w\_t - \eta \cdot u\_t\)</span></p></li>
</ol>
<p><strong>장점:</strong></p>
<ul>
<li><strong>메모리 효율성:</strong> <span class="math inline">\(O(nm)\)</span> 크기의 2차 모멘트 행렬 대신 <span class="math inline">\(O(n+m)\)</span> 크기의 벡터만 저장하므로 메모리 사용량이 크게 줄어듭니다.</li>
<li><strong>대규모 모델 학습:</strong> 메모리 효율성 덕분에 대규모 모델 학습에 적합합니다.</li>
</ul>
<p><strong>단점:</strong></p>
<ul>
<li>2차 모멘트 정보를 근사하기 때문에, 특정 문제에서는 Adam보다 성능이 낮을 수 있습니다.</li>
<li>행렬 분해로 인한 추가적인 계산 비용이 발생할 수 있습니다.</li>
</ul>
<p><strong>참고:</strong></p>
<ul>
<li><a href="https://www.google.com/url?sa=E&amp;source=gmail&amp;q=https://arxiv.org/abs/1804.04235">Shazeer &amp; Stern, 2018</a> 논문에서는 AdaFactor가 트랜스포머 모델 학습 시 메모리 사용량을 줄이면서도 Adam과 비슷한 성능을 달성했다고 보고했습니다.</li>
</ul>
</section>
<section id="그-외-참고할-만한-최신-최적화-알고리즘" class="level4">
<h4 class="anchored" data-anchor-id="그-외-참고할-만한-최신-최적화-알고리즘">그 외 참고할 만한 최신 최적화 알고리즘</h4>
<ul>
<li><strong>LAMB (Layer-wise Adaptive Moments optimizer for Batch training):</strong> 대규모 배치 학습에 특화된 알고리즘입니다. 각 레이어별로 학습률을 조정하여, 큰 배치 크기에서도 안정적인 학습을 가능하게 합니다. (참고: <a href="https://www.google.com/url?sa=E&amp;source=gmail&amp;q=https://arxiv.org/abs/1904.00962">You et al., 2019</a>)</li>
<li><strong>LARS (Layer-wise Adaptive Rate Scaling):</strong> LAMB와 유사하게 레이어별 학습률 조정을 사용하며, 큰 배치 학습에 효과적입니다. ResNet과 같은 이미지 분류 모델에서 주로 사용됩니다. (참고: <a href="https://www.google.com/url?sa=E&amp;source=gmail&amp;q=https://arxiv.org/abs/1708.03888">You et al., 2017</a>)</li>
</ul>
<hr>
</section>
</section>
</div>
</div>
</section>
</section>
<section id="최적화-훈련-비교" class="level3">
<h3 class="anchored" data-anchor-id="최적화-훈련-비교">5.2.2 최적화 훈련 비교</h3>
<p>최적화 알고리즘의 성능은 태스크와 모델 구조에 따라 크게 달라집니다. 실험을 통해 이러한 특성들을 분석해보겠습니다.</p>
<section id="기본-태스크-분석" class="level5">
<h5 class="anchored" data-anchor-id="기본-태스크-분석">기본 태스크 분석</h5>
<p>FashionMNIST 데이터셋으로 기본적인 성능을 비교합니다. 이 데이터셋은 실제 의류 이미지 분류 문제를 단순화한 것으로, 딥러닝 알고리즘의 기본 특성을 분석하기에 적합합니다.</p>
<div id="cell-17" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_05.experiments.basic <span class="im">import</span> run_basic_experiment</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_05.visualization.optimization <span class="im">import</span> plot_training_results</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_04.utils.data <span class="im">import</span> get_data_loaders</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_05.optimizers.basic <span class="im">import</span> SGD, Adam</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_05.optimizers.advanced <span class="im">import</span> Lion</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Device configuration</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>device <span class="op">=</span> torch.device(<span class="st">"cuda:0"</span> <span class="cf">if</span> torch.cuda.is_available() <span class="cf">else</span> <span class="st">"cpu"</span>)</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Data loaders</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>train_loader, test_loader <span class="op">=</span> get_data_loaders()</span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Optimizer dictionary</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>optimizers <span class="op">=</span> {</span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>    <span class="st">'SGD'</span>: SGD,</span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Adam'</span>: Adam,</span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Lion'</span>: Lion</span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Optimizer configurations</span></span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a>optimizer_configs <span class="op">=</span> {</span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a>    <span class="st">'SGD'</span>: {<span class="st">'lr'</span>: <span class="fl">0.01</span>, <span class="st">'momentum'</span>: <span class="fl">0.9</span>},</span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Adam'</span>: {<span class="st">'lr'</span>: <span class="fl">0.001</span>},</span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Lion'</span>: {<span class="st">'lr'</span>: <span class="fl">1e-4</span>}</span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb17-28"><a href="#cb17-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-29"><a href="#cb17-29" aria-hidden="true" tabindex="-1"></a><span class="co"># Run experiments</span></span>
<span id="cb17-30"><a href="#cb17-30" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> {}</span>
<span id="cb17-31"><a href="#cb17-31" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> name, config <span class="kw">in</span> optimizer_configs.items():</span>
<span id="cb17-32"><a href="#cb17-32" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Starting experiment with </span><span class="sc">{</span>name<span class="sc">}</span><span class="ss"> optimizer..."</span>)</span>
<span id="cb17-33"><a href="#cb17-33" aria-hidden="true" tabindex="-1"></a>    results[name] <span class="op">=</span> run_basic_experiment(</span>
<span id="cb17-34"><a href="#cb17-34" aria-hidden="true" tabindex="-1"></a>        optimizer_class<span class="op">=</span>optimizers[name],</span>
<span id="cb17-35"><a href="#cb17-35" aria-hidden="true" tabindex="-1"></a>        train_loader<span class="op">=</span>train_loader,</span>
<span id="cb17-36"><a href="#cb17-36" aria-hidden="true" tabindex="-1"></a>        test_loader<span class="op">=</span>test_loader,</span>
<span id="cb17-37"><a href="#cb17-37" aria-hidden="true" tabindex="-1"></a>        config<span class="op">=</span>config,</span>
<span id="cb17-38"><a href="#cb17-38" aria-hidden="true" tabindex="-1"></a>        device<span class="op">=</span>device,</span>
<span id="cb17-39"><a href="#cb17-39" aria-hidden="true" tabindex="-1"></a>        epochs<span class="op">=</span><span class="dv">20</span></span>
<span id="cb17-40"><a href="#cb17-40" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb17-41"><a href="#cb17-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-42"><a href="#cb17-42" aria-hidden="true" tabindex="-1"></a><span class="co"># Visualize training curves</span></span>
<span id="cb17-43"><a href="#cb17-43" aria-hidden="true" tabindex="-1"></a>plot_training_results(</span>
<span id="cb17-44"><a href="#cb17-44" aria-hidden="true" tabindex="-1"></a>    results,</span>
<span id="cb17-45"><a href="#cb17-45" aria-hidden="true" tabindex="-1"></a>    metrics<span class="op">=</span>[<span class="st">'loss'</span>, <span class="st">'accuracy'</span>, <span class="st">'gradient_norm'</span>, <span class="st">'memory'</span>],</span>
<span id="cb17-46"><a href="#cb17-46" aria-hidden="true" tabindex="-1"></a>    mode<span class="op">=</span><span class="st">"train"</span>,  <span class="co"># Changed mode to "train"</span></span>
<span id="cb17-47"><a href="#cb17-47" aria-hidden="true" tabindex="-1"></a>    title<span class="op">=</span><span class="st">'Optimizer Comparison on FashionMNIST'</span></span>
<span id="cb17-48"><a href="#cb17-48" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>
Starting experiment with SGD optimizer...

==================================================
Optimizer: SGD
Initial CUDA Memory Status (GPU 0):
Allocated: 23.0MB
Reserved: 48.0MB
Model Size: 283.9K parameters
==================================================
</code></pre>
</div>
<div class="cell-output cell-output-display">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id":"ada5e53909f54c17bd9780217a7549fc","version_major":2,"version_minor":0,"quarto_mimetype":"application/vnd.jupyter.widget-view+json"}
</script>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
==================================================
Final CUDA Memory Status (GPU 0):
Peak Allocated: 27.2MB
Peak Reserved: 48.0MB
Current Allocated: 25.2MB
Current Reserved: 48.0MB
==================================================


Starting experiment with Adam optimizer...

==================================================
Optimizer: Adam
Initial CUDA Memory Status (GPU 0):
Allocated: 25.2MB
Reserved: 48.0MB
Model Size: 283.9K parameters
==================================================
</code></pre>
</div>
<div class="cell-output cell-output-display">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id":"672f6e9f6a2c4916aa04a216cf6fa722","version_major":2,"version_minor":0,"quarto_mimetype":"application/vnd.jupyter.widget-view+json"}
</script>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
==================================================
Final CUDA Memory Status (GPU 0):
Peak Allocated: 28.9MB
Peak Reserved: 50.0MB
Current Allocated: 26.3MB
Current Reserved: 50.0MB
==================================================


Starting experiment with Lion optimizer...

==================================================
Optimizer: Lion
Initial CUDA Memory Status (GPU 0):
Allocated: 24.1MB
Reserved: 50.0MB
Model Size: 283.9K parameters
==================================================
</code></pre>
</div>
<div class="cell-output cell-output-display">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id":"df577f7a7c8042899f6580786f12b819","version_major":2,"version_minor":0,"quarto_mimetype":"application/vnd.jupyter.widget-view+json"}
</script>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
==================================================
Final CUDA Memory Status (GPU 0):
Peak Allocated: 27.2MB
Peak Reserved: 50.0MB
Current Allocated: 25.2MB
Current Reserved: 50.0MB
==================================================
</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="05_최적화와 시각화_files/figure-html/cell-7-output-8.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>실험 결과는 각 알고리즘의 특징을 보여줍니다. FashionMNIST 데이터셋과 MLP 모델을 사용한 실험에서 주요 관찰 결과는 다음과 같습니다.</p>
<ol type="1">
<li><strong>수렴 속도:</strong>
<ul>
<li>Adam과 Lion은 학습 초기에 매우 빠르게 수렴합니다. (처음 몇 에폭 내에 손실 급감, 정확도 빠르게 증가)</li>
<li>SGD는 상대적으로 느리고 꾸준한 수렴 패턴을 보입니다.</li>
</ul></li>
<li><strong>학습 곡선 안정성:</strong>
<ul>
<li>Adam은 매우 부드럽고 안정적인 학습 곡선을 보입니다.</li>
<li>Lion은 Adam과 유사하게 안정적이나, Accuracy 곡선에서 약간의 변동이 있습니다.</li>
<li>SGD는 Loss, Accuracy 곡선 모두에서 변동이 큽니다.</li>
</ul></li>
<li><strong>메모리 사용량:</strong>
<ul>
<li>Lion은 Adam보다 약간 적은 메모리를 사용하지만, 큰 차이는 아닙니다 (Adam: 약 26.2MB, Lion: 약 25.2MB).</li>
<li>SGD는 셋 중 가장 적은 메모리 사용.</li>
</ul></li>
<li><strong>그래디언트 노름:</strong>
<ul>
<li>Lion: 초기 그래디언트 노름이 매우 크고(약 4.0) 빠르게 감소, 낮은 값(약 1.5)에서 안정화됩니다. (초기 큰 보폭 탐색, 빠른 최적점 근처 이동)</li>
<li>Adam: Lion보다 작은 초기 그래디언트 노름(약 2.0), 빠르게 감소하여 더 낮은 값(약 1.0)에서 안정화됩니다. (적응형 학습률 조정)</li>
<li>SGD: 초기 그래디언트 노름이 가장 작고(약 0.3), 큰 변동을 보이며, 다른 알고리즘보다 높은 값(약 2.0-2.5)에서 진동합니다. (넓은 영역 탐색, flat minima 가능성 시사)</li>
</ul></li>
</ol>
<p>기본 실험에서 Adam과 Lion은 빠른 초기 수렴 속도, Adam은 가장 안정적인 학습, Lion은 약간 더 적은 메모리 사용, SGD는 넓은 범위 탐색 경향을 보였습니다.</p>
</section>
<section id="고급-태스크-평가" class="level5">
<h5 class="anchored" data-anchor-id="고급-태스크-평가">고급 태스크 평가</h5>
<p>CIFAR-100과 CNN/트랜스포머 모델에서는 최적화 알고리즘의 차이가 더욱 분명해집니다.</p>
<div id="cell-19" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_05.experiments.advanced <span class="im">import</span> run_advanced_experiment</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_05.visualization.optimization <span class="im">import</span> plot_training_results</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_04.utils.data <span class="im">import</span> get_data_loaders</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_05.optimizers.basic <span class="im">import</span> SGD, Adam</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_05.optimizers.advanced <span class="im">import</span> Lion</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Device configuration</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>device <span class="op">=</span> torch.device(<span class="st">"cuda:0"</span> <span class="cf">if</span> torch.cuda.is_available() <span class="cf">else</span> <span class="st">"cpu"</span>)</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Data loaders</span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>train_loader, test_loader <span class="op">=</span> get_data_loaders(dataset<span class="op">=</span><span class="st">"CIFAR100"</span>)</span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Optimizer dictionary</span></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>optimizers <span class="op">=</span> {</span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>    <span class="st">'SGD'</span>: SGD,</span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Adam'</span>: Adam,</span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Lion'</span>: Lion</span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Optimizer configurations</span></span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a>optimizer_configs <span class="op">=</span> {</span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a>    <span class="st">'SGD'</span>: {<span class="st">'lr'</span>: <span class="fl">0.01</span>, <span class="st">'momentum'</span>: <span class="fl">0.9</span>},</span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Adam'</span>: {<span class="st">'lr'</span>: <span class="fl">0.001</span>},</span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Lion'</span>: {<span class="st">'lr'</span>: <span class="fl">1e-4</span>}</span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-28"><a href="#cb22-28" aria-hidden="true" tabindex="-1"></a><span class="co"># Run experiments</span></span>
<span id="cb22-29"><a href="#cb22-29" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> {}</span>
<span id="cb22-30"><a href="#cb22-30" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> name, config <span class="kw">in</span> optimizer_configs.items():</span>
<span id="cb22-31"><a href="#cb22-31" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Starting experiment with </span><span class="sc">{</span>name<span class="sc">}</span><span class="ss"> optimizer..."</span>)</span>
<span id="cb22-32"><a href="#cb22-32" aria-hidden="true" tabindex="-1"></a>    results[name] <span class="op">=</span> run_advanced_experiment(</span>
<span id="cb22-33"><a href="#cb22-33" aria-hidden="true" tabindex="-1"></a>        optimizer_class<span class="op">=</span>optimizers[name],</span>
<span id="cb22-34"><a href="#cb22-34" aria-hidden="true" tabindex="-1"></a>        model_type<span class="op">=</span><span class="st">'cnn'</span>,</span>
<span id="cb22-35"><a href="#cb22-35" aria-hidden="true" tabindex="-1"></a>        train_loader<span class="op">=</span>train_loader,</span>
<span id="cb22-36"><a href="#cb22-36" aria-hidden="true" tabindex="-1"></a>        test_loader<span class="op">=</span>test_loader,</span>
<span id="cb22-37"><a href="#cb22-37" aria-hidden="true" tabindex="-1"></a>        config<span class="op">=</span>config,</span>
<span id="cb22-38"><a href="#cb22-38" aria-hidden="true" tabindex="-1"></a>        device<span class="op">=</span>device,</span>
<span id="cb22-39"><a href="#cb22-39" aria-hidden="true" tabindex="-1"></a>        epochs<span class="op">=</span><span class="dv">40</span></span>
<span id="cb22-40"><a href="#cb22-40" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb22-41"><a href="#cb22-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-42"><a href="#cb22-42" aria-hidden="true" tabindex="-1"></a><span class="co"># Visualize training curves</span></span>
<span id="cb22-43"><a href="#cb22-43" aria-hidden="true" tabindex="-1"></a>plot_training_results(</span>
<span id="cb22-44"><a href="#cb22-44" aria-hidden="true" tabindex="-1"></a>    results,</span>
<span id="cb22-45"><a href="#cb22-45" aria-hidden="true" tabindex="-1"></a>    metrics<span class="op">=</span>[<span class="st">'loss'</span>, <span class="st">'accuracy'</span>, <span class="st">'gradient_norm'</span>, <span class="st">'memory'</span>],</span>
<span id="cb22-46"><a href="#cb22-46" aria-hidden="true" tabindex="-1"></a>    mode<span class="op">=</span><span class="st">"train"</span>,</span>
<span id="cb22-47"><a href="#cb22-47" aria-hidden="true" tabindex="-1"></a>    title<span class="op">=</span><span class="st">'Optimizer Comparison on CIFAR100'</span></span>
<span id="cb22-48"><a href="#cb22-48" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Files already downloaded and verified
Files already downloaded and verified

Starting experiment with SGD optimizer...

==================================================
Optimizer: SGD
Initial CUDA Memory Status (GPU 0):
Allocated: 26.5MB
Reserved: 50.0MB
Model Size: 1194.1K parameters
==================================================
</code></pre>
</div>
<div class="cell-output cell-output-display">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id":"f9006d867491454a9db530180a287b44","version_major":2,"version_minor":0,"quarto_mimetype":"application/vnd.jupyter.widget-view+json"}
</script>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
==================================================
Final CUDA Memory Status (GPU 0):
Peak Allocated: 120.4MB
Peak Reserved: 138.0MB
Current Allocated: 35.6MB
Current Reserved: 138.0MB
==================================================

Results saved to: SGD_cnn_20250225_161620.csv

Starting experiment with Adam optimizer...

==================================================
Optimizer: Adam
Initial CUDA Memory Status (GPU 0):
Allocated: 35.6MB
Reserved: 138.0MB
Model Size: 1194.1K parameters
==================================================
</code></pre>
</div>
<div class="cell-output cell-output-display">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id":"dcd60bbfe3b64789828b28ff1a1c305e","version_major":2,"version_minor":0,"quarto_mimetype":"application/vnd.jupyter.widget-view+json"}
</script>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
==================================================
Final CUDA Memory Status (GPU 0):
Peak Allocated: 124.9MB
Peak Reserved: 158.0MB
Current Allocated: 40.2MB
Current Reserved: 158.0MB
==================================================

Results saved to: Adam_cnn_20250225_162443.csv

Starting experiment with Lion optimizer...

==================================================
Optimizer: Lion
Initial CUDA Memory Status (GPU 0):
Allocated: 31.0MB
Reserved: 158.0MB
Model Size: 1194.1K parameters
==================================================
</code></pre>
</div>
<div class="cell-output cell-output-display">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id":"31f67588627840bd8e354958b5028454","version_major":2,"version_minor":0,"quarto_mimetype":"application/vnd.jupyter.widget-view+json"}
</script>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
==================================================
Final CUDA Memory Status (GPU 0):
Peak Allocated: 120.4MB
Peak Reserved: 158.0MB
Current Allocated: 35.6MB
Current Reserved: 158.0MB
==================================================

Results saved to: Lion_cnn_20250225_163259.csv</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="05_최적화와 시각화_files/figure-html/cell-8-output-8.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>실험 결과는 CIFAR-100 데이터셋과 CNN 모델을 사용하여 SGD, Adam, Lion 최적화 알고리즘을 비교한 것으로, 각 알고리즘의 특징을 보여줍니다.</p>
<ol type="1">
<li><p><strong>수렴 속도 및 정확도:</strong></p>
<ul>
<li>SGD는 40 에폭 후에도 낮은 정확도(약 50% 미만)를 보이며, 느리게 수렴합니다.</li>
<li>Adam은 20 에폭 근처에서 약 50% 정확도에 도달하며 비교적 빠르게 수렴합니다.</li>
<li>Lion은 Adam보다 빠르게 수렴하고, 40 에폭에서 약 55%로 가장 높은 정확도를 달성했습니다.</li>
</ul></li>
<li><p><strong>학습 곡선 안정성:</strong></p>
<ul>
<li>Adam은 Loss와 Accuracy 곡선 모두 안정적입니다.</li>
<li>Lion은 Adam과 유사하게 안정적이나, Accuracy 곡선에서 약간의 변동이 있습니다.</li>
<li>SGD는 Loss와 Accuracy 곡선 모두 변동성이 큽니다.</li>
</ul></li>
<li><p><strong>메모리 사용량:</strong></p>
<ul>
<li>Lion(약 31MB)과 SGD(약31MB)는 Adam(약 34MB)보다 약간 적은 메모리를 사용합니다.</li>
</ul></li>
<li><p><strong>그래디언트 노름:</strong></p>
<ul>
<li>Lion: 초기 그래디언트 노름이 크고(약 3.56), 빠르게 증가 후 감소하여 10 근처에서 안정화됩니다. (초기 큰 보폭 탐색)</li>
<li>Adam: 초기 그래디언트 노름은 Lion보다 작고(약 3.26), 완만하게 증가 후 안정화됩니다. (안정적 탐색)</li>
<li>SGD: 초기 그래디언트 노름이 가장 작고(약 3.13), 변동성이 크며, 다른 알고리즘보다 높은 값에서 유지됩니다.</li>
</ul></li>
</ol>
<p>주어진 실험 조건에서, <strong>Lion</strong>이 가장 빠른 수렴 속도와 높은 정확도를 보였습니다. <strong>Adam</strong>은 안정적인 학습 곡선을 보였고, <strong>SGD</strong>는 느리고 변동성이 컸습니다. 메모리 사용량은 Lion과 SGD가 Adam보다 약간 적었습니다.</p>
<div id="cell-21" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_05.experiments.advanced <span class="im">import</span> run_advanced_experiment</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_05.visualization.optimization <span class="im">import</span> plot_training_results</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_04.utils.data <span class="im">import</span> get_data_loaders</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_05.optimizers.basic <span class="im">import</span> SGD, Adam</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_05.optimizers.advanced <span class="im">import</span> Lion</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Device configuration</span></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>device <span class="op">=</span> torch.device(<span class="st">"cuda:0"</span> <span class="cf">if</span> torch.cuda.is_available() <span class="cf">else</span> <span class="st">"cpu"</span>)</span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Data loaders</span></span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a>train_loader, test_loader <span class="op">=</span> get_data_loaders(dataset<span class="op">=</span><span class="st">"CIFAR100"</span>)</span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Optimizer dictionary</span></span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a>optimizers <span class="op">=</span> {</span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a>    <span class="st">'SGD'</span>: SGD,</span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Adam'</span>: Adam,</span>
<span id="cb27-18"><a href="#cb27-18" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Lion'</span>: Lion</span>
<span id="cb27-19"><a href="#cb27-19" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb27-20"><a href="#cb27-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-21"><a href="#cb27-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Optimizer configurations</span></span>
<span id="cb27-22"><a href="#cb27-22" aria-hidden="true" tabindex="-1"></a>optimizer_configs <span class="op">=</span> {</span>
<span id="cb27-23"><a href="#cb27-23" aria-hidden="true" tabindex="-1"></a>    <span class="st">'SGD'</span>: {<span class="st">'lr'</span>: <span class="fl">0.01</span>, <span class="st">'momentum'</span>: <span class="fl">0.9</span>},</span>
<span id="cb27-24"><a href="#cb27-24" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Adam'</span>: {<span class="st">'lr'</span>: <span class="fl">0.001</span>},</span>
<span id="cb27-25"><a href="#cb27-25" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Lion'</span>: {<span class="st">'lr'</span>: <span class="fl">1e-4</span>}</span>
<span id="cb27-26"><a href="#cb27-26" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb27-27"><a href="#cb27-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-28"><a href="#cb27-28" aria-hidden="true" tabindex="-1"></a><span class="co"># Run experiments</span></span>
<span id="cb27-29"><a href="#cb27-29" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> {}</span>
<span id="cb27-30"><a href="#cb27-30" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> name, config <span class="kw">in</span> optimizer_configs.items():</span>
<span id="cb27-31"><a href="#cb27-31" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Starting experiment with </span><span class="sc">{</span>name<span class="sc">}</span><span class="ss"> optimizer..."</span>)</span>
<span id="cb27-32"><a href="#cb27-32" aria-hidden="true" tabindex="-1"></a>    results[name] <span class="op">=</span> run_advanced_experiment(</span>
<span id="cb27-33"><a href="#cb27-33" aria-hidden="true" tabindex="-1"></a>        optimizer_class<span class="op">=</span>optimizers[name],</span>
<span id="cb27-34"><a href="#cb27-34" aria-hidden="true" tabindex="-1"></a>        model_type<span class="op">=</span><span class="st">'transformer'</span>,</span>
<span id="cb27-35"><a href="#cb27-35" aria-hidden="true" tabindex="-1"></a>        train_loader<span class="op">=</span>train_loader,</span>
<span id="cb27-36"><a href="#cb27-36" aria-hidden="true" tabindex="-1"></a>        test_loader<span class="op">=</span>test_loader,</span>
<span id="cb27-37"><a href="#cb27-37" aria-hidden="true" tabindex="-1"></a>        config<span class="op">=</span>config,</span>
<span id="cb27-38"><a href="#cb27-38" aria-hidden="true" tabindex="-1"></a>        device<span class="op">=</span>device,</span>
<span id="cb27-39"><a href="#cb27-39" aria-hidden="true" tabindex="-1"></a>        epochs<span class="op">=</span><span class="dv">40</span></span>
<span id="cb27-40"><a href="#cb27-40" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb27-41"><a href="#cb27-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-42"><a href="#cb27-42" aria-hidden="true" tabindex="-1"></a><span class="co"># Visualize training curves</span></span>
<span id="cb27-43"><a href="#cb27-43" aria-hidden="true" tabindex="-1"></a>plot_training_results(</span>
<span id="cb27-44"><a href="#cb27-44" aria-hidden="true" tabindex="-1"></a>    results,</span>
<span id="cb27-45"><a href="#cb27-45" aria-hidden="true" tabindex="-1"></a>    metrics<span class="op">=</span>[<span class="st">'loss'</span>, <span class="st">'accuracy'</span>, <span class="st">'gradient_norm'</span>, <span class="st">'memory'</span>],</span>
<span id="cb27-46"><a href="#cb27-46" aria-hidden="true" tabindex="-1"></a>    mode<span class="op">=</span><span class="st">"train"</span>,</span>
<span id="cb27-47"><a href="#cb27-47" aria-hidden="true" tabindex="-1"></a>    title<span class="op">=</span><span class="st">'Optimizer Comparison on CIFAR100'</span></span>
<span id="cb27-48"><a href="#cb27-48" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Files already downloaded and verified
Files already downloaded and verified

Starting experiment with SGD optimizer...</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>/home/sean/anaconda3/envs/DL/lib/python3.10/site-packages/torch/nn/modules/transformer.py:379: UserWarning: enable_nested_tensor is True, but self.use_nested_tensor is False because encoder_layer.norm_first was True
  warnings.warn(</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
==================================================
Optimizer: SGD
Initial CUDA Memory Status (GPU 0):
Allocated: 274.5MB
Reserved: 318.0MB
Model Size: 62099.8K parameters
==================================================
</code></pre>
</div>
<div class="cell-output cell-output-display">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id":"0194a84568dd47cc87bcbd8b8efcf1c7","version_major":2,"version_minor":0,"quarto_mimetype":"application/vnd.jupyter.widget-view+json"}
</script>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
==================================================
Final CUDA Memory Status (GPU 0):
Peak Allocated: 836.8MB
Peak Reserved: 906.0MB
Current Allocated: 749.5MB
Current Reserved: 906.0MB
==================================================

Results saved to: SGD_transformer_20250225_164652.csv

Starting experiment with Adam optimizer...

==================================================
Optimizer: Adam
Initial CUDA Memory Status (GPU 0):
Allocated: 748.2MB
Reserved: 906.0MB
Model Size: 62099.8K parameters
==================================================
</code></pre>
</div>
<div class="cell-output cell-output-display">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id":"a67a0697ce6e40169da7fa60aa2dd45f","version_major":2,"version_minor":0,"quarto_mimetype":"application/vnd.jupyter.widget-view+json"}
</script>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
==================================================
Final CUDA Memory Status (GPU 0):
Peak Allocated: 1073.0MB
Peak Reserved: 1160.0MB
Current Allocated: 985.1MB
Current Reserved: 1160.0MB
==================================================

Results saved to: Adam_transformer_20250225_170159.csv

Starting experiment with Lion optimizer...

==================================================
Optimizer: Lion
Initial CUDA Memory Status (GPU 0):
Allocated: 511.4MB
Reserved: 1160.0MB
Model Size: 62099.8K parameters
==================================================
</code></pre>
</div>
<div class="cell-output cell-output-display">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id":"7cdfacd5f0ef4c57b845cc96581dcd2e","version_major":2,"version_minor":0,"quarto_mimetype":"application/vnd.jupyter.widget-view+json"}
</script>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
==================================================
Final CUDA Memory Status (GPU 0):
Peak Allocated: 985.1MB
Peak Reserved: 1160.0MB
Current Allocated: 748.2MB
Current Reserved: 1160.0MB
==================================================

Results saved to: Lion_transformer_20250225_171625.csv</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="05_최적화와 시각화_files/figure-html/cell-9-output-10.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>일반적으로 트랜스포머는 이미지 분류 작업에 직접 사용되기보다는, ViT(Vision Transformer)와 같이 이미지 특성에 맞게 변형된 구조로 사용됩니다. 이 실험은 최적화 알고리즘 비교를 위한 예시로 진행합니다. 트랜스포머 모델 실험 결과는 다음과 같습니다.</p>
<ol type="1">
<li>수렴 성능 : Adam은 가장 빠른 초기 수렴을 보이며 그 다음이 Lion, SGD 였습니다.</li>
<li>안정성과 일반화 : Adam은 30.5% 도달하고 가장 안정적인 성능을 보입니다. Lion은 28.88%의 테스트 정확도로 학습 후반부에 약간의 성능 저하가 있었습니다. SGD는 31.1%의 정확도로 가장 좋은 일반화 성능을 보였습니다.</li>
<li>메모리 사용: Lion과 SGD는 비슷한 메모리를 Adam은 상대적으로 더 많은 메모리를 사용했습니다.</li>
<li>그래디언트 동역학: Adam의 그래디언트 노름은 1.98에서 0.92까지 점진적으로 감소했습니다. Lion의 2.81에서 시작하여 1.21까지 감소했고 SGD는 8.41에서 시작하여 5.92까지 감소하며 가장 큰 변화를 보였습니다.</li>
</ol>
<p><strong>결론</strong> CIFAR-100 데이터셋에서의 실험 결과, SGD가 가장 좋은 일반화 성능을 보였지만 학습 속도가 가장 느렸습니다. Adam은 가장 빠른 수렴과 안정적인 학습을 보였으나 메모리 사용량이 많았고, Lion은 메모리 효율성과 수렴 속도 면에서 균형 잡힌 성능을 보여주었습니다.</p>
</section>
</section>
</section>
<section id="최적화-과정의-시각화와-분석-딥러닝-학습의-블랙박스-들여다보기" class="level2">
<h2 class="anchored" data-anchor-id="최적화-과정의-시각화와-분석-딥러닝-학습의-블랙박스-들여다보기">5.3 최적화 과정의 시각화와 분석: 딥러닝 학습의 블랙박스 들여다보기</h2>
<blockquote class="blockquote">
<p><strong>도전과제:</strong> 수백만, 수천만 차원의 고차원 공간에서 벌어지는 딥러닝 최적화 과정을 어떻게 효과적으로 시각화하고 이해할 수 있을까?</p>
<p><strong>연구자의 고뇌:</strong> 딥러닝 모델의 파라미터 공간은 인간이 직관적으로 상상하기 어려운 초고차원 공간입니다. 연구자들은 다양한 차원 축소 기법과 시각화 도구를 개발하여 이 “블랙박스”를 열어보려 노력했지만, 여전히 많은 부분이 베일에 싸여 있습니다.</p>
</blockquote>
<p>신경망의 학습 과정을 이해하는 것은 효과적인 모델 설계, 최적화 알고리즘 선택, 그리고 하이퍼파라미터 튜닝에 필수적입니다. 특히, 손실 함수(loss function)의 기하학적 특성(geometry)과 최적화 경로(optimization path)를 시각화하고 분석하는 것은 학습 과정의 동적 특성(dynamics)과 안정성(stability)을 파악하는 데 중요한 통찰력을 제공합니다. <em>최근 몇 년간, 손실 표면 시각화 연구는 딥러닝 연구자들에게 신경망 학습의 비밀을 풀어줄 실마리를 제공하면서, 더 효율적이고 안정적인 학습 알고리즘 및 모델 구조 개발에 기여하고 있습니다.</em></p>
<p>이 절에서는 손실 표면 시각화의 기본 개념과 최신 기법들을 살펴보고, 이를 통해 딥러닝 학습 과정에서 발생하는 다양한 현상(예: local minima, saddle point, optimization path의 특성)들을 분석합니다. 특히, 모델 구조(예: 잔차 연결)가 손실 표면에 미치는 영향, 최적화 알고리즘에 따른 최적화 경로의 차이 등을 중점적으로 다룹니다.</p>
<section id="손실-표면loss-landscape의-이해-딥러닝-모델의-지형도" class="level3">
<h3 class="anchored" data-anchor-id="손실-표면loss-landscape의-이해-딥러닝-모델의-지형도">5.3.1 손실 표면(Loss Landscape)의 이해: 딥러닝 모델의 지형도</h3>
<p>손실 표면 시각화는 딥러닝 모델의 학습 과정을 이해하기 위한 핵심적인 도구입니다. <em>마치 지형도를 통해 산의 높낮이와 골짜기의 위치를 파악하듯이, 손실 표면 시각화를 통해 파라미터 공간에서 손실 함수의 변화를 시각적으로 파악할 수 있습니다.</em></p>
<p>2017년 Goodfellow et al.의 연구는 손실 표면의 평탄성(flatness)이 모델의 일반화(generalization) 성능과 밀접한 관련이 있음을 보여주었습니다. (넓고 평탄한 minima가 좁고 뾰족한 minima보다 일반화 성능이 더 좋다는 경향) 2018년 Li et al.은 3차원 시각화를 통해 잔차 연결(residual connection)이 손실 표면을 평탄하게 만들어 학습을 용이하게 한다는 것을 보였습니다. 이러한 발견들은 ResNet과 같은 현대적인 신경망 아키텍처 설계의 핵심적인 기반이 되었습니다.</p>
<section id="기본-시각화-기법" class="level5">
<h5 class="anchored" data-anchor-id="기본-시각화-기법">기본 시각화 기법</h5>
<ol type="1">
<li><p><strong>선형 보간법 (Linear Interpolation):</strong></p>
<ul>
<li><p><em>개념:</em> 서로 다른 두 모델(예: 학습 전/후 모델, 서로 다른 local minima에 수렴한 모델)의 가중치를 선형적으로 결합하여, 그 사이의 손실 함수 값을 계산합니다.</p></li>
<li><p><em>수식:</em></p>
<p><span class="math inline">\(w(\alpha) = (1-\alpha)w_1 + \alpha w_2\)</span></p>
<ul>
<li><span class="math inline">\(w_1\)</span>, <span class="math inline">\(w_2\)</span>: 두 모델의 가중치</li>
<li><span class="math inline">\(\alpha \in [0,1]\)</span>: 보간 계수 (0이면 <span class="math inline">\(w_1\)</span>, 1이면 <span class="math inline">\(w_2\)</span>, 그 사이의 값이면 두 가중치의 선형 결합)</li>
<li><span class="math inline">\(L(w(\alpha))\)</span>: 보간된 가중치 <span class="math inline">\(w(\alpha)\)</span>에서의 손실 값</li>
</ul></li>
</ul></li>
</ol>
<div id="cell-24" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.nn <span class="im">as</span> nn</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> torch.utils.data <span class="im">import</span> DataLoader, Subset</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_05.visualization.loss_surface <span class="im">import</span> linear_interpolation, visualize_linear_interpolation</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_04.utils.data <span class="im">import</span> get_dataset</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_04.utils.metrics <span class="im">import</span> load_model</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Linear Interpolation</span></span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Device configuration</span></span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a>device <span class="op">=</span> torch.device(<span class="st">"cuda"</span> <span class="cf">if</span> torch.cuda.is_available() <span class="cf">else</span> <span class="st">"cpu"</span>)</span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Get the dataset</span></span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a>_, test_dataset <span class="op">=</span> get_dataset(dataset<span class="op">=</span><span class="st">"FashionMNIST"</span>)</span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a small dataset</span></span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true" tabindex="-1"></a>small_dataset <span class="op">=</span> Subset(test_dataset, torch.arange(<span class="dv">0</span>, <span class="dv">256</span>))</span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true" tabindex="-1"></a>data_loader <span class="op">=</span> DataLoader(small_dataset, batch_size<span class="op">=</span><span class="dv">256</span>, shuffle<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true" tabindex="-1"></a>loss_func <span class="op">=</span> nn.CrossEntropyLoss()</span>
<span id="cb34-19"><a href="#cb34-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-20"><a href="#cb34-20" aria-hidden="true" tabindex="-1"></a><span class="co"># model1, _ = load_model(model_file="SimpleNetwork-ReLU.pth", path="tmp/models/")</span></span>
<span id="cb34-21"><a href="#cb34-21" aria-hidden="true" tabindex="-1"></a><span class="co"># model2, _ = load_model(model_file="SimpleNetwork-Tanh.pth", path="tmp/models/")</span></span>
<span id="cb34-22"><a href="#cb34-22" aria-hidden="true" tabindex="-1"></a>model1, _ <span class="op">=</span> load_model(model_file<span class="op">=</span><span class="st">"SimpleNetwork-ReLU-epoch1.pth"</span>, path<span class="op">=</span><span class="st">"tmp/models/"</span>)</span>
<span id="cb34-23"><a href="#cb34-23" aria-hidden="true" tabindex="-1"></a>model2, _ <span class="op">=</span> load_model(model_file<span class="op">=</span><span class="st">"SimpleNetwork-ReLU-epoch15.pth"</span>, path<span class="op">=</span><span class="st">"tmp/models/"</span>)</span>
<span id="cb34-24"><a href="#cb34-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-25"><a href="#cb34-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-26"><a href="#cb34-26" aria-hidden="true" tabindex="-1"></a>model1 <span class="op">=</span> model1.to(device)</span>
<span id="cb34-27"><a href="#cb34-27" aria-hidden="true" tabindex="-1"></a>model2 <span class="op">=</span> model2.to(device)</span>
<span id="cb34-28"><a href="#cb34-28" aria-hidden="true" tabindex="-1"></a><span class="co"># Linear interpolation</span></span>
<span id="cb34-29"><a href="#cb34-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-30"><a href="#cb34-30" aria-hidden="true" tabindex="-1"></a><span class="co"># Test with a small dataset</span></span>
<span id="cb34-31"><a href="#cb34-31" aria-hidden="true" tabindex="-1"></a>_, test_dataset <span class="op">=</span> get_dataset(dataset<span class="op">=</span><span class="st">"FashionMNIST"</span>)</span>
<span id="cb34-32"><a href="#cb34-32" aria-hidden="true" tabindex="-1"></a>small_dataset <span class="op">=</span> Subset(test_dataset, torch.arange(<span class="dv">0</span>, <span class="dv">256</span>))</span>
<span id="cb34-33"><a href="#cb34-33" aria-hidden="true" tabindex="-1"></a>data_loader <span class="op">=</span> DataLoader(small_dataset, batch_size<span class="op">=</span><span class="dv">256</span>, shuffle<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb34-34"><a href="#cb34-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-35"><a href="#cb34-35" aria-hidden="true" tabindex="-1"></a>alphas, losses,  accuracies <span class="op">=</span> linear_interpolation(model1, model2, data_loader, loss_func, device)</span>
<span id="cb34-36"><a href="#cb34-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-37"><a href="#cb34-37" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> visualize_linear_interpolation(alphas, losses, accuracies,  <span class="st">"ReLU(1)-ReLU(15)"</span>,  size<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">4</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="05_최적화와 시각화_files/figure-html/cell-10-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>선형 보간에서 α=0은 첫 번째 모델(1 에폭 학습), α=1은 두 번째 모델(15 에폭 학습)의 가중치를 의미하며, 중간값들은 두 모델 가중치의 선형 결합을 나타냅니다. 그래프에서 α 값이 증가함에 따라 손실 함수 값이 감소하는 경향을 보이며, 이는 학습이 진행될수록 모델이 더 좋은 최적점으로 이동함을 의미합니다. 그러나 선형 보간은 고차원 가중치 공간의 매우 제한된 단면만을 보여준다는 한계가 있습니다. 두 모델 간의 실제 최적 경로는 비선형일 가능성이 높으며, α 범위를 [0,1] 밖으로 확장하는 것은 해석을 어렵게 만듭니다.</p>
<p>베지어 곡선이나 스플라인을 사용한 비선형 경로 탐색, PCA나 t-SNE를 통한 고차원 구조 시각화는 더 포괄적인 정보를 제공할 수 있습니다. 실무에서는 선형 보간을 초기 분석 도구로 사용하고, α는 [0,1] 범위 또는 약간의 extrapolation으로 제한하는 것이 좋습니다. 다른 시각화 기법과 함께 종합적으로 분석하며, 모델 성능 차이가 큰 경우 추가 분석이 필요합니다.</p>
<p>다음은 PCA와 t-SNE 분석입니다.</p>
<div id="cell-26" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_05.visualization.loss_surface <span class="im">import</span> analyze_weight_space, visualize_weight_space</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_04.utils.metrics <span class="im">import</span> load_model, load_models_by_pattern</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>models, labels <span class="op">=</span> load_models_by_pattern(</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>    activation_types<span class="op">=</span>[<span class="st">'ReLU'</span>],</span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># activation_types=['Tanh'],</span></span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># activation_types=['GELU'],</span></span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a>    epochs<span class="op">=</span>[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>,<span class="dv">11</span>,<span class="dv">12</span>,<span class="dv">13</span>,<span class="dv">14</span>,<span class="dv">15</span>]</span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a><span class="co"># PCA analysis</span></span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true" tabindex="-1"></a>embedded_pca <span class="op">=</span> analyze_weight_space(models, labels, method<span class="op">=</span><span class="st">'pca'</span>)</span>
<span id="cb35-15"><a href="#cb35-15" aria-hidden="true" tabindex="-1"></a>visualize_weight_space(embedded_pca, labels, method<span class="op">=</span><span class="st">'PCA'</span>)</span>
<span id="cb35-16"><a href="#cb35-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"embedded_pca = </span><span class="sc">{</span>embedded_pca<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb35-17"><a href="#cb35-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-18"><a href="#cb35-18" aria-hidden="true" tabindex="-1"></a><span class="co"># t-SNE analysis</span></span>
<span id="cb35-19"><a href="#cb35-19" aria-hidden="true" tabindex="-1"></a>embedded_tsne <span class="op">=</span> analyze_weight_space(models, labels, method<span class="op">=</span><span class="st">'tsne'</span>, perplexity<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb35-20"><a href="#cb35-20" aria-hidden="true" tabindex="-1"></a>visualize_weight_space(embedded_tsne, labels, method<span class="op">=</span><span class="st">'t-SNE'</span>)</span>
<span id="cb35-21"><a href="#cb35-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"embedded_tsne = </span><span class="sc">{</span>embedded_tsne<span class="sc">}</span><span class="ss">"</span>) <span class="co"># Corrected: Print embedded_tsne, not embedded_pca</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="05_최적화와 시각화_files/figure-html/cell-11-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>embedded_pca = [[ 9.8299894e+00  2.1538167e+00]
 [-1.1609798e+01 -9.0169059e-03]
 [-1.1640446e+01 -1.2218434e-02]
 [-1.1667191e+01 -1.3469303e-02]
 [-1.1691980e+01 -1.5136327e-02]
 [-1.1714937e+01 -1.6765745e-02]
 [-1.1735878e+01 -1.8110925e-02]
 [ 9.9324265e+00  1.5862983e+00]
 [ 1.0126298e+01  4.7935897e-01]
 [ 1.0256655e+01 -2.8844318e-01]
 [ 1.0319887e+01 -6.6510278e-01]
 [ 1.0359785e+01 -8.9812231e-01]
 [ 1.0392080e+01 -1.0731999e+00]
 [ 1.0418671e+01 -1.2047548e+00]
 [-1.1575559e+01 -5.1336871e-03]]</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="05_최적화와 시각화_files/figure-html/cell-11-output-3.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>embedded_tsne = [[ 119.4719    -99.78837 ]
 [ 100.26558    66.285835]
 [  94.79294    62.795162]
 [  89.221085   59.253677]
 [  83.667984   55.70297 ]
 [  77.897224   52.022995]
 [  74.5897     49.913578]
 [ 123.20351  -100.34615 ]
 [ -70.45423   -65.66194 ]
 [ -65.55417   -68.90429 ]
 [ -60.166885  -72.466805]
 [ -54.70004   -76.077   ]
 [ -49.00131   -79.833694]
 [ -45.727974  -81.99213 ]
 [ 105.22419    69.45333 ]]</code></pre>
</div>
</div>
<p>PCA와 t-SNE 시각화는 학습 과정에서 모델 가중치 공간의 변화를 저차원(2차원)으로 투영하여 보여줍니다.</p>
<ul>
<li><strong>PCA 시각화:</strong>
<ul>
<li>점들은 각 에폭(epoch)의 모델 가중치를 나타냅니다. (보라색(epoch 1) -&gt; 붉은색(epoch 9) -&gt; 초록색 계열(epoch 10 이후))</li>
<li>초기에 넓게 퍼져 있던 가중치가 학습이 진행됨에 따라 특정 영역으로 모여듭니다.</li>
<li>특히, epoch 9에서 epoch 10으로 넘어갈 때 큰 변화가 관찰됩니다.</li>
<li>PCA는 가중치 공간에서 가장 큰 변화가 일어나는 방향(주성분)을 보여줍니다.</li>
</ul></li>
<li><strong>t-SNE 시각화:</strong>
<ul>
<li>PCA와 유사하게, epoch에 따라 점들의 색깔이 변하며, 학습 초/중/후반의 가중치 분포 변화를 보여줍니다.</li>
<li>t-SNE는 <em>비선형</em> 차원 축소 기법으로, 고차원 공간에서의 <em>국소적 이웃 관계</em>를 보존하는 데 중점을 둡니다.</li>
<li>epoch 1-9 그룹과 epoch 10-15 그룹이 비교적 명확하게 분리되어, PCA 결과를 뒷받침합니다.</li>
</ul></li>
</ul>
<p>이 시각화들을 통해, 학습 과정에서 모델 가중치의 변화와 최적화 알고리즘의 가중치 공간 탐색에 대한 직관적 이해를 얻을 수 있습니다. <em>특히 PCA와 t-SNE를 함께 사용하면, 전역적 변화(PCA)와 국소적 구조(t-SNE)를 동시에 파악할 수 있습니다.</em></p>
<ol start="2" type="1">
<li><p><strong>등고선 맵 (Contour Plot)</strong></p>
<p>등고선 맵은 2차원 평면 상에 손실 함수 값이 일정한 지점들을 연결한 선(등고선)을 그려, 손실 표면의 형태를 시각화하는 방법입니다. <em>마치 지형도의 등고선처럼, 손실 함수의 “높낮이”를 나타냅니다.</em></p>
<p><em>일반적인 절차는 다음과 같습니다.</em></p>
<ol type="1">
<li><p><strong>기준점 설정:</strong> 기준이 되는 모델 파라미터(<span class="math inline">\(w_0\)</span>)를 선택합니다. (예: 학습이 완료된 모델의 파라미터)</p></li>
<li><p><strong>방향 벡터 선택:</strong> 2개의 방향 벡터(<span class="math inline">\(d_1\)</span>, <span class="math inline">\(d_2\)</span>)를 선택합니다. <em>이 벡터들은 2차원 평면의 기저(basis)를 형성합니다.</em></p>
<ul>
<li><em>일반적인 선택:</em> 무작위(random) 방향, PCA(주성분 분석)를 통해 얻은 주성분 방향, 또는 PyHessian과 같은 라이브러리를 사용하여 헤시안(Hessian) 행렬의 고유벡터(eigenvector) 중 가장 큰 고윳값(eigenvalue)에 해당하는 상위 2개. <em>후자의 경우, 손실 함수 값이 가장 급격하게 변하는 방향을 나타냅니다.</em></li>
</ul></li>
<li><p><strong>파라미터 교란:</strong> 기준점 <span class="math inline">\(w_0\)</span>를 중심으로, 선택된 두 방향 벡터 <span class="math inline">\(d_1\)</span>, <span class="math inline">\(d_2\)</span>를 따라 파라미터를 교란(perturb)합니다.</p>
<p><span class="math inline">\(w(\lambda_1, \lambda_2) = w_0 + \lambda_1 d_1 + \lambda_2 d_2\)</span></p>
<ul>
<li><span class="math inline">\(\lambda_1\)</span>, <span class="math inline">\(\lambda_2\)</span>: 각 방향 벡터에 대한 스칼라 계수 (예: -0.2 ~ 0.2 범위에서 일정 간격으로 값을 선택)</li>
</ul></li>
<li><p><strong>손실 값 계산:</strong> 각 <span class="math inline">\((\lambda_1, \lambda_2)\)</span> 조합에 대해, 교란된 파라미터 <span class="math inline">\(w(\lambda_1, \lambda_2)\)</span>를 모델에 적용하고, 손실 함수 값을 계산합니다.</p></li>
<li><p><strong>등고선 플롯:</strong> <span class="math inline">\((\lambda_1, \lambda_2, L(w(\lambda_1, \lambda_2)))\)</span> 데이터를 사용하여 2차원 등고선 플롯을 그립니다. (matplotlib의 <code>contour</code> 또는 <code>tricontourf</code> 함수 등을 사용)</p></li>
</ol>
<p><em>등고선 맵은 손실 표면의 국소적인 형태(local geometry)를 시각적으로 보여주며, 최적화 알고리즘의 궤적(trajectory)을 함께 표시하여 알고리즘의 동작 방식을 분석하는 데에도 활용될 수 있습니다.</em></p></li>
</ol>
<div id="cell-29" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.nn <span class="im">as</span> nn</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> torch.utils.data <span class="im">import</span> DataLoader, Subset</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_05.visualization.loss_surface <span class="im">import</span> hessian_eigenvectors, xy_perturb_loss, visualize_loss_surface, linear_interpolation</span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_04.utils.data <span class="im">import</span> get_dataset</span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_04.utils.metrics <span class="im">import</span> load_model</span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_05.optimizers.basic <span class="im">import</span> SGD, Adam</span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Device configuration</span></span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a>device <span class="op">=</span> torch.device(<span class="st">"cuda"</span> <span class="cf">if</span> torch.cuda.is_available() <span class="cf">else</span> <span class="st">"cpu"</span>)</span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Get the dataset</span></span>
<span id="cb38-14"><a href="#cb38-14" aria-hidden="true" tabindex="-1"></a>_, test_dataset <span class="op">=</span> get_dataset(dataset<span class="op">=</span><span class="st">"FashionMNIST"</span>)</span>
<span id="cb38-15"><a href="#cb38-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a small dataset</span></span>
<span id="cb38-16"><a href="#cb38-16" aria-hidden="true" tabindex="-1"></a>small_dataset <span class="op">=</span> Subset(test_dataset, torch.arange(<span class="dv">0</span>, <span class="dv">256</span>))</span>
<span id="cb38-17"><a href="#cb38-17" aria-hidden="true" tabindex="-1"></a>data_loader <span class="op">=</span> DataLoader(small_dataset, batch_size<span class="op">=</span><span class="dv">256</span>, shuffle<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb38-18"><a href="#cb38-18" aria-hidden="true" tabindex="-1"></a>loss_func <span class="op">=</span> nn.CrossEntropyLoss()</span>
<span id="cb38-19"><a href="#cb38-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-20"><a href="#cb38-20" aria-hidden="true" tabindex="-1"></a>trained_model, _ <span class="op">=</span> load_model(model_file<span class="op">=</span><span class="st">"SimpleNetwork-ReLU.pth"</span>, path<span class="op">=</span><span class="st">"tmp/models/"</span>)</span>
<span id="cb38-21"><a href="#cb38-21" aria-hidden="true" tabindex="-1"></a><span class="co"># trained_model, _ = load_model(model_file="SimpleNetwork-Tanh.pth", path="tmp/models/")</span></span>
<span id="cb38-22"><a href="#cb38-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-23"><a href="#cb38-23" aria-hidden="true" tabindex="-1"></a>trained_model <span class="op">=</span> trained_model.to(device)</span>
<span id="cb38-24"><a href="#cb38-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-25"><a href="#cb38-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-26"><a href="#cb38-26" aria-hidden="true" tabindex="-1"></a><span class="co"># pyhessian</span></span>
<span id="cb38-27"><a href="#cb38-27" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> []  <span class="co"># List to store the calculated result sets</span></span>
<span id="cb38-28"><a href="#cb38-28" aria-hidden="true" tabindex="-1"></a>top_n <span class="op">=</span> <span class="dv">4</span>  <span class="co"># Must be an even number.  Each pair of eigenvectors is used.  2 is the minimum.  10 means 5 graphs.</span></span>
<span id="cb38-29"><a href="#cb38-29" aria-hidden="true" tabindex="-1"></a>top_eigenvalues, top_eignevectors <span class="op">=</span> hessian_eigenvectors(model<span class="op">=</span>trained_model, loss_func<span class="op">=</span>loss_func, data_loader<span class="op">=</span>data_loader, top_n<span class="op">=</span>top_n, is_cuda<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb38-30"><a href="#cb38-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-31"><a href="#cb38-31" aria-hidden="true" tabindex="-1"></a><span class="co"># Define the scale with lambda.</span></span>
<span id="cb38-32"><a href="#cb38-32" aria-hidden="true" tabindex="-1"></a>lambda1, lambda2 <span class="op">=</span> np.linspace(<span class="op">-</span><span class="fl">0.2</span>, <span class="fl">0.2</span>, <span class="dv">40</span>).astype(np.float32), np.linspace(<span class="op">-</span><span class="fl">0.2</span>, <span class="fl">0.2</span>, <span class="dv">40</span>).astype(np.float32)</span>
<span id="cb38-33"><a href="#cb38-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-34"><a href="#cb38-34" aria-hidden="true" tabindex="-1"></a><span class="co"># If top_n=10, a total of 5 pairs of graphs can be drawn.</span></span>
<span id="cb38-35"><a href="#cb38-35" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(top_n <span class="op">//</span> <span class="dv">2</span>):</span>
<span id="cb38-36"><a href="#cb38-36" aria-hidden="true" tabindex="-1"></a>    x, y, z <span class="op">=</span> xy_perturb_loss(model<span class="op">=</span>trained_model, top_eigenvectors<span class="op">=</span>top_eignevectors[i<span class="op">*</span><span class="dv">2</span>:(i<span class="op">+</span><span class="dv">1</span>)<span class="op">*</span><span class="dv">2</span>], data_loader<span class="op">=</span>data_loader, loss_func<span class="op">=</span>loss_func, lambda1<span class="op">=</span>lambda1, lambda2<span class="op">=</span>lambda2, device<span class="op">=</span>device)</span>
<span id="cb38-37"><a href="#cb38-37" aria-hidden="true" tabindex="-1"></a>    data.append((x, y, z))</span>
<span id="cb38-38"><a href="#cb38-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-39"><a href="#cb38-39" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> visualize_loss_surface(data, <span class="st">"ReLU"</span>, color<span class="op">=</span><span class="st">"C0"</span>, alpha<span class="op">=</span><span class="fl">0.6</span>, plot_3d<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb38-40"><a href="#cb38-40" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> visualize_loss_surface(data, <span class="st">"ReLU"</span>, color<span class="op">=</span><span class="st">"C0"</span>, alpha<span class="op">=</span><span class="fl">0.6</span>, plot_3d<span class="op">=</span><span class="va">False</span>) <span class="co"># Changed "ReLu" to "ReLU" for consistency</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>/home/sean/anaconda3/envs/DL/lib/python3.10/site-packages/torch/autograd/graph.py:825: UserWarning: Using backward() with create_graph=True will create a reference cycle between the parameter and its gradient which can cause a memory leak. We recommend using autograd.grad when creating the graph to avoid this. If you have to use this function, make sure to reset the .grad fields of your parameters to None after use to break the cycle and avoid the leak. (Triggered internally at ../torch/csrc/autograd/engine.cpp:1201.)
  return Variable._execution_engine.run_backward(  # Calls into the C++ engine to run the backward pass</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="05_최적화와 시각화_files/figure-html/cell-12-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="05_최적화와 시각화_files/figure-html/cell-12-output-3.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>등고선 맵은 단순 선형 보간보다 <em>국소적인 영역에 대한</em> 더 풍부한 정보를 제공합니다. 선형 보간이 두 모델 사이의 <em>1차원적인 경로</em>를 따라 손실 함수 값의 변화를 보여주는 반면, 등고선 맵은 선택된 두 방향(<span class="math inline">\(\lambda_1\)</span>, <span class="math inline">\(\lambda_2\)</span>)을 축으로 하는 <em>2차원 평면</em> 상에서 손실 함수의 변화를 시각화합니다. 이를 통해, 최적화 경로 상의 미묘한 변화, <em>선형 보간으로는 알 수 없었던 주변 영역의</em> 국소 최솟값(local minima), 안장점(saddle point)의 존재, 그리고 그 사이의 장벽(barrier) 등을 확인할 수 있습니다.</p>
</section>
</section>
<section id="손실-표면-분석의-심층-기법" class="level3">
<h3 class="anchored" data-anchor-id="손실-표면-분석의-심층-기법">5.3.2 손실 표면 분석의 심층 기법</h3>
<p>단순한 시각화(선형 보간, 등고선 맵)를 넘어, 딥러닝 모델의 손실 표면(loss landscape)을 더 깊이 있게 이해하기 위한 고급 분석 기법들이 연구되고 있습니다.</p>
<ol type="1">
<li><p><strong>위상 기반 분석 (Topological Data Analysis, TDA):</strong></p>
<ul>
<li><em>핵심 아이디어:</em> 위상수학(topology)의 도구를 사용하여 손실 표면의 연결성(connectivity)과 같은 “모양”을 분석합니다.</li>
<li><em>주요 기법:</em> 지속성 호몰로지(persistent homology), Mapper 알고리즘 등.</li>
<li><em>활용:</em> 손실 표면의 복잡성, 국소 최솟값(local minima)들의 연결 구조, 안장점(saddle point)의 특성 등을 파악하여, 학습 동역학(learning dynamics) 및 일반화(generalization) 성능에 대한 통찰력을 얻을 수 있습니다. <em>(자세한 내용은 “딥다이브: 위상 기반 손실 표면 분석” 참고)</em></li>
</ul></li>
<li><p><strong>다중 스케일 분석 (Multi-scale Analysis):</strong></p>
<ul>
<li><em>핵심 아이디어:</em> 손실 표면을 다양한 스케일(scale)에서 분석하여, 거시적인 구조와 미세한 구조를 모두 파악합니다.</li>
<li><em>주요 기법:</em> 웨이블릿 변환(wavelet transform), 스케일 공간 이론(scale-space theory) 등.</li>
<li><em>활용:</em> 손실 표면의 거칠기(roughness), 주요 특징(feature)의 스케일별 분포 등을 분석하여, 최적화 알고리즘의 동작 방식, 학습의 어려움 등을 이해할 수 있습니다. <em>(자세한 내용은 “딥다이브: 다중 스케일 손실 표면 분석” 참고)</em></li>
</ul></li>
</ol>
<p><em>이러한 고급 분석 기법들은 손실 표면에 대한 더 추상적이고 정량적인 정보를 제공하여, 딥러닝 모델의 학습 과정을 더 깊이 이해하고, 더 나은 모델 설계 및 최적화 전략을 수립하는 데 기여할 수 있습니다.</em></p>
<div id="cell-32" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.nn <span class="im">as</span> nn  <span class="co"># Import the nn module</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> torch.utils.data <span class="im">import</span> DataLoader, Subset  <span class="co"># Import DataLoader and Subset</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_05.visualization.loss_surface <span class="im">import</span>  analyze_loss_surface_multiscale</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_04.utils.data <span class="im">import</span> get_dataset  <span class="co"># Import get_dataset</span></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_04.utils.metrics <span class="im">import</span> load_model  <span class="co"># Import load_model</span></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Device configuration</span></span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a>device <span class="op">=</span> torch.device(<span class="st">"cuda"</span> <span class="cf">if</span> torch.cuda.is_available() <span class="cf">else</span> <span class="st">"cpu"</span>)</span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Load dataset and create a small subset</span></span>
<span id="cb40-12"><a href="#cb40-12" aria-hidden="true" tabindex="-1"></a>_, test_dataset <span class="op">=</span> get_dataset(dataset<span class="op">=</span><span class="st">"FashionMNIST"</span>)</span>
<span id="cb40-13"><a href="#cb40-13" aria-hidden="true" tabindex="-1"></a>small_dataset <span class="op">=</span> Subset(test_dataset, torch.arange(<span class="dv">0</span>, <span class="dv">256</span>))</span>
<span id="cb40-14"><a href="#cb40-14" aria-hidden="true" tabindex="-1"></a>data_loader <span class="op">=</span> DataLoader(small_dataset, batch_size<span class="op">=</span><span class="dv">256</span>, shuffle<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb40-15"><a href="#cb40-15" aria-hidden="true" tabindex="-1"></a>loss_func <span class="op">=</span> nn.CrossEntropyLoss()</span>
<span id="cb40-16"><a href="#cb40-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-17"><a href="#cb40-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Load model (example: SimpleNetwork-ReLU)</span></span>
<span id="cb40-18"><a href="#cb40-18" aria-hidden="true" tabindex="-1"></a>model, _ <span class="op">=</span> load_model(model_file<span class="op">=</span><span class="st">"SimpleNetwork-ReLU.pth"</span>, path<span class="op">=</span><span class="st">"tmp/models/"</span>)</span>
<span id="cb40-19"><a href="#cb40-19" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> model.to(device)</span>
<span id="cb40-20"><a href="#cb40-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-21"><a href="#cb40-21" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> analyze_loss_surface_multiscale(model, data_loader, loss_func, device)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="05_최적화와 시각화_files/figure-html/cell-13-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p><code>analyze_loss_surface_multiscale</code> 함수를 사용하여 FashionMNIST 데이터셋에 대해 학습된 <code>SimpleNetwork-ReLU</code> 모델의 손실 표면을 다중 스케일 관점에서 분석, 시각화했습니다.</p>
<p><strong>그래프 해석 (웨이블릿 변환 기반):</strong></p>
<ul>
<li><p><strong>Approx. Coefficients (근사 계수):</strong> 손실 표면의 전반적인 형태(global structure)를 나타냅니다. 중심부(낮은 손실 값)에 최솟값이 있을 가능성이 높습니다.</p></li>
<li><p><strong>Detail Coeff Level 1/2 (세부 계수):</strong> 더 작은 규모의 변화를 나타냅니다. “Level 1”은 중간 스케일, “Level 2”는 가장 미세한 스케일의 굴곡(local minima, saddle point, 노이즈 등)을 보여줍니다.</p></li>
<li><p><strong>색상:</strong> 어두운색(낮은 손실), 밝은색(높은 손실)</p></li>
<li><p><code>analyze_loss_surface_multiscale</code> 함수의 구현(웨이블릿 함수, 분해 레벨 등)에 따라 결과가 달라질 수 있습니다.</p></li>
<li><p>이 시각화는 손실 표면의 <em>일부</em>만 보여주며, 고차원 공간의 복잡성을 완전히 파악하기는 어렵습니다.</p></li>
</ul>
<p>다중 스케일 분석은 손실 표면을 여러 스케일로 분해하여, 단순 시각화로는 파악하기 어려운 다층적 구조를 보여줍니다. 큰 스케일에서는 전반적 경향, 작은 스케일에서는 국소적 변화를 파악하여, 최적화 알고리즘 동작, 학습 난이도, 일반화 성능 등을 이해하는 데 도움을 줍니다.</p>
<div class="callout callout-style-default callout-note callout-titled" title="클릭하여 내용 보기 (위상 기반 손실 표면 분석)">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-3-contents" aria-controls="callout-3" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
클릭하여 내용 보기 (위상 기반 손실 표면 분석)
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-3" class="callout-3-contents callout-collapse collapse">
<section id="위상-기반-손실-표면-분석" class="level3 callout-body-container callout-body">
<h3 class="anchored" data-anchor-id="위상-기반-손실-표면-분석">위상 기반 손실 표면 분석</h3>
<p>위상수학(topology)은 연속적인 변형에 의해 변하지 않는 기하학적 성질을 연구하는 분야입니다. 딥러닝에서 위상 기반 분석은 손실 표면의 연결성(connectivity), 구멍(hole), 공동(void)과 같은 위상적 특징(topological feature)을 분석하여, 학습 역학 및 일반화 성능에 대한 통찰력을 얻는 데 활용됩니다.</p>
<p><strong>핵심 개념:</strong></p>
<ul>
<li><p><strong>Sublevel Set:</strong> 주어진 함수 <span class="math inline">\(f: \mathbb{R}^n \rightarrow \mathbb{R}\)</span> 와 임계값 <span class="math inline">\(c\)</span>에 대해, <span class="math inline">\(f^{-1}((-\infty, c]) = {x \in \mathbb{R}^n | f(x) \leq c}\)</span> 로 정의되는 집합입니다. 손실 함수에서는 특정 손실 값 이하를 갖는 파라미터 공간 영역을 나타냅니다.</p></li>
<li><p><strong>Persistent Homology:</strong> Sublevel set의 변화를 추적하면서, 위상적 특징(0차: connected components, 1차: loops, 2차: voids, …)의 생성과 소멸을 기록합니다.</p>
<ul>
<li><strong>0차 특징 (Connected Components):</strong> 서로 연결된 영역의 개수. 손실 표면에서는 지역 최솟값(local minima)의 개수와 관련됩니다.</li>
<li><strong>1차 특징 (Loops):</strong> 닫힌 루프의 개수. 손실 표면에서는 안장점(saddle point)을 둘러싼 경로의 존재와 관련됩니다.</li>
</ul></li>
<li><p><strong>Persistence Diagram:</strong> 각 위상적 특징의 생성(birth) 및 소멸(death) 시점의 손실 값을 좌표평면에 점으로 나타낸 것입니다. 점의 <span class="math inline">\(y\)</span>좌표(<span class="math inline">\(\text{death} - \text{birth}\)</span>)는 해당 특징의 “수명(lifetime)” 또는 “지속성(persistence)”을 나타내며, 값이 클수록 더 안정적인 특징으로 간주됩니다.</p></li>
<li><p><strong>Bottleneck Distance:</strong> 두 persistence diagram 간의 거리를 측정하는 방법 중 하나입니다. 두 다이어그램의 점들 사이의 최적 매칭(optimal matching)을 찾아, 매칭된 점들 간의 거리 중 최댓값을 계산합니다.</p></li>
</ul>
<p><strong>수학적 배경 (간략):</strong></p>
<ul>
<li><strong>Simplicial Complex:</strong> 점(vertex), 선(edge), 삼각형(triangle), 사면체(tetrahedron) 등을 일반화한 개념으로, 위상 공간을 근사하는 데 사용됩니다.</li>
<li><strong>Boundary Operator:</strong> Simplicial complex의 경계를 계산하는 연산자입니다.</li>
<li><strong>Homology Group:</strong> Boundary operator를 사용하여 정의되는 군(group)으로, 위상 공간의 “구멍”을 나타냅니다.</li>
<li><strong>Persistent Homology Algorithm:</strong> Sublevel set filtration을 통해 simplicial complex를 구성하고, homology group의 변화를 추적하여 persistence diagram을 계산합니다. (자세한 내용은 참고 문헌 [1] 참조)</li>
</ul>
<p><strong>딥러닝 연구 적용:</strong></p>
<ul>
<li><strong>손실 표면 구조 분석:</strong> Persistence diagram을 통해 손실 표면의 복잡성, 지역 최솟값의 개수 및 안정성, 안장점의 존재 여부 등을 파악할 수 있습니다.
<ul>
<li>예: <a href="https://www.google.com/search?q=https://www.google.com/search%3Fq%3Dhttps://arxiv.org/abs/1803.06934">Gur-Ari et al., 2018</a> 에서는 신경망 손실 표면의 persistence diagram을 계산하여, 넓은(wide) 네트워크가 좁은(narrow) 네트워크보다 더 단순한 위상적 구조를 갖는다는 것을 보였습니다.</li>
</ul></li>
<li><strong>일반화 성능 예측:</strong> Persistence diagram의 특징(예: 가장 긴 수명을 갖는 0차 특징의 수명)이 모델의 일반화 성능과 상관관계가 있을 수 있습니다.
<ul>
<li>예: <a href="https://www.google.com/url?sa=E&amp;source=gmail&amp;q=%5Bhttps://www.google.com/search?q=https://proceedings.mlr.press/v162/perez22a.html">Perez et al., 2022</a>는](<a href="https://www.google.com/search?q=https://www.google.com/search%3Fq%3Dhttps://proceedings.mlr.press/v162/perez22a.html">https://www.google.com/search?q=https://www.google.com/search%3Fq%3Dhttps://proceedings.mlr.press/v162/perez22a.html)%EB%8A%94</a>%EB%8A%94)) persistence diagram의 특징을 사용하여 모델의 일반화 성능을 예측하는 방법을 제안했습니다.</li>
</ul></li>
<li><strong>Mode Connectivity</strong>: 서로 다른 local minimum을 연결하는 경로를 찾고, 그 경로상의 에너지 장벽(energy barrier)을 분석합니다.
<ul>
<li>예: <a href="https://www.google.com/url?sa=E&amp;source=gmail&amp;q=https://arxiv.org/abs/1802.10026">Garipov et al., 2018</a></li>
</ul></li>
</ul>
<p><strong>참고 자료:</strong></p>
<ol type="1">
<li>Edelsbrunner, H., &amp; Harer, J. (2010). <em>Computational Topology: An Introduction</em>. American Mathematical Society.</li>
<li>Gur-Ari, G., Roberts, D. A., &amp; Dyer, E. (2018). <em>Gradient descent happens in a tiny subspace</em>. arXiv preprint arXiv:1812.04754.</li>
<li>Perez, D., Masoomi, A., DiCecco, J., &amp; Chwialkowski, K. (2022). <em>Relating loss landscape topology to generalization with persistent homology</em>. In International Conference on Machine Learning (pp.&nbsp;17953-17977). PMLR.</li>
<li>Garipov, T., Izmailov, P., Podoprikhin, D., Vetrov, D. P., &amp; Wilson, A. G. (2018). <em>Loss surfaces, mode connectivity, and fast ensembling of dnns.</em> Advances in neural information processing systems, 31.</li>
</ol>
</section>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled" title="클릭하여 내용 보기 (딥다이브: 다중 스케일 손실 표면 분석)">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-4-contents" aria-controls="callout-4" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
클릭하여 내용 보기 (딥다이브: 다중 스케일 손실 표면 분석)
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-4" class="callout-4-contents callout-collapse collapse">
<section id="다중-스케일-손실-표면-분석" class="level3 callout-body-container callout-body">
<h3 class="anchored" data-anchor-id="다중-스케일-손실-표면-분석">다중 스케일 손실 표면 분석</h3>
<p>딥러닝 모델의 손실 표면은 다양한 스케일의 특징을 갖습니다. 큰 규모의 계곡(valley)과 능선(ridge)부터 작은 규모의 요철(bump)과 구덩이(hole)까지, 다양한 크기의 기하학적 구조가 학습 과정에 영향을 미칩니다. 다중 스케일 분석은 이러한 다양한 스케일의 특징을 분리하여 분석하는 방법입니다.</p>
<p><strong>핵심 아이디어:</strong></p>
<ul>
<li><p><strong>웨이블릿 변환 (Wavelet Transform):</strong> 웨이블릿 변환은 신호(signal)를 다양한 주파수(frequency) 성분으로 분해하는 수학적 도구입니다. 이를 손실 함수에 적용하면, 서로 다른 스케일의 특징을 분리할 수 있습니다.</p>
<ul>
<li><p><strong>연속 웨이블릿 변환 (Continuous Wavelet Transform, CWT):</strong></p>
<p><span class="math inline">\(W(a, b) = \int\_{-\infty}^{\infty} f(x) \psi\_{a,b}(x) dx\)</span></p>
<ul>
<li><span class="math inline">\(f(x)\)</span>: 분석 대상 함수 (손실 함수)</li>
<li><span class="math inline">\(\psi\_{a,b}(x) = \frac{1}{\sqrt{a}}\psi(\frac{x-b}{a})\)</span>: 웨이블릿 함수 (mother wavelet <span class="math inline">\(\psi\)</span>를 스케일링(<span class="math inline">\(a\)</span>) 및 이동(<span class="math inline">\(b\)</span>)시킨 함수)</li>
<li><span class="math inline">\(W(a, b)\)</span>: 스케일 <span class="math inline">\(a\)</span>, 위치 <span class="math inline">\(b\)</span>에서의 웨이블릿 계수</li>
</ul></li>
<li><p><strong>Mother Wavelet:</strong> 특정 조건을 만족하는 함수 (예: Mexican hat wavelet, Morlet wavelet) (자세한 내용은 참고 문헌 [2] 참조)</p></li>
</ul></li>
<li><p><strong>다중 해상도 분석 (Multi-resolution Analysis, MRA):</strong> CWT를 이산화(discretization)하여, 신호를 서로 다른 해상도(resolution) 레벨로 분해하는 방법입니다.</p></li>
</ul>
<p><strong>수학적 배경 (간략):</strong></p>
<ul>
<li><strong>Scaling Function:</strong> 저주파 성분을 나타내는 함수입니다.</li>
<li><strong>Wavelet Function:</strong> 고주파 성분을 나타내는 함수입니다.</li>
<li><strong>Decomposition:</strong> 신호를 scaling function과 wavelet function의 조합으로 분해합니다.</li>
<li><strong>Reconstruction:</strong> 분해된 신호를 다시 원래 신호로 복원합니다. <em>(자세한 내용은 참고 문헌 [1] 참조)</em></li>
</ul>
<p><strong>딥러닝 연구 적용:</strong></p>
<ul>
<li><p><strong>손실 표면 거칠기 분석:</strong> 웨이블릿 변환을 통해 손실 표면의 거칠기(roughness)를 정량화하고, 이것이 학습 속도 및 일반화 성능에 미치는 영향을 분석할 수 있습니다.</p>
<ul>
<li>예: <a href="https://www.google.com/url?sa=E&amp;source=gmail&amp;q=%5Bhttps://www.google.com/search?q=https://arxiv.org/abs/1910.00779">Li et al., 2019</a>는](<a href="https://www.google.com/search?q=https://www.google.com/search%3Fq%3Dhttps://arxiv.org/abs/1910.00779">https://www.google.com/search?q=https://www.google.com/search%3Fq%3Dhttps://arxiv.org/abs/1910.00779)%EB%8A%94</a>%EB%8A%94)) 웨이블릿 기반 다중 해상도 분석을 사용하여 손실 표면의 거칠기가 학습 역학에 미치는 영향을 분석했습니다.</li>
</ul></li>
<li><p><strong>최적화 알고리즘 분석:</strong> 최적화 알고리즘이 각 스케일에서 어떤 특징을 따라 이동하는지 분석하여, 알고리즘의 동작 방식을 더 잘 이해할 수 있습니다.</p></li>
</ul>
<p><strong>참고 자료:</strong></p>
<ol type="1">
<li>Mallat, S. (2008). <em>A wavelet tour of signal processing: the sparse way</em>. Academic press.</li>
<li>Daubechies, I. (1992). <em>Ten lectures on wavelets</em>. Society for industrial and applied mathematics.</li>
<li>Li, Y., Hu, W., Zhang, Y., &amp; Gu, Q. (2019). <em>Multiresolution analysis of the loss landscape of deep nets</em>. arXiv preprint arXiv:1910.00779.</li>
</ol>
</section>
</div>
</div>
</section>
</section>
<section id="최적화-과정-시각화-가우시안-함수로-엿보는-딥러닝-학습의-비밀" class="level2">
<h2 class="anchored" data-anchor-id="최적화-과정-시각화-가우시안-함수로-엿보는-딥러닝-학습의-비밀">5.4 최적화 과정 시각화: 가우시안 함수로 엿보는 딥러닝 학습의 비밀</h2>
<p>딥러닝 모델의 실제 손실 표면(loss surface)은 수백만에서 수십억 차원에 이르는 <em>초고차원 공간</em>에 존재하며, 매우 복잡한 기하학적 구조를 가집니다. 따라서 이를 직접 시각화하고 분석하는 것은 <em>사실상 불가능</em>합니다. 또한, 실제 손실 표면은 미분 불가능한 지점, 불연속점, 수치적 불안정성 등 다양한 문제점을 안고 있어, 이론적인 분석에도 어려움이 따릅니다.</p>
<section id="가우시안-함수를-통한-근사적-분석-단순함-속에-숨겨진-통찰" class="level3">
<h3 class="anchored" data-anchor-id="가우시안-함수를-통한-근사적-분석-단순함-속에-숨겨진-통찰">5.4.1 가우시안 함수를 통한 근사적 분석: 단순함 속에 숨겨진 통찰</h3>
<p>이러한 한계를 극복하고 최적화 과정을 <em>개념적으로</em> 이해하기 위해, 우리는 매끄럽고(smooth), 연속적(continuous)이며, <em>볼록(convex)한</em> 형태를 갖는 가우시안 함수(Gaussian function)를 사용하여 손실 표면을 <em>근사(approximation)</em>하는 방법을 사용합니다.</p>
<p><strong>가우시안 함수를 사용하는 이유 (손실 표면 근사의 장점):</strong></p>
<ol type="1">
<li><strong>미분 가능성:</strong> 가우시안 함수는 모든 지점에서 무한 번 미분 가능(infinitely differentiable)합니다. 이는 경사 하강법(gradient descent) 기반 최적화 알고리즘을 적용하고 분석하는 데 필수적인 조건입니다.</li>
<li><strong>볼록성(Convexity):</strong> 단일 가우시안 함수는 볼록 함수(convex function)입니다. 볼록 함수는 전역 최솟값(global minimum)이 하나만 존재하므로, 최적화 알고리즘의 수렴성을 분석하기 용이합니다.</li>
<li><strong>대칭성(Symmetry):</strong> 가우시안 함수는 중심점을 기준으로 대칭적인 형태를 가집니다. 이는 손실 표면의 특정 방향에 대한 편향(bias)이 없음을 의미하며, 최적화 알고리즘의 동작을 분석할 때 단순화된 가정을 할 수 있게 해줍니다.</li>
<li><strong>수학적 단순성:</strong> 가우시안 함수는 비교적 간단한 수식으로 표현되므로, 수학적 분석이 용이합니다. 이를 통해 최적화 알고리즘의 동작 원리를 이론적으로 이해하고, 예측 가능한 결과를 도출할 수 있습니다.</li>
<li><strong>조절 가능한 복잡성:</strong> 가우시안 혼합 모델을 사용해서 복잡도를 조절할 수 있습니다.</li>
</ol>
<p><strong>가우시안 함수 수식:</strong></p>
<p><span class="math inline">\(z = A \exp\left(-\left(\frac{(x-x_0)^2}{2\sigma_1^2} + \frac{(y-y_0)^2}{2\sigma_2^2}\right)\right)\)</span></p>
<ul>
<li><span class="math inline">\(A\)</span>: 진폭 (amplitude) - 손실 함수의 최대 높이</li>
<li><span class="math inline">\(x_0\)</span>, <span class="math inline">\(y_0\)</span>: 중심점 (center) - 손실 함수의 최솟값 위치</li>
<li><span class="math inline">\(\sigma_1\)</span>, <span class="math inline">\(\sigma_2\)</span>: x축, y축 방향의 표준편차 (standard deviation) - 손실 표면의 폭 (넓고 좁음)</li>
</ul>
<p>물론, 실제 손실 표면은 가우시안 함수보다 훨씬 복잡한 형태를 가질 수 있습니다. (다수의 local minima, saddle point, plateau 등). 하지만, <em>단일 가우시안 함수를 사용한 근사는 최적화 알고리즘의 기본적인 동작 특성(예: 수렴 속도, 진동 패턴)을 이해하고, 서로 다른 알고리즘을 비교 분석하는 데 유용한 출발점을 제공합니다.</em> 더 복잡한 손실 표면을 모사(simulate)하기 위해서는 여러 개의 가우시안 함수를 조합한 가우시안 혼합 모델(Gaussian Mixture Model, GMM)을 사용할 수 있습니다.</p>
<p><em>이 절에서는 단일 가우시안 함수를 사용하여 손실 표면을 근사하고, 다양한 최적화 알고리즘(SGD, Adam 등)을 적용하여 학습 궤적(learning trajectory)을 시각화함으로써, 각 알고리즘의 동적 특성과 장단점을 직관적으로 파악해 볼 것입니다.</em></p>
<div id="cell-37" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.nn <span class="im">as</span> nn</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> torch.utils.data <span class="im">import</span> DataLoader, Subset</span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_05.visualization.loss_surface <span class="im">import</span> hessian_eigenvectors, xy_perturb_loss, visualize_loss_surface, linear_interpolation</span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_04.utils.data <span class="im">import</span> get_dataset  </span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_04.utils.metrics <span class="im">import</span> load_model  </span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_05.optimizers.basic <span class="im">import</span> SGD, Adam</span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_05.visualization.gaussian_loss_surface <span class="im">import</span> (</span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a>    get_opt_params,  visualize_gaussian_fit, train_loss_surface, visualize_optimization_path</span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-13"><a href="#cb41-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-14"><a href="#cb41-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Device configuration</span></span>
<span id="cb41-15"><a href="#cb41-15" aria-hidden="true" tabindex="-1"></a>device <span class="op">=</span> torch.device(<span class="st">"cuda"</span> <span class="cf">if</span> torch.cuda.is_available() <span class="cf">else</span> <span class="st">"cpu"</span>)</span>
<span id="cb41-16"><a href="#cb41-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-17"><a href="#cb41-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Get the dataset</span></span>
<span id="cb41-18"><a href="#cb41-18" aria-hidden="true" tabindex="-1"></a>_, test_dataset <span class="op">=</span> get_dataset(dataset<span class="op">=</span><span class="st">"FashionMNIST"</span>)</span>
<span id="cb41-19"><a href="#cb41-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a small dataset</span></span>
<span id="cb41-20"><a href="#cb41-20" aria-hidden="true" tabindex="-1"></a>small_dataset <span class="op">=</span> Subset(test_dataset, torch.arange(<span class="dv">0</span>, <span class="dv">256</span>))</span>
<span id="cb41-21"><a href="#cb41-21" aria-hidden="true" tabindex="-1"></a>data_loader <span class="op">=</span> DataLoader(small_dataset, batch_size<span class="op">=</span><span class="dv">256</span>, shuffle<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb41-22"><a href="#cb41-22" aria-hidden="true" tabindex="-1"></a>loss_func <span class="op">=</span> nn.CrossEntropyLoss()</span>
<span id="cb41-23"><a href="#cb41-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-24"><a href="#cb41-24" aria-hidden="true" tabindex="-1"></a>trained_model, _ <span class="op">=</span> load_model(model_file<span class="op">=</span><span class="st">"SimpleNetwork-ReLU.pth"</span>, path<span class="op">=</span><span class="st">"tmp/models/"</span>)</span>
<span id="cb41-25"><a href="#cb41-25" aria-hidden="true" tabindex="-1"></a><span class="co"># trained_model, _ = load_model(model_file="SimpleNetwork-Tanh.pth", path="tmp/models/")</span></span>
<span id="cb41-26"><a href="#cb41-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-27"><a href="#cb41-27" aria-hidden="true" tabindex="-1"></a>trained_model <span class="op">=</span> trained_model.to(device)</span>
<span id="cb41-28"><a href="#cb41-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-29"><a href="#cb41-29" aria-hidden="true" tabindex="-1"></a><span class="co"># Loss surface data generation</span></span>
<span id="cb41-30"><a href="#cb41-30" aria-hidden="true" tabindex="-1"></a>top_n <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb41-31"><a href="#cb41-31" aria-hidden="true" tabindex="-1"></a>top_eigenvalues, top_eignevectors <span class="op">=</span> hessian_eigenvectors(</span>
<span id="cb41-32"><a href="#cb41-32" aria-hidden="true" tabindex="-1"></a>    model<span class="op">=</span>trained_model,</span>
<span id="cb41-33"><a href="#cb41-33" aria-hidden="true" tabindex="-1"></a>    loss_func<span class="op">=</span>loss_func,</span>
<span id="cb41-34"><a href="#cb41-34" aria-hidden="true" tabindex="-1"></a>    data_loader<span class="op">=</span>data_loader,</span>
<span id="cb41-35"><a href="#cb41-35" aria-hidden="true" tabindex="-1"></a>    top_n<span class="op">=</span>top_n,</span>
<span id="cb41-36"><a href="#cb41-36" aria-hidden="true" tabindex="-1"></a>    is_cuda<span class="op">=</span><span class="va">True</span></span>
<span id="cb41-37"><a href="#cb41-37" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb41-38"><a href="#cb41-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-39"><a href="#cb41-39" aria-hidden="true" tabindex="-1"></a><span class="co"># Define lambda range</span></span>
<span id="cb41-40"><a href="#cb41-40" aria-hidden="true" tabindex="-1"></a>d_min, d_max, d_num <span class="op">=</span> <span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">30</span></span>
<span id="cb41-41"><a href="#cb41-41" aria-hidden="true" tabindex="-1"></a>lambda1 <span class="op">=</span> np.linspace(d_min, d_max, d_num).astype(np.float32)</span>
<span id="cb41-42"><a href="#cb41-42" aria-hidden="true" tabindex="-1"></a>lambda2 <span class="op">=</span> np.linspace(d_min, d_max, d_num).astype(np.float32)</span>
<span id="cb41-43"><a href="#cb41-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-44"><a href="#cb41-44" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate loss surface</span></span>
<span id="cb41-45"><a href="#cb41-45" aria-hidden="true" tabindex="-1"></a>x, y, z <span class="op">=</span> xy_perturb_loss(</span>
<span id="cb41-46"><a href="#cb41-46" aria-hidden="true" tabindex="-1"></a>    model<span class="op">=</span>trained_model,</span>
<span id="cb41-47"><a href="#cb41-47" aria-hidden="true" tabindex="-1"></a>    top_eigenvectors<span class="op">=</span>top_eignevectors,</span>
<span id="cb41-48"><a href="#cb41-48" aria-hidden="true" tabindex="-1"></a>    data_loader<span class="op">=</span>data_loader,</span>
<span id="cb41-49"><a href="#cb41-49" aria-hidden="true" tabindex="-1"></a>    loss_func<span class="op">=</span>loss_func,</span>
<span id="cb41-50"><a href="#cb41-50" aria-hidden="true" tabindex="-1"></a>    lambda1<span class="op">=</span>lambda1,</span>
<span id="cb41-51"><a href="#cb41-51" aria-hidden="true" tabindex="-1"></a>    lambda2<span class="op">=</span>lambda2,</span>
<span id="cb41-52"><a href="#cb41-52" aria-hidden="true" tabindex="-1"></a>    device<span class="op">=</span>device</span>
<span id="cb41-53"><a href="#cb41-53" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb41-54"><a href="#cb41-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-55"><a href="#cb41-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-56"><a href="#cb41-56" aria-hidden="true" tabindex="-1"></a><span class="co"># After generating loss surface data</span></span>
<span id="cb41-57"><a href="#cb41-57" aria-hidden="true" tabindex="-1"></a>popt, _, offset <span class="op">=</span> get_opt_params(x, y, z)</span>
<span id="cb41-58"><a href="#cb41-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-59"><a href="#cb41-59" aria-hidden="true" tabindex="-1"></a><span class="co"># Visualize Gaussian fitting</span></span>
<span id="cb41-60"><a href="#cb41-60" aria-hidden="true" tabindex="-1"></a>visualize_gaussian_fit(x, y, z, popt, offset, d_min, d_max, d_num)</span>
<span id="cb41-61"><a href="#cb41-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-62"><a href="#cb41-62" aria-hidden="true" tabindex="-1"></a><span class="co"># View from a different angle</span></span>
<span id="cb41-63"><a href="#cb41-63" aria-hidden="true" tabindex="-1"></a>visualize_gaussian_fit(x, y, z, popt, offset, d_min, d_max, d_num,</span>
<span id="cb41-64"><a href="#cb41-64" aria-hidden="true" tabindex="-1"></a>                      elev<span class="op">=</span><span class="dv">30</span>, azim<span class="op">=</span><span class="dv">45</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Function parameters = [29.27164346 -0.0488573  -0.06687705  0.7469189   0.94904458]</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="05_최적화와 시각화_files/figure-html/cell-14-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="05_최적화와 시각화_files/figure-html/cell-14-output-3.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>실제 손실 평면 데이터(파란 점)와 가우시안 함수로 근사한 평면(붉은색)을 겹쳐서 시각화했습니다. 그래프에서 볼 수 있듯이, 생성된 가우시안 함수가 <em>원래 손실 표면 데이터의 전반적인 경향</em>(특히, 중심부의 오목한 형태)을 비교적 잘 포착하여, 유사한 곡면을 생성하고 있습니다. 이제 이 근사된 손실 평면 함수를 이용하여, 다양한 최적화 알고리즘(optimizer)이 어떻게 최솟값을 찾아가는지 그 경로를 분석하고 시각화할 것입니다.</p>
</section>
<section id="경로-시각화" class="level3">
<h3 class="anchored" data-anchor-id="경로-시각화">5.4.2 경로 시각화</h3>
<p>가우시안 함수로 근사한 손실평면을 사용하여, 옵티마이저가 어떻게 작동하는 2D 평면에서 시각화 해보겠습니다.</p>
<div id="cell-41" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Gaussian fitting</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>popt, _, offset <span class="op">=</span> get_opt_params(x, y, z)</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>gaussian_params <span class="op">=</span> (<span class="op">*</span>popt, offset)</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate optimization paths</span></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>points_sgd <span class="op">=</span> train_loss_surface(</span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">lambda</span> params: SGD(params, lr<span class="op">=</span><span class="fl">0.1</span>),</span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a>    [d_min, d_max], <span class="dv">100</span>, gaussian_params</span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true" tabindex="-1"></a>points_sgd_m <span class="op">=</span> train_loss_surface(</span>
<span id="cb43-11"><a href="#cb43-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">lambda</span> params: SGD(params, lr<span class="op">=</span><span class="fl">0.05</span>, momentum<span class="op">=</span><span class="fl">0.8</span>),</span>
<span id="cb43-12"><a href="#cb43-12" aria-hidden="true" tabindex="-1"></a>    [d_min, d_max], <span class="dv">100</span>, gaussian_params</span>
<span id="cb43-13"><a href="#cb43-13" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb43-14"><a href="#cb43-14" aria-hidden="true" tabindex="-1"></a>points_adam <span class="op">=</span> train_loss_surface(</span>
<span id="cb43-15"><a href="#cb43-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">lambda</span> params: Adam(params, lr<span class="op">=</span><span class="fl">0.1</span>),</span>
<span id="cb43-16"><a href="#cb43-16" aria-hidden="true" tabindex="-1"></a>    [d_min, d_max], <span class="dv">100</span>, gaussian_params</span>
<span id="cb43-17"><a href="#cb43-17" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb43-18"><a href="#cb43-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-19"><a href="#cb43-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Visualization</span></span>
<span id="cb43-20"><a href="#cb43-20" aria-hidden="true" tabindex="-1"></a>visualize_optimization_path(</span>
<span id="cb43-21"><a href="#cb43-21" aria-hidden="true" tabindex="-1"></a>    x, y, z, popt, offset,</span>
<span id="cb43-22"><a href="#cb43-22" aria-hidden="true" tabindex="-1"></a>    [points_sgd, points_sgd_m, points_adam],</span>
<span id="cb43-23"><a href="#cb43-23" aria-hidden="true" tabindex="-1"></a>    act_name<span class="op">=</span><span class="st">"ReLU"</span></span>
<span id="cb43-24"><a href="#cb43-24" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>그래프는 가우시안 함수로 근사된 손실 표면에서 SGD, Momentum SGD, Adam 세 가지 최적화 알고리즘의 학습 경로를 보여줍니다. 경사가 완만한 영역과 급한 영역 모두에서 세 알고리즘은 <strong>각기 다른</strong> 특성을 보입니다.</p>
<ul>
<li><strong>SGD (주황색):</strong> 경사가 완만한 곳에서는 비교적 <em>넓은 폭으로 진동하며</em> 최저점을 향해 나아가지만, 경사가 급한 곳에서는 <em>더욱 큰 폭으로 진동하며,</em> 최저점 근처에서 <em>수렴 속도가 느려지는</em> 경향을 보입니다.</li>
<li><strong>Momentum SGD (초록색):</strong> SGD보다 <em>진동이 덜하고, 더 부드러운 곡선</em> 형태로 최저점에 접근합니다. 관성(momentum) 효과 덕분에 <em>경사가 급한 영역에서도 비교적 안정적으로</em> 최저점을 찾아갑니다.</li>
<li><strong>Adam (빨간색):</strong> <em>가장 적은 진동으로,</em> 경사 변화에 <em>민감하게 반응하며</em> 효율적인 경로를 따라 최저점에 도달합니다. <em>특히, 경사가 급한 영역에서도 상대적으로 빠른 수렴 속도를 보입니다.</em> 이는 Adam의 적응형 학습률(adaptive learning rate) 조정 메커니즘 덕분입니다.</li>
</ul>
<p>실무에서는 SGD 자체보다는 모멘텀을 적용한 SGD가 훨씬 선호되며, Adam 또는 AdamW와 같은 적응형 최적화 알고리즘도 널리 사용됩니다. 일반적으로 손실 표면은 대부분의 영역에서 평탄(flat)하지만, 최솟값 근처에서는 좁고 깊은 골짜기(narrow valley) 형태를 띠는 경향이 있습니다. 이로 인해 큰 학습률(learning rate)은 최솟값을 지나치거나(overshoot) 발산(diverge)할 위험이 있으므로, 학습률을 점진적으로 감소시키는 학습률 스케줄러(learning rate scheduler)를 함께 사용하는 것이 일반적입니다. 또한, 최적화 알고리즘의 선택뿐만 아니라, 적절한 학습률 스케줄러, 배치 크기, 정규화 기법 등을 함께 고려하는 것이 중요합니다.</p>
<p><img src="../../../assets/images/04_loss_resnet_ft_imagenet_2.png" class="img-fluid"></p>
<p><img src="../../../assets/images/04_loss_resnet_ft_imagenet_1.png" class="img-fluid"></p>
<p>위 손실평면 이미지는 ImageNet 데이터셋으로 신규 학습한 ResNet-50 모델의 손실 표면을 3차원으로 시각화한 것입니다. (PyHessian을 사용하여 계산된 헤시안 행렬의 상위 고유벡터 두 개를 축으로 사용). 가우시안 함수 근사와는 달리, 실제 딥러닝 모델의 손실 표면은 훨씬 더 복잡하고 불규칙한 형태를 띠고 있음을 알 수 있습니다. 그럼에도 중심부(파란색 영역)에 최솟값이 존재한다는 큰 경향은 유지함을 알 수 있습니다. 이러한 시각화는 딥러닝 모델의 실제 손실 표면이 얼마나 복잡한 지형을 갖는지, 그리고 왜 최적화가 어려운 문제인지에 대한 직관적인 이해를 돕습니다.</p>
</section>
</section>
<section id="최적화-과정의-동적-분석-학습-궤적의-탐구" class="level2">
<h2 class="anchored" data-anchor-id="최적화-과정의-동적-분석-학습-궤적의-탐구">5.5 최적화 과정의 동적 분석: 학습 궤적의 탐구</h2>
<p>딥러닝 모델 학습에서 최적화 알고리즘이 <em>어떤 경로</em>로 손실 함수 최솟값을 찾아가는지, 그 동적 특성(dynamics)을 이해하는 것은 중요합니다. <em>특히, 대규모 언어 모델(LLM) 등장으로, 수십억 개 파라미터 모델의 학습 동역학 분석 및 제어가 더욱 중요해졌습니다.</em></p>
<section id="훈련-과정의-특징" class="level3">
<h3 class="anchored" data-anchor-id="훈련-과정의-특징">5.5.1 훈련 과정의 특징</h3>
<p>딥러닝 모델 학습 과정은 초기, 중기, 후기 단계로 나눌 수 있으며, 각 단계별 특징이 있습니다.</p>
<ol type="1">
<li><p><strong>학습 단계별 특성:</strong></p>
<ul>
<li><strong>초기:</strong> 그래디언트 노름(gradient norm)이 크고 변동이 심하며, 손실 함수 값이 급격히 감소합니다.</li>
<li><strong>중기:</strong> 그래디언트가 안정화되며, 파라미터는 최적 영역(optimal region)을 탐색(explore)합니다.</li>
<li><strong>후기:</strong> 파라미터는 지역 최적해(local optimum) 주변에서 미세 조정(fine-tuning)됩니다. (조기 종료 중요)</li>
</ul></li>
<li><p><strong>층별 그래디언트 특성:</strong></p>
<ul>
<li>깊은 신경망에서는 입력층에 가까울수록 그래디언트가 크고, 출력층에 가까울수록 작아지는 경향이 있습니다. (vanishing gradient problem)</li>
<li>이는 역전파(backpropagation) 시 연쇄 법칙(chain rule) 때문입니다.</li>
<li>잔차 연결(residual connection)은 이러한 불균형을 완화하여 깊은 층에서도 안정적 학습을 돕습니다.</li>
</ul></li>
<li><p><strong>파라미터 의존성:</strong></p>
<ul>
<li>신경망 파라미터들은 상호 의존적이며, 이는 최적화 과정을 비선형적(nonlinear)으로 만듭니다.</li>
<li>일부 파라미터가 학습에 더 큰 영향을 미칠 수 있으므로, 파라미터 간 균형(balance)이 중요합니다.</li>
</ul></li>
<li><p><strong>최적화 경로 분석:</strong></p>
<ul>
<li>최적화 과정에서 파라미터가 손실 표면 위를 이동하는 경로를 최적화 경로(optimization path)라고 합니다.</li>
<li>넓고 완만한 계곡(valley) 형태의 지역 최솟값이 좁고 뾰족한 계곡보다 일반화 성능(generalization performance)이 좋은 경향이 있습니다.</li>
<li>고차원 공간에서는 안장점(saddle point)이 매우 흔합니다. (모멘텀, Adam 등이 회피하도록 설계)</li>
<li>손실 표면이 평탄한(flat) 영역에서는 그래디언트가 작아져 학습이 느려질 수 있습니다. (적응형 학습률 알고리즘이 도움)</li>
</ul></li>
</ol>
</section>
<section id="학습-안정성-분석-및-제어" class="level3">
<h3 class="anchored" data-anchor-id="학습-안정성-분석-및-제어">5.5.2 학습 안정성 분석 및 제어</h3>
<section id="안정성-분석-방법론" class="level4">
<h4 class="anchored" data-anchor-id="안정성-분석-방법론">안정성 분석 방법론</h4>
<p>최적화 과정의 안정성(stability) 분석을 위해 다음을 고려합니다.</p>
<ol type="1">
<li><p><strong>그래디언트 진단 (Gradient Diagnostics):</strong></p>
<ul>
<li>그래디언트 소실(vanishing gradient) 또는 폭발(exploding gradient) 현상 감지.</li>
<li>훈련 과정에서 그래디언트 노름(norm)을 주기적으로 관찰.</li>
</ul></li>
<li><p><strong>헤시안 기반 분석 (Hessian-based Analysis):</strong></p>
<ul>
<li>헤시안(Hessian) 행렬의 고윳값(eigenvalue) 분포와 조건수(condition number)는 최적화 경로 안정성을 나타냅니다.</li>
<li>(5.3절의 헤시안 기반 시각화 참고)</li>
</ul></li>
<li><p><strong>실시간 모니터링 (Real-time Monitoring):</strong></p>
<ul>
<li>학습 중 그래디언트 노름, 파라미터 업데이트 크기, 손실 함수 값, 성능 지표 등을 실시간 모니터링.</li>
</ul></li>
</ol>
<section id="안정화-기법-stabilization-techniques" class="level5">
<h5 class="anchored" data-anchor-id="안정화-기법-stabilization-techniques">안정화 기법 (Stabilization Techniques)</h5>
<ul>
<li><p><strong>그래디언트 클리핑 (Gradient Clipping):</strong> 그래디언트 크기(norm)가 임계값(threshold)을 넘지 않도록 제한.</p>
<p><span class="math inline">\(g \leftarrow \text{clip}(g) = \min(\max(g, -c), c)\)</span></p>
<ul>
<li><span class="math inline">\(g\)</span>: 그래디언트, <span class="math inline">\(c\)</span>: 임계값</li>
</ul></li>
<li><p><strong>적응형 학습률 (Adaptive Learning Rate):</strong> Adam, RMSProp, Lion, Sophia 등은 그래디언트 통계에 따라 학습률 자동 조절.</p></li>
<li><p><strong>학습률 스케줄러 (Learning Rate Scheduler):</strong> 학습 에폭(epoch) 또는 검증 손실(validation loss)에 따라 학습률 점진적 감소.</p></li>
<li><p><strong>하이퍼파라미터 최적화 (Hyperparameter Optimization):</strong> 최적화 관련 하이퍼파라미터를 자동 탐색/조정.</p></li>
</ul>
</section>
<section id="최신-연구-동향" class="level5">
<h5 class="anchored" data-anchor-id="최신-연구-동향">최신 연구 동향</h5>
<p>최근(2024년) 학습 동역학 연구는 다음 방향으로 발전하고 있습니다.</p>
<ul>
<li><strong>예측적 안정화 (Predictive Stabilization):</strong> 학습 <em>전</em> 모델 구조, 초기화, 데이터셋 특성 분석을 통해 불안정성 요인 사전 제거/완화.</li>
<li><strong>통합적 분석 (Unified Analysis):</strong> 곡률(curvature) 정보(헤시안)와 그래디언트 통계를 <em>함께</em> 분석하여 최적화 알고리즘 이해 심화.</li>
<li><strong>자동화된 제어 (Automated Control):</strong> 강화 학습(reinforcement learning) 등으로 최적화 알고리즘 하이퍼파라미터 자동 조정.</li>
</ul>
<p>이러한 연구들은 딥러닝 모델 학습을 더 안정/효율적으로 만들고, “블랙박스”를 이해하는 데 기여합니다.</p>
<p>이제 간단한 예제를 통해 최적화 과정의 동적 분석을 탐구해 봅시다.</p>
<div id="cell-44" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.nn <span class="im">as</span> nn</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.optim <span class="im">as</span> optim</span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> torch.utils.data <span class="im">import</span> DataLoader, Subset  <span class="co"># Import Subset</span></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_05.visualization.train_dynamics <span class="im">import</span> visualize_training_dynamics</span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_04.utils.data <span class="im">import</span> get_dataset  </span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_04.utils.metrics <span class="im">import</span> load_model  </span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Device configuration</span></span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true" tabindex="-1"></a>device <span class="op">=</span> torch.device(<span class="st">"cuda"</span> <span class="cf">if</span> torch.cuda.is_available() <span class="cf">else</span> <span class="st">"cpu"</span>)</span>
<span id="cb44-11"><a href="#cb44-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-12"><a href="#cb44-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Load the FashionMNIST dataset (both training and testing)</span></span>
<span id="cb44-13"><a href="#cb44-13" aria-hidden="true" tabindex="-1"></a>train_dataset, test_dataset <span class="op">=</span> get_dataset(dataset<span class="op">=</span><span class="st">"FashionMNIST"</span>)</span>
<span id="cb44-14"><a href="#cb44-14" aria-hidden="true" tabindex="-1"></a>train_loader <span class="op">=</span> DataLoader(train_dataset, batch_size<span class="op">=</span><span class="dv">256</span>, shuffle<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb44-15"><a href="#cb44-15" aria-hidden="true" tabindex="-1"></a>loss_func <span class="op">=</span> nn.CrossEntropyLoss()</span>
<span id="cb44-16"><a href="#cb44-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-17"><a href="#cb44-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Load a pre-trained model (e.g., ReLU-based network)</span></span>
<span id="cb44-18"><a href="#cb44-18" aria-hidden="true" tabindex="-1"></a>trained_model, _ <span class="op">=</span> load_model(model_file<span class="op">=</span><span class="st">"SimpleNetwork-ReLU.pth"</span>, path<span class="op">=</span><span class="st">"tmp/models/"</span>)</span>
<span id="cb44-19"><a href="#cb44-19" aria-hidden="true" tabindex="-1"></a>trained_model <span class="op">=</span> trained_model.to(device)</span>
<span id="cb44-20"><a href="#cb44-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-21"><a href="#cb44-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Choose an optimizer (e.g., Adam)</span></span>
<span id="cb44-22"><a href="#cb44-22" aria-hidden="true" tabindex="-1"></a>optimizer <span class="op">=</span> optim.Adam(trained_model.parameters(), lr<span class="op">=</span><span class="fl">0.001</span>)</span>
<span id="cb44-23"><a href="#cb44-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-24"><a href="#cb44-24" aria-hidden="true" tabindex="-1"></a><span class="co"># Call the training dynamics visualization function (e.g., train for 10 epochs with the entire training dataset)</span></span>
<span id="cb44-25"><a href="#cb44-25" aria-hidden="true" tabindex="-1"></a>metrics <span class="op">=</span> visualize_training_dynamics(</span>
<span id="cb44-26"><a href="#cb44-26" aria-hidden="true" tabindex="-1"></a>    trained_model, optimizer, train_loader, loss_func, num_epochs<span class="op">=</span><span class="dv">20</span>, device<span class="op">=</span>device</span>
<span id="cb44-27"><a href="#cb44-27" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb44-28"><a href="#cb44-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-29"><a href="#cb44-29" aria-hidden="true" tabindex="-1"></a><span class="co"># Print the final results for each metric</span></span>
<span id="cb44-30"><a href="#cb44-30" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Final Loss:"</span>, metrics[<span class="st">"loss"</span>][<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb44-31"><a href="#cb44-31" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Final Grad Norm:"</span>, metrics[<span class="st">"grad_norm"</span>][<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb44-32"><a href="#cb44-32" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Final Param Change:"</span>, metrics[<span class="st">"param_change"</span>][<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb44-33"><a href="#cb44-33" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Final Weight Norm:"</span>, metrics[<span class="st">"weight_norm"</span>][<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb44-34"><a href="#cb44-34" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Final Loss Improvement:"</span>, metrics[<span class="st">"loss_improvement"</span>][<span class="op">-</span><span class="dv">1</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>위 예제는 설명한 학습 동역학(learning dynamics)의 다양한 측면을 실제로 보여줍니다. FashionMNIST 데이터셋에 대해 사전 학습된 SimpleNetwork-ReLU 모델을 사용하여, Adam 최적화 알고리즘으로 추가 학습을 진행하면서, 에폭(epoch)별로 다음 다섯 가지 핵심 지표(metric)를 시각화했습니다.</p>
<ul>
<li><strong>Loss (손실):</strong> 학습 과정에서 손실 함수 값이 어떻게 감소하는지를 보여줍니다. (파란색 선)</li>
<li><strong>Grad Norm (그래디언트 노름):</strong> 그래디언트의 크기(L2 norm)를 나타냅니다. (빨간색 선)</li>
<li><strong>Param Change (파라미터 변화량):</strong> 이전 에폭 대비 파라미터(가중치)의 변화량(L2 norm)을 나타냅니다.</li>
<li><strong>Weight Norm (가중치 노름):</strong> 전체 모델 파라미터(가중치)의 크기(L2 norm)를 나타냅니다. (보라색 선)</li>
<li><strong>Loss Improvement (손실 개선량):</strong> 이전 에폭에 비해 손실 함수 값이 얼마나 감소했는지를 나타냅니다. (노란색 선)</li>
</ul>
<p>그래프에서 나타내는 것은 다음입니다.</p>
<ul>
<li><strong>Loss:</strong> 초기 에폭(epoch 1)에서 약 0.51이었던 손실 값은 학습이 진행됨에 따라 꾸준히 감소하여, 마지막 에폭(epoch 20)에서는 약 0.16에 도달합니다.</li>
<li><strong>Grad Norm:</strong> 초기 에폭에서 상대적으로 높았던 그래디언트 노름(약 4.5)은 학습이 진행되면서 점차 감소하여, 마지막 에폭에서는 약 2.0 근처에 도달합니다.</li>
<li><strong>Param Change:</strong> 파라미터 변화량은 학습 초기에 크지만, 학습이 진행될수록 감소하는 경향을 보입니다. 이는 모델이 점차 최적점에 가까워지면서 파라미터의 변화가 작아짐을 의미합니다.</li>
<li><strong>Weight Norm:</strong> 가중치 노름은 학습 과정 전반에 걸쳐 꾸준히 증가합니다. 이는 모델의 파라미터가 학습을 통해 점점 더 “커진다”는 것을 의미합니다. (하지만, 반드시 과적합(overfitting)을 의미하는 것은 아닙니다.)</li>
<li><strong>Loss Improvement:</strong> 손실 개선량은 학습 초기에 크고, 학습이 진행될수록 감소하는 경향을 보입니다.</li>
</ul>
<p><em>이 예제를 통해, 최적화 알고리즘이 손실 함수를 최소화하는 과정, 그래디언트의 변화, 파라미터의 변화 등을 시각적으로 확인하고, 학습 동역학에 대한 직관적인 이해를 얻을 수 있습니다.</em></p>
</section>
</section>
</section>
<section id="맺음말" class="level3">
<h3 class="anchored" data-anchor-id="맺음말">맺음말</h3>
<p>이번 5장에서는 딥러닝 모델 학습의 핵심 요소인 최적화와 관련된 다양한 주제들을 깊이 있게 살펴보았습니다. 가중치 초기화 방법의 중요성, 다양한 최적화 알고리즘(SGD, Momentum, Adam, Lion, Sophia, AdaFactor)의 원리와 특성, 그리고 손실 표면 시각화 및 학습 동역학 분석을 통해 딥러닝 모델의 학습 과정을 더 잘 이해할 수 있게 되었습니다.</p>
<p><em>6장에서는 딥러닝 모델의 일반화 성능을 향상시키기 위한 핵심 기법인 규제(regularization)에 대해 자세히 알아봅니다. L1/L2 규제, 드롭아웃(dropout), 배치 정규화(batch normalization), 데이터 증강(data augmentation) 등 다양한 규제 기법의 원리와 효과를 살펴보고, 실전 예제를 통해 그 적용 방법을 익힐 것입니다.</em></p>
</section>
<section id="연습-문제" class="level3">
<h3 class="anchored" data-anchor-id="연습-문제">연습 문제</h3>
<section id="기본-문제" class="level4">
<h4 class="anchored" data-anchor-id="기본-문제">기본 문제</h4>
<ol type="1">
<li><strong>SGD 수동 계산:</strong> 학습률이 0.1이고 모멘텀이 0.9일 때, 다음 손실 함수 <span class="math inline">\(L(w) = w^2\)</span> 에 대한 SGD 업데이트 규칙을 3단계 이상 수동으로 계산해보세요. 초기 가중치는 <span class="math inline">\(w_0 = 2\)</span>로 설정합니다.</li>
<li><strong>경사하강법 수렴 속도 비교:</strong> 간단한 2차원 함수 <span class="math inline">\(f(x, y) = x^2 + 2y^2\)</span> 에 대해 경사하강법을 적용하고, 학습률을 0.1, 0.01, 0.001로 변경하면서 수렴 속도를 비교해보세요.</li>
<li><strong>초기화 방법 비교:</strong> Kaiming 초기화와 Xavier 초기화를 비교하고, ReLU 활성화 함수와 함께 사용할 때 Kaiming 초기화가 더 적합한 이유를 설명해보세요.</li>
</ol>
</section>
<section id="응용-문제" class="level4">
<h4 class="anchored" data-anchor-id="응용-문제">응용 문제</h4>
<ol type="1">
<li><strong>Adam 옵티마이저:</strong> Adam 옵티마이저의 작동 원리를 (수식을 포함하여) 설명하고, <span class="math inline">\(\beta_1\)</span> 과 <span class="math inline">\(\beta_2\)</span> 파라미터의 역할에 대해 설명해보세요.</li>
<li><strong>배치 정규화와 초기화:</strong> 배치 정규화(Batch Normalization)가 초기화 방법의 중요성을 어떻게 감소시키는지 설명하고, 그 이유를 설명해보세요.</li>
<li><strong>가우시안 손실 평면:</strong> 가우시안 함수를 사용해서 손실 평면을 근사하는 예제(5.5.1절)에서, 가우시안 함수의 파라미터(진폭, 중심점, 분산)가 최적화 과정에 미치는 영향에 대하여 설명해보세요. (각 파라미터를 변경하면서 최적화 경로가 어떻게 달라지는지 관찰해보세요.)</li>
</ol>
</section>
<section id="심화-문제" class="level4">
<h4 class="anchored">심화 문제</h4>
<ol type="1">
<li><strong>Lion 옵티마이저 분석:</strong> Lion 옵티마이저의 핵심 아이디어를 (수식을 포함하여) 설명하고, Adam과 비교하여 어떤 장단점이 있는지 분석해보세요.</li>
<li><strong>초기화 방법 실험:</strong> 주어진 데이터셋(예: FashionMNIST)과 모델(5.1절의 SimpleNetwork)에 대해, 서로 다른 초기화 방법(LeCun, Xavier, Kaiming, Orthogonal)을 적용하여 학습시키고, 그 결과(오차율, 수렴 속도, 평균 조건수, 스펙트럴 놈, 유효 랭크비)를 비교 분석해보세요.</li>
<li><strong>최적화 경로 시각화:</strong> 5.5절의 최적화 경로 시각화 코드를 참고하여, 자신만의 손실 함수(예: 다봉형 함수, 비볼록 함수)를 정의하고, 다양한 옵티마이저(SGD, Momentum, Adam, Lion 등)의 최적화 경로를 시각화하고 비교 분석해보세요. (최소 3개 이상의 옵티마이저 비교)</li>
</ol>
<div class="callout callout-style-default callout-note callout-titled" title="클릭하여 내용 보기 (위상 기반 손실 표면 분석)">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-5-contents" aria-controls="callout-5" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
클릭하여 내용 보기 (위상 기반 손실 표면 분석)
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-5" class="callout-5-contents callout-collapse collapse">
<section id="연습-문제-해답" class="level3 callout-body-container callout-body">
<h3 class="anchored" data-anchor-id="연습-문제-해답">연습 문제 해답</h3>
<section id="기본-문제-1" class="level4">
<h4 class="anchored" data-anchor-id="기본-문제-1">기본 문제</h4>
<ol type="1">
<li><p><strong>SGD 수동 계산:</strong></p>
<ul>
<li><strong>1단계:</strong>
<ul>
<li><span class="math inline">\(g_0 = \frac{dL}{dw}(w_0) = 2w_0 = 4\)</span></li>
<li><span class="math inline">\(v_0 = 0\)</span> (모멘텀 초기값)</li>
<li><span class="math inline">\(w_1 = w_0 - \eta v_1 = 2 - 0.1 \cdot (0.9 \cdot 0 + 4) = 1.6\)</span></li>
</ul></li>
<li><strong>2단계:</strong>
<ul>
<li><span class="math inline">\(g_1 = 2w_1 = 3.2\)</span></li>
<li><span class="math inline">\(v_1 = 0.9 \cdot v_0 + g_0= 0.9 \cdot 0 + 4 = 4\)</span></li>
<li><span class="math inline">\(w_2 = w_1 - \eta \cdot (0.9 \cdot v_1 + g_1) = 1.6 - 0.1 \cdot (0.9 \cdot 4+ 3.2) = 0.92\)</span></li>
</ul></li>
<li><strong>3단계:</strong>
<ul>
<li><span class="math inline">\(g_2 = 2w_2 = 1.84\)</span></li>
<li><span class="math inline">\(v_2 = 0.9 \cdot 4 + 3.2 = 6.8\)</span></li>
<li><span class="math inline">\(w_3 = w_2 - \eta \cdot (0.9 * v_2 + g_2) = 0.92 - 0.1 \cdot (0.9 \cdot 6.8 + 1.84) = 0.124\)</span></li>
</ul></li>
</ul></li>
<li><p><strong>경사하강법 수렴 속도 비교:</strong></p>
<ul>
<li>학습률이 클수록 (0.1) 초기 수렴은 빠르지만, 최적점 근처에서 진동할 수 있습니다.</li>
<li>학습률이 작을수록 (0.001) 수렴 속도는 느리지만, 더 안정적으로 최적점에 접근합니다.</li>
<li>적절한 학습률(0.01)은 적당한 수렴속도와 안정성을 보입니다.</li>
</ul></li>
<li><p><strong>초기화 방법 비교:</strong></p>
<ul>
<li><strong>Kaiming 초기화:</strong> ReLU 활성화 함수의 특성(음수 입력을 0으로 만듦)을 고려하여, <span class="math inline">\(\sqrt{2/n_{in}}\)</span> 의 표준편차를 갖는 분포로 가중치를 초기화합니다.</li>
<li><strong>Xavier 초기화:</strong> 활성화 함수의 종류와 관계없이 입력과 출력의 분산을 유지하는 <span class="math inline">\(\sqrt{2/(n_{in} + n_{out})}\)</span> 의 표준편차를 사용합니다.</li>
<li><strong>ReLU + Kaiming:</strong> ReLU는 양수 영역에서 선형 활성화를 가지므로, Kaiming 초기화가 더 큰 분산을 제공하여 “죽은 뉴런” 문제를 완화하고, 더 빠른 학습을 돕습니다.</li>
</ul></li>
</ol>
</section>
<section id="응용-문제-1" class="level4">
<h4 class="anchored" data-anchor-id="응용-문제-1">응용 문제</h4>
<ol type="1">
<li><p><strong>Adam 옵티마이저:</strong></p>
<ul>
<li><strong>작동 원리:</strong> Adam은 모멘텀(Momentum)과 RMSProp의 아이디어를 결합한 옵티마이저입니다.
<ul>
<li><strong>모멘텀:</strong> 과거 그래디언트의 지수 가중 평균(1차 모멘트, <span class="math inline">\(m_t\)</span>)을 사용하여 관성을 부여합니다.</li>
<li><strong>RMSProp:</strong> 과거 그래디언트 제곱의 지수 가중 평균(2차 모멘트, <span class="math inline">\(v_t\)</span>)을 사용하여 파라미터별 학습률을 조정합니다.</li>
<li><strong>편향 보정:</strong> 초기 단계에서 <span class="math inline">\(m_t\)</span> 와 <span class="math inline">\(v_t\)</span> 가 0으로 편향되는 것을 보정합니다.</li>
</ul></li>
<li><strong>수식:</strong>
<ul>
<li><span class="math inline">\(m_t = \beta_1 m_{t-1} + (1 - \beta_1) g_t\)</span></li>
<li><span class="math inline">\(v_t = \beta_2 v_{t-1} + (1 - \beta_2) g_t^2\)</span></li>
<li><span class="math inline">\(\hat{m_t} = m_t / (1 - \beta_1^t)\)</span></li>
<li><span class="math inline">\(\hat{v_t} = v_t / (1 - \beta_2^t)\)</span></li>
<li><span class="math inline">\(w_{t+1} = w_t - \eta \hat{m_t} / (\sqrt{\hat{v_t}} + \epsilon)\)</span></li>
</ul></li>
<li><strong><span class="math inline">\(\beta_1\)</span>, <span class="math inline">\(\beta_2\)</span> 역할:</strong>
<ul>
<li><span class="math inline">\(\beta_1\)</span>: 1차 모멘트(모멘텀)의 지수 감소율을 조절합니다. (일반적으로 0.9)</li>
<li><span class="math inline">\(\beta_2\)</span>: 2차 모멘트(RMSProp)의 지수 감소율을 조절합니다. (일반적으로 0.999)</li>
</ul></li>
</ul></li>
<li><p><strong>배치 정규화와 초기화:</strong></p>
<ul>
<li><strong>배치 정규화:</strong> 각 미니배치의 입력을 평균 0, 분산 1로 정규화합니다.</li>
<li><strong>초기화 중요성 감소:</strong> 배치 정규화는 네트워크 내부 공변량 변화(internal covariate shift)를 줄여, 초기 가중치 분포에 대한 의존성을 낮춥니다.</li>
<li><strong>이유:</strong> 정규화된 입력은 활성화 함수를 적절한 범위(예: ReLU의 양수 영역)에 위치시켜, 그래디언트 소실/폭발 문제를 완화하고, 학습을 안정화합니다.</li>
</ul></li>
<li><p><strong>가우시안 손실 평면:</strong></p>
<ul>
<li><strong>진폭 (A):</strong> 손실 함수의 전반적인 크기를 조절합니다. 진폭이 크면 손실 값의 변화폭이 커져 학습이 불안정해질 수 있습니다.</li>
<li><strong>중심점 (<span class="math inline">\(x_0\)</span>, <span class="math inline">\(y_0\)</span>):</strong> 손실 함수의 최솟값 위치를 결정합니다. 최적화 알고리즘은 이 중심점을 향해 이동합니다.</li>
<li><strong>분산 (<span class="math inline">\(\sigma_1\)</span>, <span class="math inline">\(\sigma_2\)</span>):</strong> 각 축 방향으로의 손실 함수 변화 정도를 나타냅니다. 분산이 작으면 좁고 뾰족한 형태, 크면 넓고 완만한 형태가 됩니다. 분산이 다르면 각 방향으로의 학습 속도를 다르게 조절해야 합니다.</li>
</ul></li>
</ol>
</section>
<section id="심화-문제-1" class="level4">
<h4 class="anchored" data-anchor-id="심화-문제-1">심화 문제</h4>
<ol type="1">
<li><p><strong>Lion 옵티마이저 분석:</strong></p>
<ul>
<li><strong>핵심 아이디어:</strong> 그래디언트의 부호(sign)만을 사용하여 업데이트를 수행합니다.</li>
<li><strong>수식:</strong> <code>c_t = β_1 * m_{t-1} + (1 - β_1) * g_t     w_{t+1} = w_t - η * sign(c_t)     m_t = c_t</code>
<ul>
<li>update의 부호만 사용하므로, Adam처럼 2nd moment를 계산, 저장할 필요없음</li>
</ul></li>
<li><strong>장점:</strong>
<ul>
<li>Adam보다 메모리 사용량이 적습니다. (2차 모멘트를 저장하지 않음)</li>
<li>업데이트 크기가 모든 파라미터에 대해 동일하여, 희소한 그래디언트에 강건합니다.</li>
</ul></li>
<li><strong>단점:</strong>
<ul>
<li>그래디언트의 크기 정보를 무시하므로, 특정 상황에서 Adam보다 느리게 수렴할 수 있습니다.</li>
<li>학습률 튜닝이 Adam보다 더 민감할 수 있습니다.</li>
</ul></li>
</ul></li>
<li><p><strong>초기화 방법 실험:</strong></p>
<ul>
<li><strong>실험 설계:</strong>
<ul>
<li>동일한 모델(SimpleNetwork)과 데이터셋(FashionMNIST)을 사용합니다.</li>
<li>LeCun, Xavier, Kaiming, Orthogonal 초기화를 각각 적용합니다.</li>
<li>동일한 최적화 알고리즘(예: Adam)과 학습률을 사용합니다.</li>
<li>충분한 에폭(예: 20) 동안 학습시키고, 각 에폭마다 평가 지표(오차율, 수렴 속도, 평균 조건수, 스펙트럴 놈, 유효 랭크비)를 기록합니다.</li>
</ul></li>
<li><strong>결과 분석:</strong>
<ul>
<li>ReLU 활성화 함수를 사용하는 경우, Kaiming 초기화가 가장 좋은 성능을 보일 가능성이 높습니다.</li>
<li>Orthogonal 초기화는 RNN/LSTM에서 좋은 성능을 보일 수 있습니다.</li>
<li>Xavier 초기화는 tanh, sigmoid 활성화 함수에서 좋은 성능을 보일 수 있습니다.</li>
<li>LeCun 초기화는 현대적인 네트워크에서는 성능이 떨어질 수 있습니다.</li>
</ul></li>
</ul></li>
<li><p><strong>최적화 경로 시각화:</strong></p>
<ul>
<li><strong>자신만의 손실 함수 정의:</strong>
<ul>
<li>예: <span class="math inline">\(f(x, y) = (x^2 + y - 11)^2 + (x + y^2 - 7)^2\)</span> (Himmelblau 함수, 다봉형 함수)</li>
<li>예: <span class="math inline">\(f(x, y) = 0.5x^2 - 0.25y^2 + 3\)</span> (안장점(saddle point)이 있는 비볼록 함수)</li>
</ul></li>
<li><strong>최적화 알고리즘 선택:</strong> SGD, Momentum(SGD with momentum), Adam, Lion</li>
<li><strong>시각화:</strong> 5.5절의 코드를 참고하여 각 옵티마이저의 최적화 경로를 2차원 평면에 시각화합니다.</li>
<li><strong>결과 분석:</strong>
<ul>
<li>SGD는 지역 최솟값/안장점에 빠질 가능성이 높습니다.</li>
<li>Momentum은 관성을 통해 지역 최솟값을 탈출할 가능성이 있지만, 진동할 수 있습니다.</li>
<li>Adam은 적응형 학습률 덕분에 더 효율적으로 최적점에 도달할 수 있습니다.</li>
<li>Lion은 Adam과 유사하거나 더 빠른 수렴을 보일 수 있지만, 학습률 튜닝에 민감할 수 있습니다.</li>
<li>다봉, 안장점 등 손실함수의 형태에 따라 최적화 결과를 비교분석합니다.</li>
</ul></li>
</ul></li>
</ol>
</section>
</section>
</div>
</div>
</section>
</section>
<section id="참고-자료" class="level3">
<h3 class="anchored" data-anchor-id="참고-자료">참고 자료</h3>
<ol type="1">
<li><strong><a href="https://arxiv.org/abs/1609.04747">An overview of gradient descent optimization algorithms</a></strong> (Sebastian Ruder, 2016) - 딥러닝 최적화 알고리즘에 대한 훌륭한 개요 논문입니다. SGD, Momentum, AdaGrad, RMSProp, Adam 등 다양한 알고리즘을 비교 분석합니다.</li>
<li><strong><a href="https://arxiv.org/abs/1712.09913">Visualizing the Loss Landscape of Neural Nets</a></strong> (Li et al., 2018) - 손실 표면 시각화에 대한 선구적인 논문입니다. 잔차 연결(residual connection)이 손실 표면을 어떻게 평탄화하는지 보여줍니다.</li>
<li><strong><a href="https://www.google.com/search?q=https://ruder.io/deep-learning-optimization-2023/">Optimization for Deep Learning Highlights in 2023</a></strong> (Sebastian Ruder, 2023) - 2023년 딥러닝 최적화 주요 내용을 요약한 블로그 글입니다. 최신 연구 동향을 파악하는 데 유용합니다.</li>
<li><strong><a href="https://arxiv.org/abs/2110.08536">Improving Deep Learning with Better Initialization</a></strong> (Mishkin &amp; Matas, 2021) - 초기화에 대한 현대적 연구 동향을 담은 논문입니다. 다양한 초기화 방법을 비교하고, 실용적인 가이드라인을 제시합니다.</li>
<li><strong><a href="https://www.google.com/url?sa=E&amp;source=gmail&amp;q=https://arxiv.org/abs/2302.06675">Symbolic Discovery of Optimization Algorithms</a></strong> (Chen et al.&nbsp;2023) - 구글 브레인에서 발견한 Lion 알고리즘에 관한 논문</li>
<li><strong><a href="https://arxiv.org/abs/1912.07145">PyHessian: Neural Networks Through the Lens of the Hessian</a></strong> (Yao et al., 2020) - 헤시안 행렬을 이용한 손실 표면 분석 도구 PyHessian에 대한 논문입니다.</li>
<li><strong><a href="https://arxiv.org/abs/1705.08292">The Marginal Value of Adaptive Gradient Methods in Machine Learning</a></strong> (Wilson et al., 2017) - 적응형 학습률 방법(Adam 등)이 항상 SGD보다 좋은 것은 아니라는 것을 보여주는 논문입니다.</li>
<li><strong><a href="https://www.offconvex.org/2016/03/22/saddlepoints/">How to escape saddle points efficiently</a></strong> (Ge et al., 2015) - 섭동 경사하강법(perturbed gradient descent)을 사용하여 안장점을 효율적으로 탈출하는 방법을 설명하는 블로그 글입니다.</li>
<li><strong><a href="https://www.google.com/search?q=https://openreview.net/forum%3Fid%3DFpgg9h-xO_a">Deep Understanding of Modern Initialization Methods with Block Diagonal Matrices</a></strong> (Huang et al., 2021) - 블록 대각 행렬을 사용하여 초기화 방법을 분석하는 논문입니다.</li>
<li><strong><a href="https://www.google.com/search?q=https://proceedings.neurips.cc/paper/2020/hash/9c838d2e45b2ad1094d42f4ef36764f6-Abstract.html">AdaHessian: An Adaptive Second Order Optimizer for Machine Learning</a></strong> (Yao et al., 2020) - 헤시안 행렬의 대각 성분을 사용하여 2차 정보를 활용하는 AdaHessian 옵티마이저에 대한 논문입니다.</li>
<li><strong><a href="https://arxiv.org/abs/2411.01593">A Closer Look at Smoothness in Deep Learning: A Tensor Decomposition Approach</a></strong> (Li et al., 2024) - 텐서 분해를 사용하여 딥러닝 모델의 평활성(smoothness)을 분석하는 논문입니다.</li>
<li><strong><a href="https://arxiv.org/abs/2502.00894">Understanding Measures of Efficiency for Stochastic Optimization</a></strong> (Defazio &amp; Bottou, 2025) - 확률적 최적화 알고리즘의 효율성을 측정하는 방법을 제안하는 논문입니다.</li>
<li><strong><a href="https://www.google.com/url?sa=E&amp;source=gmail&amp;q=https://www.deeplearningbook.org/">Deep Learning</a></strong> (Goodfellow, Bengio, Courville, 2016) - 딥러닝 교과서. 6장(Deep Feedforward Networks), 8장(Optimization for Training Deep Models)에서 초기화 및 최적화 관련 내용을 다룹니다.</li>
<li><strong><a href="https://www.google.com/url?sa=E&amp;source=gmail&amp;q=https://cs231n.github.io/optimization-1/">Stanford CS231n: Convolutional Neural Networks for Visual Recognition</a></strong> - 스탠포드 대학교 딥러닝 강의. Optimization 파트에서 최적화 관련 내용을 다룹니다.</li>
<li><strong><a href="https://www.google.com/search?q=https://paperswithcode.com/methods/category/optimization-methods">Papers with Code - Optimization Methods</a></strong> - 최적화 관련 최신 논문들을 모아놓은 웹사이트입니다.</li>
</ol>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>