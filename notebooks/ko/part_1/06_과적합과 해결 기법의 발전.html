<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>quarto-input749202496d9f251f – Deep Learning DNA: Surviving Architectures and Essential Principles</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap-f507c7d0488cb7630e20aad62ad8c2aa.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script>window.MathJax = {loader: {load: ['[tex]/boldsymbol']},tex: {packages: {'[+]': ['boldsymbol']}}};</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-sidebar docked">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../../notebooks/ko/part_1/01_딥러닝의 시작.html">part_1</a></li><li class="breadcrumb-item"><a href="../../../notebooks/ko/part_1/06_과적합과 해결 기법의 발전.html">6. 과적합과 해결 기법의 발전</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../../../">한국어</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Language</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../index_de.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Deutsch</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../index_en.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">English</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../index_es.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Español</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">한국어</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../index_zh.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">中文</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../notebooks/ko/part_1/00_서론.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">서론</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true">
 <span class="menu-text">part_1</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../notebooks/ko/part_1/01_딥러닝의 시작.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">1. 딥러닝의 시작</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../notebooks/ko/part_1/02_딥러닝의 수학.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">2. 딥러닝의 수학</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../notebooks/ko/part_1/03_딥러닝프레임워크.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">3. 딥러닝프레임워크</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../notebooks/ko/part_1/04_활성화함수.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">4. 활성화함수</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../notebooks/ko/part_1/05_최적화와 시각화.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">5. 최적화와 시각화</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../notebooks/ko/part_1/06_과적합과 해결 기법의 발전.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">6. 과적합과 해결 기법의 발전</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../notebooks/ko/part_1/07_합성곱 신경망의 진화.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">7. 합성곱 신경망의 진화</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../notebooks/ko/part_1/08_트랜스포머의 탄생.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">8. 트랜스포머의 탄생</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../notebooks/ko/part_1/09_트랜스포머의 진화.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">9. 트랜스포머의 진화</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../notebooks/ko/part_1/10_멀티모달 딥러닝: 다중 감각 융합의 시작.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">10. 멀티모달 딥러닝: 다중 감각 융합의 시작</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../notebooks/ko/part_1/11_멀티모달 딥러닝: 한계를 넘어선 지능.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">11. 멀티모달 딥러닝: 한계를 넘어선 지능</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true">
 <span class="menu-text">딥러닝의 최전선</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../notebooks/ko/딥러닝의 최전선/01_SLM: 작지만 강력한 언어모델.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">1. SLM: 작지만 강력한 언어모델</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../notebooks/ko/딥러닝의 최전선/02_자율주행.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">2. 자율주행</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#장-과적합과-해결-기법의-발전" id="toc-장-과적합과-해결-기법의-발전" class="nav-link active" data-scroll-target="#장-과적합과-해결-기법의-발전">6장 과적합과 해결 기법의 발전</a>
  <ul class="collapse">
  <li><a href="#과적합의-이해" id="toc-과적합의-이해" class="nav-link" data-scroll-target="#과적합의-이해">6.1 과적합의 이해</a></li>
  <li><a href="#규제화-기법" id="toc-규제화-기법" class="nav-link" data-scroll-target="#규제화-기법">6.2 규제화 기법</a>
  <ul class="collapse">
  <li><a href="#l1-l2-규제" id="toc-l1-l2-규제" class="nav-link" data-scroll-target="#l1-l2-규제">6.2.1 L1, L2 규제</a></li>
  <li><a href="#파이토치에서-l1-l2-규제-적용" id="toc-파이토치에서-l1-l2-규제-적용" class="nav-link" data-scroll-target="#파이토치에서-l1-l2-규제-적용">6.2.2 파이토치에서 L1, L2 규제 적용</a></li>
  <li><a href="#손실-평면에서의-규제효과-분석" id="toc-손실-평면에서의-규제효과-분석" class="nav-link" data-scroll-target="#손실-평면에서의-규제효과-분석">6.2.3 손실 평면에서의 규제효과 분석</a></li>
  </ul></li>
  <li><a href="#드롭아웃dropout" id="toc-드롭아웃dropout" class="nav-link" data-scroll-target="#드롭아웃dropout">6.3 드롭아웃(Dropout)</a>
  <ul class="collapse">
  <li><a href="#드롭아웃의-원리" id="toc-드롭아웃의-원리" class="nav-link" data-scroll-target="#드롭아웃의-원리">6.3.1 드롭아웃의 원리</a></li>
  <li><a href="#파이토치에서-드롭아웃의-구현" id="toc-파이토치에서-드롭아웃의-구현" class="nav-link" data-scroll-target="#파이토치에서-드롭아웃의-구현">6.3.2 파이토치에서 드롭아웃의 구현</a></li>
  </ul></li>
  <li><a href="#배치-정규화batch-normalization" id="toc-배치-정규화batch-normalization" class="nav-link" data-scroll-target="#배치-정규화batch-normalization">6.4 배치 정규화(batch normalization)</a>
  <ul class="collapse">
  <li><a href="#배치정규화의-개념과-효과" id="toc-배치정규화의-개념과-효과" class="nav-link" data-scroll-target="#배치정규화의-개념과-효과">6.4.1 배치정규화의 개념과 효과</a></li>
  <li><a href="#파이토치에서의-배치-정규화-구현" id="toc-파이토치에서의-배치-정규화-구현" class="nav-link" data-scroll-target="#파이토치에서의-배치-정규화-구현">6.4.2 파이토치에서의 배치 정규화 구현</a></li>
  <li><a href="#통계-추적과-추론-시-적용" id="toc-통계-추적과-추론-시-적용" class="nav-link" data-scroll-target="#통계-추적과-추론-시-적용">6.4.3 통계 추적과 추론 시 적용</a></li>
  </ul></li>
  <li><a href="#하이퍼파라미터의-최적화" id="toc-하이퍼파라미터의-최적화" class="nav-link" data-scroll-target="#하이퍼파라미터의-최적화">6.5 하이퍼파라미터의 최적화</a>
  <ul class="collapse">
  <li><a href="#최적화-방법론-비교" id="toc-최적화-방법론-비교" class="nav-link" data-scroll-target="#최적화-방법론-비교">6.5.1 최적화 방법론 비교</a></li>
  <li><a href="#bayes-opt를-이용한-최적화" id="toc-bayes-opt를-이용한-최적화" class="nav-link" data-scroll-target="#bayes-opt를-이용한-최적화">6.5.2 Bayes-Opt를 이용한 최적화</a></li>
  <li><a href="#botorch를-이용한-최적화" id="toc-botorch를-이용한-최적화" class="nav-link" data-scroll-target="#botorch를-이용한-최적화">6.5.3 BoTorch를 이용한 최적화</a></li>
  </ul></li>
  <li><a href="#가우시안-프로세스" id="toc-가우시안-프로세스" class="nav-link" data-scroll-target="#가우시안-프로세스">6.6 가우시안 프로세스</a>
  <ul class="collapse">
  <li><a href="#불확실성-처리의-수학적-기초" id="toc-불확실성-처리의-수학적-기초" class="nav-link" data-scroll-target="#불확실성-처리의-수학적-기초">6.6.1 불확실성 처리의 수학적 기초</a></li>
  <li><a href="#현대적-응용" id="toc-현대적-응용" class="nav-link" data-scroll-target="#현대적-응용">6.6.2 현대적 응용</a></li>
  <li><a href="#심층-커널-학습deep-kernel-learning" id="toc-심층-커널-학습deep-kernel-learning" class="nav-link" data-scroll-target="#심층-커널-학습deep-kernel-learning">6.6.3 심층 커널 학습(Deep Kernel Learning)</a></li>
  </ul></li>
  <li><a href="#연습문제" id="toc-연습문제" class="nav-link" data-scroll-target="#연습문제">연습문제</a>
  <ul class="collapse">
  <li><a href="#기본-문제" id="toc-기본-문제" class="nav-link" data-scroll-target="#기본-문제">기본 문제</a></li>
  <li><a href="#응용-문제" id="toc-응용-문제" class="nav-link" data-scroll-target="#응용-문제">응용 문제</a></li>
  <li><a href="#심화-문제" id="toc-심화-문제" class="nav-link" data-scroll-target="#심화-문제">심화 문제</a></li>
  </ul></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../../notebooks/ko/part_1/01_딥러닝의 시작.html">part_1</a></li><li class="breadcrumb-item"><a href="../../../notebooks/ko/part_1/06_과적합과 해결 기법의 발전.html">6. 과적합과 해결 기법의 발전</a></li></ol></nav></header>




<p><a href="https://colab.research.google.com/github/Quantum-Intelligence-Frontier/dldna/blob/main/notebooks/ko/part_1/06_과적합과 해결 기법의 발전.ipynb" target="_parent"> <img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"> </a></p>
<section id="장-과적합과-해결-기법의-발전" class="level1">
<h1>6장 과적합과 해결 기법의 발전</h1>
<blockquote class="blockquote">
<p>“단순함이 궁극의 정교함이다.” - 레오나르도 다 빈치 (Leonardo da Vinci)</p>
</blockquote>
<p>딥러닝 모델은 수많은 파라미터를 통해 복잡한 함수를 표현할 수 있는 강력한 능력을 지닙니다. 하지만 이러한 능력은 때때로 <em>양날의 검</em>과 같습니다. 모델이 훈련 데이터에 지나치게 맞춰지면, 새로운 데이터에 대한 예측 성능이 오히려 떨어지는 <strong>과적합(overfitting)</strong> 현상이 발생하기 때문입니다.</p>
<p>1986년 역전파 알고리즘이 재조명된 이후, 과적합은 딥러닝 연구자들에게 끊임없는 도전 과제였습니다. 초기에는 단순히 모델의 크기를 줄이거나, 훈련 데이터를 늘리는 방식으로 과적합에 대응했습니다. 하지만 이러한 방법들은 모델의 표현력을 제한하거나, 데이터 수집의 어려움으로 인해 한계가 있었습니다. 2012년 AlexNet의 등장은 딥러닝의 새로운 시대를 열었지만, 동시에 과적합 문제의 심각성을 부각시켰습니다. AlexNet은 이전 모델들보다 훨씬 많은 파라미터를 가졌기 때문에, 과적합의 위험이 더욱 커졌습니다. 이후 딥러닝 모델의 규모가 기하급수적으로 증가하면서, 과적합 문제는 딥러닝 연구의 핵심 과제가 되었습니다.</p>
<p>이 장에서는 과적합의 본질을 이해하고, 이를 해결하기 위해 발전해 온 다양한 기법들을 살펴보겠습니다. 마치 탐험가가 미지의 영역을 탐험하며 지도를 만들어나가듯, 딥러닝 연구자들은 과적합이라는 난관을 극복하기 위해 끊임없이 새로운 방법들을 탐색하고 발전시켜 왔습니다.</p>
<section id="과적합의-이해" class="level2">
<h2 class="anchored" data-anchor-id="과적합의-이해">6.1 과적합의 이해</h2>
<p>과적합은 1670년 William Hopkins의 저술에서 처음 언급되었지만, 현대적인 의미로는 1935년 <em>Quarterly Review of Biology</em>에서 “13개의 관측치로 6변량 분석을 하는 것은 과적합처럼 보인다”라는 언급으로 시작되었습니다. 이후 1950년대 통계학에서 본격적으로 연구되기 시작했으며, 특히 1952년 “Tests of Fit in Time Series” 논문에서 시계열 분석의 맥락에서 중요하게 다뤄졌습니다.</p>
<p>딥러닝에서 과적합 문제는 2012년 AlexNet의 등장과 함께 새로운 국면을 맞이했습니다. AlexNet은 약 6천만 개의 파라미터를 가진 대규모 신경망으로, 이전 모델들과 비교할 수 없는 규모였습니다. 이후 딥러닝 모델의 규모가 기하급수적으로 증가하면서, 과적합 문제는 더욱 심각해졌습니다. 예를 들어, 현대의 대규모 언어 모델(LLM)들은 수천억 개의 파라미터를 가지고 있어, 과적합 방지가 모델 설계의 핵심 과제가 되었습니다.</p>
<p>이러한 도전에 대응하여, 드롭아웃(2014), 배치 정규화(2015)와 같은 혁신적인 해결책들이 제안되었고, 최근에는 훈련 이력을 활용한 과적합 감지 및 예방(2024) 등 더욱 정교한 방법들이 연구되고 있습니다. 특히 대규모 모델에서는 조기 종료(early stopping)와 같은 전통적인 방법부터 앙상블 학습, 데이터 증강과 같은 현대적 기법까지 다양한 전략을 복합적으로 활용하고 있습니다.</p>
<p>간단한 예제를 통해 과적합 현상을 직관적으로 이해해 보겠습니다. 노이즈가 포함된 사인(sine) 함수 데이터에 대해 서로 다른 차수(degree)의 다항식(polynomial)을 적용해 보겠습니다.</p>
<div id="cell-2" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="op">!</span>pip install dldna[colab] <span class="co"># in Colab</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co"># !pip install dldna[all] # in your local</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>load_ext autoreload</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>autoreload <span class="dv">2</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="cell-3" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Noisy sin graph</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> real_func(x):</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> np.sin(x) <span class="op">+</span> np.random.uniform(<span class="op">-</span><span class="fl">0.2</span>, <span class="fl">0.2</span>, <span class="bu">len</span>(x))</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> y</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Create x data from 40 to 320 degrees.  Use a step value to avoid making it too dense.</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.array([np.pi<span class="op">/</span><span class="dv">180</span> <span class="op">*</span> i <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">40</span>, <span class="dv">320</span>, <span class="dv">4</span>)])</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> real_func(x)</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>sns.scatterplot(x<span class="op">=</span>x, y<span class="op">=</span>y, label<span class="op">=</span><span class="st">'real function'</span>)</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot with 1st, 3rd, and 21th degree polynomials.  </span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> deg <span class="kw">in</span> [<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">21</span>]:  </span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Get the coefficients for the corresponding degree using polyfit, and create the estimated function using poly1d.</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>    params <span class="op">=</span> np.polyfit(x, y, deg) <span class="co"># Get the parameter values</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># print(f" {deg} params = {params}")</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> np.poly1d(params) <span class="co"># Get the line function</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>    sns.lineplot(x<span class="op">=</span>x, y<span class="op">=</span>p(x), color<span class="op">=</span><span class="ss">f"C</span><span class="sc">{</span>deg<span class="sc">}</span><span class="ss">"</span>, label<span class="op">=</span><span class="ss">f"deg = </span><span class="sc">{</span>deg<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>The autoreload extension is already loaded. To reload it, use:
  %reload_ext autoreload</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>/tmp/ipykernel_1362795/2136320363.py:25: RankWarning: Polyfit may be poorly conditioned
  params = np.polyfit(x, y, deg) # Get the parameter values</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="06_과적합과 해결 기법의 발전_files/figure-html/cell-3-output-3.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>위 코드는 노이즈가 포함된 사인 함수 데이터를 생성하고, 1차, 3차, 21차 다항식을 사용하여 이 데이터에 피팅(fitting)하는 예제입니다.</p>
<ul>
<li><p><strong>1차 함수 (deg = 1):</strong> 데이터의 전반적인 추세를 따르지 못하고 단순한 직선 형태로 나타납니다. 이는 모델이 데이터의 복잡성을 충분히 표현하지 못하는 <em>과소적합(underfitting)</em> 상태를 보여줍니다.</p></li>
<li><p><strong>3차 함수 (deg = 3):</strong> 데이터의 기본적인 패턴을 비교적 잘 포착하면서도, 노이즈에 크게 흔들리지 않는 부드러운 곡선 형태를 보입니다.</p></li>
<li><p><strong>21차 함수 (deg = 21)</strong>: 훈련 데이터의 노이즈까지 지나치게 따라가면서, 훈련 데이터에만 과도하게 최적화된 <em>과적합(overfitting)</em> 상태를 보여줍니다.</p></li>
</ul>
<p>이처럼 모델의 복잡도(여기서는 다항식의 차수)가 너무 낮으면 과소적합, 너무 높으면 과적합이 발생합니다. 우리가 궁극적으로 찾고자 하는 것은 훈련 데이터뿐만 아니라 새로운 데이터에도 잘 일반화(generalization)되는 모델, 즉, 실제 사인 함수에 가장 가까운 근사 함수입니다.</p>
<p>과적합은 모델의 복잡도(용량, capacity)가 훈련 데이터의 양에 비해 상대적으로 클 때 발생합니다. 신경망은 수많은 파라미터를 가지며 표현력이 매우 높기 때문에, 특히 과적합에 취약합니다. 훈련 데이터가 부족하거나, 데이터에 노이즈가 많을 때도 과적합이 발생할 수 있습니다. 과적합은 다음과 같은 특징으로 나타납니다.</p>
<ul>
<li><strong>훈련 데이터</strong>에 대한 손실(loss)은 지속적으로 감소합니다.</li>
<li><strong>검증 데이터</strong>(validation data) 에 대한 손실은 감소하다가, 어느 시점부터는 오히려 증가합니다.</li>
<li>이는 모델이 훈련 데이터의 노이즈와 세세한 부분까지 학습하여, 훈련 데이터에만 지나치게 특화되었기 때문입니다.</li>
</ul>
<p>결과적으로, 과적합된 모델은 훈련 데이터에서는 높은 성능을 보이지만, 실제 새로운 데이터에서는 예측 성능이 떨어지게 됩니다. 이러한 과적합을 방지하기 위해, 이후에는 L1/L2 규제, 드롭아웃, 배치 정규화 등 다양한 기법들을 자세히 살펴보겠습니다.</p>
</section>
<section id="규제화-기법" class="level2">
<h2 class="anchored" data-anchor-id="규제화-기법">6.2 규제화 기법</h2>
<blockquote class="blockquote">
<p><strong>도전과제:</strong> 모델의 복잡도를 효과적으로 제어하면서 일반화 성능을 향상시킬 수 있는 방법은 무엇일까?</p>
<p><strong>연구자의 고뇌:</strong> 과적합을 막기 위해 모델의 크기를 줄이는 것은 표현력을 제한할 수 있고, 단순히 훈련 데이터를 늘리는 것도 항상 가능한 것은 아닙니다. 모델의 구조나 학습 과정에 제약을 가하여 훈련 데이터에 대한 과도한 최적화를 방지하고, 새로운 데이터에 대한 예측 성능을 향상시키는 방법이 필요했습니다.</p>
</blockquote>
<section id="l1-l2-규제" class="level3">
<h3 class="anchored" data-anchor-id="l1-l2-규제">6.2.1 L1, L2 규제</h3>
<p>신경망에서 사용하는 대표적인 규제(regularization)로는 L1, L2 규제가 있습니다. L1은 라소(Lasso), L2는 리지(Ridge) 규제(를 이용한 선형 회귀)를 뜻합니다.</p>
<p>리지 회귀, 라소 회귀라고도 부르는데, 각 회귀는 일정한 페널티 항을 도입해서 파라미터의 움직임을 제한합니다. 두 방법의 특성 차이를 표로 정리하면 다음과 같습니다.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 27%">
<col style="width: 38%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th>특징</th>
<th>리지 회귀(Ridge Regression)</th>
<th>라소 회귀(Lasso Regression)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>페널티 유형</td>
<td>L2 페널티를 부과한다. 페널티 항은 파라미터의 제곱값 합산에 알파값을 곱한 항이다.</td>
<td>L1 페널티를 부과한다. 파라미터 절대값 합산에 알파값을 곱한 항이다.</td>
</tr>
<tr class="even">
<td>파라미터 영향</td>
<td>값이 큰 파라미터를 억제하여 0에 가깝게 도달하게 만든다. 0이 되지는 않는다</td>
<td>알파 값이 클 때 일부 파라미터 값을 0으로 만들어서 보다 간소한 모델을 만들 수 있다</td>
</tr>
<tr class="odd">
<td>전체 영향</td>
<td>모든 파라미터가 그대로 보존. 따라서 영향도가 적은 파라미터도 그대로 남는다.</td>
<td>관련있는 파라미터만 남아 선택적 특성을 가진다. 복잡한 모델을 좀 더 단순하게 설명할 수 있게 한다.</td>
</tr>
<tr class="even">
<td>최적화 특성</td>
<td>이상적인 값에 라소에 비해 덜 민감.</td>
<td>페널티 항목이 절대값이기 때문에 이상적인 값에 민감.</td>
</tr>
</tbody>
</table>
<p>수식을 표현하면 다음과 같습니다.</p>
<ul>
<li><p>리지 목적함수 (Ridge Regression Objective Function)</p>
<p>“수정된 리지 목적 함수” = (수정하지 않은 선형 회귀 함수) + <span class="math inline">\(\alpha \cdot \sum (\text{파라미터})^2\)</span></p>
<p><span class="math inline">\(f_{\beta} = \sum_{i=1}^{M} (y_i - \hat{y}_i)^2 + \alpha \sum_{j} \beta_{j}^2\)</span></p>
<p>여기서 <span class="math inline">\(\beta\)</span>는 구하고자 하는 파라미터(가중치) 벡터입니다. <span class="math inline">\(\alpha \sum_{j} \beta_{j}^2\)</span>는 페널티(penalty) 항 또는 규제 항이라고 합니다. <span class="math inline">\(\alpha\)</span>는 규제 항의 크기를 조절하는 하이퍼파라미터입니다. 파라미터를 구하는 공식은 다음과 같습니다.</p>
<p><span class="math inline">\(\beta = \underset{\beta}{\operatorname{argmin}} \left( \sum_{i=1}^{M} (y_i - \hat{y}_i)^2 + \alpha \sum_{j} \beta_{j}^2 \right)\)</span></p></li>
<li><p>라소 목적함수 (Lasso Regression Objective Function)</p>
<p>“수정된 라소 목적 함수” = (수정하지 않은 선형 회귀 함수) + $ || $</p>
<p><span class="math inline">\(f_{\beta} = \sum_{i=1}^{M} (y_i - \hat{y}_i)^2 + \alpha \sum_{j} |\beta_{j}|\)</span></p>
<p><span class="math inline">\(\beta = \underset{\beta}{\operatorname{argmin}} \left( \sum_{i=1}^{M} (y_i - \hat{y}_i)^2 + \alpha \sum_{j} |\beta_j| \right)\)</span></p></li>
</ul>
<p>파라미터 제곱의 합을 페널티 항으로 사용하는 L2를 신경망에서는 흔히 가중치 감쇠(weight decay)라고 합니다. 리지(L2) 회귀를 이용해서 단순 선형회귀와 차이가 어떻게 나는지 살펴보겠습니다. sklearn에 구현된 모델을 사용합니다. 이를 위해 입력인 x데이터를 차수만큼 차원을 늘려 만들어 주어야 합니다. 다음 간단한 유틸리티 함수를 이용해서 만들도록 하겠습니다.</p>
<div id="cell-6" class="cell" data-execution_count="15">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_x_powered(x, p<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    size <span class="op">=</span> <span class="bu">len</span>(x)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># The shape of the created x will be (data size, degree)</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    new_x <span class="op">=</span> np.zeros((size, p))</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> s <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(x)): <span class="co"># Iterate over data size</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> d <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, p<span class="op">+</span><span class="dv">1</span>): <span class="co"># Iterate over degrees</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>            new_x[s][d<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> x[s]<span class="op">**</span>d <span class="co"># Raise x to the power of the degree.</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> new_x</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Let's take a quick look at how it works.</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>deg <span class="op">=</span> <span class="dv">3</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.array([np.pi<span class="op">/</span><span class="dv">180</span> <span class="op">*</span> i <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">20</span>, <span class="dv">35</span>, <span class="dv">5</span>)])</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> real_func(x)  <span class="co"># real_func는 이전 코드에 정의되어 있다고 가정</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"x = </span><span class="sc">{</span>x<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>new_x <span class="op">=</span> get_x_powered(x, p<span class="op">=</span>deg)</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"new_x = </span><span class="sc">{</span>new_x<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>x = [0.34906585 0.43633231 0.52359878]
new_x = [[0.34906585 0.12184697 0.04253262]
 [0.43633231 0.19038589 0.08307151]
 [0.52359878 0.27415568 0.14354758]]</code></pre>
</div>
</div>
<p>3차이기 때문에 <span class="math inline">\(x\)</span>값이 <span class="math inline">\(x^2, x^3\)</span> 으로 늘어납니다. 예를 들어 0.3490, 0.1218(0.3490의 제곱), 0.04253(0.3490의 세제곱) 이 그 예입니다. 만약 10차이면 <span class="math inline">\(x^{10}\)</span> 까지 데이터가 만들어 집니다. 페널티항의 알파값은 0이상 무한대 값을 가질 수 있습니다. 알파값이 커질수록 규제강도가 큰 것입니다. 차수는 13으로 고정하고 선형회귀 함수와 리지회귀를 알파값을 바꿔가며 비교해 보겠습니다.</p>
<div id="cell-8" class="cell" data-execution_count="18">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.linear_model <span class="im">import</span> Ridge</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> PolynomialFeatures</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.pipeline <span class="im">import</span> make_pipeline</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a noisy sine wave (increased noise)</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> real_func(x):</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.sin(x) <span class="op">+</span> np.random.normal(<span class="dv">0</span>, <span class="fl">0.4</span>, <span class="bu">len</span>(x))  <span class="co"># Increased noise</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Create x data (narrower range)</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.array([np.pi <span class="op">/</span> <span class="dv">180</span> <span class="op">*</span> i <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">40</span>, <span class="dv">280</span>, <span class="dv">8</span>)])  <span class="co"># Narrower range, larger step</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> real_func(x)</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Degree of the polynomial</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>deg <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a><span class="co"># List of alpha values to compare (adjusted)</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>alpha_list <span class="op">=</span> [<span class="fl">0.0</span>, <span class="fl">0.1</span>, <span class="dv">10</span>]  <span class="co"># Adjusted alpha values</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>cols <span class="op">=</span> <span class="bu">len</span>(alpha_list)</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>fig, axes_list <span class="op">=</span> plt.subplots(<span class="dv">1</span>, cols, figsize<span class="op">=</span>(<span class="dv">20</span>, <span class="dv">5</span>))  <span class="co"># Adjusted figure size</span></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, alpha <span class="kw">in</span> <span class="bu">enumerate</span>(alpha_list):</span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>    axes <span class="op">=</span> axes_list[i]</span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Plot the original data</span></span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a>    sns.scatterplot(ax<span class="op">=</span>axes, x<span class="op">=</span>x, y<span class="op">=</span>y, label<span class="op">=</span><span class="st">'real function'</span>, s<span class="op">=</span><span class="dv">50</span>)  <span class="co"># Increased marker size</span></span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Plot linear regression</span></span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a>    params <span class="op">=</span> np.polyfit(x, y, deg)</span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> np.poly1d(params)</span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a>    sns.lineplot(ax<span class="op">=</span>axes, x<span class="op">=</span>x, y<span class="op">=</span>p(x), label<span class="op">=</span><span class="ss">f"LR deg = </span><span class="sc">{</span>deg<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-37"><a href="#cb7-37" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Ridge regression (using Pipeline, solver='auto')</span></span>
<span id="cb7-38"><a href="#cb7-38" aria-hidden="true" tabindex="-1"></a>    model <span class="op">=</span> make_pipeline(PolynomialFeatures(degree<span class="op">=</span>deg), Ridge(alpha<span class="op">=</span>alpha, solver<span class="op">=</span><span class="st">'auto'</span>))</span>
<span id="cb7-39"><a href="#cb7-39" aria-hidden="true" tabindex="-1"></a>    model.fit(x.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>), y)  <span class="co"># Reshape x for pipeline</span></span>
<span id="cb7-40"><a href="#cb7-40" aria-hidden="true" tabindex="-1"></a>    y_pred <span class="op">=</span> model.predict(x.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>)) <span class="co"># Reshape x for prediction</span></span>
<span id="cb7-41"><a href="#cb7-41" aria-hidden="true" tabindex="-1"></a>    sns.lineplot(ax<span class="op">=</span>axes, x<span class="op">=</span>x, y<span class="op">=</span>y_pred, label<span class="op">=</span><span class="ss">f"Ridge alpha=</span><span class="sc">{</span>alpha<span class="sc">:0.1e}</span><span class="ss"> deg=</span><span class="sc">{</span>deg<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb7-42"><a href="#cb7-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-43"><a href="#cb7-43" aria-hidden="true" tabindex="-1"></a>    axes.set_title(<span class="ss">f"Alpha = </span><span class="sc">{</span>alpha<span class="sc">:0.1e}</span><span class="ss">"</span>)</span>
<span id="cb7-44"><a href="#cb7-44" aria-hidden="true" tabindex="-1"></a>    axes.set_ylim(<span class="op">-</span><span class="fl">1.5</span>, <span class="fl">1.5</span>)  <span class="co"># Limit y-axis range</span></span>
<span id="cb7-45"><a href="#cb7-45" aria-hidden="true" tabindex="-1"></a>    axes.legend()</span>
<span id="cb7-46"><a href="#cb7-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-47"><a href="#cb7-47" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb7-48"><a href="#cb7-48" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="06_과적합과 해결 기법의 발전_files/figure-html/cell-5-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>위 그래프는 10차 다항식을 사용하여 노이즈가 추가된 사인 함수 데이터에 피팅한 결과로, 각기 다른 <code>alpha</code> 값(규제 강도)을 사용한 Ridge 회귀 결과를 보여줍니다. 데이터 범위가 좁고 노이즈가 많아 낮은 차수에서도 과적합이 쉽게 발생합니다.</p>
<ul>
<li><strong>Alpha = 0.0:</strong> Ridge 회귀는 일반 최소 제곱 선형 회귀와 같아지며, 10차 다항식은 훈련 데이터 노이즈까지 따라가 심하게 굴곡진 과적합 형태를 보입니다.</li>
<li><strong>Alpha = 0.1:</strong> 약한 규제가 적용되어 <code>alpha=0</code>일 때보다 굴곡은 줄었지만, 여전히 노이즈에 민감하여 사인 함수와는 거리가 있습니다.</li>
<li><strong>Alpha = 10:</strong> 강한 규제로 곡선이 훨씬 부드러워져, 데이터의 전반적인 추세(사인 함수)를 잘 나타냅니다. 이는 L2 규제(Ridge 회귀)가 과적합을 효과적으로 제어함을 보여줍니다.</li>
</ul>
<p>적절한 <code>alpha</code> 값 선택으로 모델 복잡도를 제어하고 일반화 성능을 높일 수 있습니다. L2 규제는 가중치를 0에 가깝게 만들어 모델을 안정화하는 데 유용합니다.</p>
<p><code>sklearn.linear_model.Ridge</code> 모델은 <code>solver</code>에 따라 최적화 방법이 달라질 수 있습니다. 특히 이 예제처럼 데이터 범위가 좁고 노이즈가 많으면 <code>'svd'</code>나 <code>'cholesky'</code> solver가 더 안정적일 수 있어, <code>solver</code> 선택에 주의해야 합니다 (코드에서는 <code>'cholesky'</code> 지정).</p>
</section>
<section id="파이토치에서-l1-l2-규제-적용" class="level3">
<h3 class="anchored" data-anchor-id="파이토치에서-l1-l2-규제-적용">6.2.2 파이토치에서 L1, L2 규제 적용</h3>
<p>파이토치와 케라스는 L1, L2 규제를 구현하는 방식에 차이가 있습니다. 케라스는 각 층(layer)에 규제 항을 직접 추가하는 방식(<code>kernel_regularizer</code>, <code>bias_regularizer</code>)을 지원합니다.</p>
<div id="cell-10" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># In Keras, you can specify regularization when declaring a layer.</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>keras.layers.Dense(<span class="dv">64</span>, activation<span class="op">=</span><span class="st">'relu'</span>,</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>                    kernel_regularizer<span class="op">=</span>regularizers.l2(<span class="fl">0.01</span>),</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>                    input_shape<span class="op">=</span>(<span class="dv">784</span>,))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>반면, 파이토치는 옵티마이저(optimizer)에 가중치 감쇠(weight decay)를 설정하는 방식으로 L2 규제를 적용하며, L1 규제는 일반적으로 사용자 정의 손실 함수를 통해 구현합니다.</p>
<div id="cell-12" class="cell" data-execution_count="5">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.nn <span class="im">as</span> nn</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> custom_loss(outputs, targets, model, lambda_l1<span class="op">=</span><span class="fl">0.01</span>, lambda_l2<span class="op">=</span><span class="fl">0.01</span>,):</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    mse_loss <span class="op">=</span> nn.MSELoss()(outputs, targets)</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    l1_loss <span class="op">=</span> <span class="fl">0.</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    l2_loss <span class="op">=</span> <span class="fl">0.</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> param <span class="kw">in</span> model.parameters():</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>        l1_loss <span class="op">+=</span> torch.<span class="bu">sum</span>(torch.<span class="bu">abs</span>(param)) <span class="co"># Take the absolute value of the parameters.</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>        l2_loss <span class="op">+=</span> torch.<span class="bu">sum</span>(param <span class="op">**</span> <span class="dv">2</span>)  <span class="co"># Square the parameters.</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    total_loss <span class="op">=</span> mse_loss <span class="op">+</span> lambda_l1 <span class="op">*</span> l1_loss <span class="op">+</span> lambda_l2 <span class="op">*</span> l2_loss <span class="co"># Add L1 and L2 penalty terms to the loss.</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> total_loss</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage within a training loop (not runnable as is)</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a><span class="co"># for inputs, targets in dataloader:</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a><span class="co">#     # ... (rest of the training loop)</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a><span class="co">#     loss = custom_loss(outputs, targets, model)</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a><span class="co">#     loss.backward()</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ... (rest of the training loop)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>위 예제처럼 custom_loss 함수를 정의하여 L1, L2 규제를 모두 적용할 수 있습니다. 하지만 대개는 L2 규제에 해당하는 weight_decay를 옵티마이저에 설정하여 사용합니다. 그런데 Adam, SGD 옵티마이저에서는 가중치 감쇠를 L2 규제와는 약간 다르게 구현합니다. 전통적인 L2 규제는 손실 함수에 파라미터 제곱 항을 더하는 방식입니다.</p>
<p><span class="math inline">\(L_{n+1} = L_{n} + \frac{ \lambda }{2} \sum w^2\)</span></p>
<p>이를 파라미터에 대해 미분하면 다음과 같습니다.</p>
<p><span class="math inline">\(\frac{\partial L_{n+1}}{\partial w} = \frac{\partial L_{n}}{\partial w} +\lambda w\)</span></p>
<p>SGD와 Adam은 이 식에서 <span class="math inline">\(\lambda w\)</span> 항을 직접 기울기에 더하는 방식으로 구현되었습니다. chapter_05/optimizers/ SGD 코드는 다음과 같습니다.</p>
<div id="cell-14" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="va">self</span>.weight_decay <span class="op">!=</span> <span class="dv">0</span>:</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    grad <span class="op">=</span> grad.add(p, alpha<span class="op">=</span><span class="va">self</span>.weight_decay)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>이 방식은 모멘텀(momentum)이나 적응적 학습률(adaptive learning rate)과 결합될 때, 손실 함수에 L2 규제 항을 추가하는 것과 정확히 동일한 효과를 내지 않습니다.</p>
<p><strong>AdamW와 가중치 감쇠의 분리 (Decoupled Weight Decay)</strong></p>
<p>2017년 ICLR에 발표된 “Fixing Weight Decay Regularization in Adam” 논문(https://arxiv.org/abs/1711.05101)에서는 Adam 옵티마이저에서 가중치 감쇠가 L2 규제와 다르게 동작하는 문제를 지적하고, 이를 수정한 AdamW 옵티마이저를 제안했습니다. AdamW에서는 가중치 감쇠를 기울기 업데이트와 분리하여 파라미터 업데이트 단계에서 직접 적용합니다. 코드는 동일한 basic.py에 있습니다.</p>
<div id="cell-16" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># PyTorch AdamW weght decay</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> weight_decay <span class="op">!=</span> <span class="dv">0</span>:</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    param.data.mul_(<span class="dv">1</span> <span class="op">-</span> lr <span class="op">*</span> weight_decay)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>AdamW는 파라미터값에 1 - lr * weight_decay를 곱합니다.</p>
<ul>
<li><strong>기존 Adam의 가중치 감쇠</strong>: 기울기 업데이트 단계에서 가중치 감쇠 항 (<span class="math inline">\(\lambda w\)</span>)이 학습률(<span class="math inline">\(lr\)</span>) 및 다른 기울기 조정 항(예: 모멘텀)과 함께 고려됩니다. 이로 인해 가중치 감쇠의 효과가 학습률 및 다른 하이퍼파라미터 설정에 따라 달라질 수 있습니다.</li>
<li><strong>AdamW의 가중치 감쇠</strong>: 가중치 감쇠가 파라미터 업데이트 단계에서 별도로 적용되므로, 학습률이나 다른 하이퍼파라미터에 덜 의존적입니다. 즉, 가중치 감쇠의 효과가 더 예측 가능하고 일관됩니다.</li>
</ul>
<p>결론적으로, AdamW의 방식이 더 정확한 L2 규제 구현에 가깝습니다. SGD, Adam의 가중치 감쇠를 L2 규제라고 부르는 것은 역사적인 이유와 유사한 효과 때문이지만, 엄밀하게는 별도의 규제 기법으로 보는 것이 더 정확하며, AdamW는 이러한 차이를 명확히 하여 더 나은 성능을 제공합니다.</p>
</section>
<section id="손실-평면에서의-규제효과-분석" class="level3">
<h3 class="anchored">6.2.3 손실 평면에서의 규제효과 분석</h3>
<p>L1과 L2 규제가 모델의 학습에 미치는 영향을 시각적으로 이해하기 위해, 4장에서 소개했던 손실 평면(loss surface) 시각화 기법을 활용해 보겠습니다. 규제가 없는 경우와 L2 규제를 적용한 경우의 손실 평면 변화를 비교하고, 규제 강도(<code>weight_decay</code>)에 따른 최적해의 위치 변화를 관찰합니다.</p>
<div id="cell-19" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> sys</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_05.visualization.loss_surface <span class="im">import</span> xy_perturb_loss,  hessian_eigenvectors, visualize_loss_surface </span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_04.utils.data <span class="im">import</span> get_dataset, get_device   </span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_04.utils.metrics <span class="im">import</span> load_model  </span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.nn <span class="im">as</span> nn</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.utils.data <span class="im">as</span> data_utils</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> torch.utils.data <span class="im">import</span>  DataLoader</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>device <span class="op">=</span> get_device()  <span class="co"># Get the device (CPU or CUDA)</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>train_dataset, test_dataset <span class="op">=</span> get_dataset()  <span class="co"># Load the datasets.  </span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>act_name <span class="op">=</span> <span class="st">"ReLU"</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>model_file <span class="op">=</span> <span class="ss">f"SimpleNetwork-</span><span class="sc">{</span>act_name<span class="sc">}</span><span class="ss">.pth"</span></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>small_dataset <span class="op">=</span> data_utils.Subset(test_dataset, torch.arange(<span class="dv">0</span>, <span class="dv">256</span>))  <span class="co"># Use a subset of the test dataset</span></span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>data_loader <span class="op">=</span> DataLoader(small_dataset, batch_size<span class="op">=</span><span class="dv">256</span>, shuffle<span class="op">=</span><span class="va">True</span>)  <span class="co"># Create a data loader</span></span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>loss_func <span class="op">=</span> nn.CrossEntropyLoss()  <span class="co"># Define the loss function</span></span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a><span class="co"># Load the trained model.</span></span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a>trained_model, _ <span class="op">=</span> load_model(model_file<span class="op">=</span>model_file, path<span class="op">=</span><span class="st">"./tmp/opts/ReLU"</span>) <span class="co"># 4장의 load_model 사용</span></span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a>trained_model <span class="op">=</span> trained_model.to(device)  <span class="co"># Move the model to the device</span></span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true" tabindex="-1"></a>top_n <span class="op">=</span> <span class="dv">2</span>  <span class="co"># Number of top eigenvalues/eigenvectors to compute</span></span>
<span id="cb12-29"><a href="#cb12-29" aria-hidden="true" tabindex="-1"></a>top_eigenvalues, top_eigenvectors <span class="op">=</span>  hessian_eigenvectors(model<span class="op">=</span>trained_model, loss_func<span class="op">=</span>loss_func, data_loader<span class="op">=</span>data_loader, top_n<span class="op">=</span>top_n, is_cuda<span class="op">=</span><span class="va">True</span>)  <span class="co"># 5장의 함수 사용</span></span>
<span id="cb12-30"><a href="#cb12-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-31"><a href="#cb12-31" aria-hidden="true" tabindex="-1"></a>d_min ,d_max, d_num <span class="op">=</span> <span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">50</span>  <span class="co"># Define the range and number of points for the grid</span></span>
<span id="cb12-32"><a href="#cb12-32" aria-hidden="true" tabindex="-1"></a>lambda1, lambda2 <span class="op">=</span> np.linspace(d_min, d_max, d_num).astype(np.float32), np.linspace(d_min, d_max, d_num).astype(np.float32)  <span class="co"># Create the grid of lambda values</span></span>
<span id="cb12-33"><a href="#cb12-33" aria-hidden="true" tabindex="-1"></a>x, y, z <span class="op">=</span> xy_perturb_loss(model<span class="op">=</span>trained_model, top_eigenvectors<span class="op">=</span>top_eigenvectors, data_loader<span class="op">=</span>data_loader, loss_func<span class="op">=</span>loss_func, lambda1<span class="op">=</span>lambda1, lambda2<span class="op">=</span>lambda2, device<span class="op">=</span>device) <span class="co"># 5장의 함수 사용</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p><code>xy_perturb_loss</code>로 근사 함수를 만든 다음, 그 근사함수에 다시 (x,y)를 넣어 새롭게 z 값을 구합니다. 이렇게 하는 이유는 5장에서 처럼 <code>xy_perturb_loss</code>로 구한 값으로 등고선을 그리면 최소값이 조금 달라서 옵티마이저가 수렴하는 포인트가 조금 벗어나기 때문입니다. 이제 옵티마이저가 흘러가는 경로는 모두 표현하지 않고 가장 마지막 최저점만을 감쇠값인 weight_decay 값을 증가시켜가며 비교해 봅니다.</p>
<div id="cell-21" class="cell" data-execution_count="8">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.nn <span class="im">as</span> nn</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.optim <span class="im">as</span> optim  <span class="co"># Import optim</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> torch.utils.data <span class="im">import</span> DataLoader, Subset</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="co"># 5장, 4장 함수들 import</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_05.visualization.loss_surface <span class="im">import</span> (</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>    hessian_eigenvectors,</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>    xy_perturb_loss,</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>    visualize_loss_surface</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_04.utils.data <span class="im">import</span> get_dataset, get_device</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_04.utils.metrics <span class="im">import</span> load_model</span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_05.visualization.gaussian_loss_surface <span class="im">import</span> (</span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>    get_opt_params,</span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>    train_loss_surface,</span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>    gaussian_func <span class="co"># gaussian_func 추가.</span></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a>device <span class="op">=</span> get_device()</span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a>_, test_dataset <span class="op">=</span> get_dataset(dataset<span class="op">=</span><span class="st">"FashionMNIST"</span>) </span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a>small_dataset <span class="op">=</span> Subset(test_dataset, torch.arange(<span class="dv">0</span>, <span class="dv">256</span>))</span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a>data_loader <span class="op">=</span> DataLoader(small_dataset, batch_size<span class="op">=</span><span class="dv">256</span>, shuffle<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true" tabindex="-1"></a>loss_func <span class="op">=</span> nn.CrossEntropyLoss()</span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true" tabindex="-1"></a>act_name <span class="op">=</span> <span class="st">"ReLU"</span> <span class="co"># Tanh로 실험하려면 이 부분을 변경</span></span>
<span id="cb13-30"><a href="#cb13-30" aria-hidden="true" tabindex="-1"></a>model_file <span class="op">=</span> <span class="ss">f"SimpleNetwork-</span><span class="sc">{</span>act_name<span class="sc">}</span><span class="ss">.pth"</span></span>
<span id="cb13-31"><a href="#cb13-31" aria-hidden="true" tabindex="-1"></a>trained_model, _ <span class="op">=</span> load_model(model_file<span class="op">=</span>model_file, path<span class="op">=</span><span class="st">"./tmp/opts/ReLU"</span>) </span>
<span id="cb13-32"><a href="#cb13-32" aria-hidden="true" tabindex="-1"></a>trained_model <span class="op">=</span> trained_model.to(device)</span>
<span id="cb13-33"><a href="#cb13-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-34"><a href="#cb13-34" aria-hidden="true" tabindex="-1"></a>top_n <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb13-35"><a href="#cb13-35" aria-hidden="true" tabindex="-1"></a>top_eigenvalues, top_eigenvectors <span class="op">=</span> hessian_eigenvectors(</span>
<span id="cb13-36"><a href="#cb13-36" aria-hidden="true" tabindex="-1"></a>    model<span class="op">=</span>trained_model,</span>
<span id="cb13-37"><a href="#cb13-37" aria-hidden="true" tabindex="-1"></a>    loss_func<span class="op">=</span>loss_func,</span>
<span id="cb13-38"><a href="#cb13-38" aria-hidden="true" tabindex="-1"></a>    data_loader<span class="op">=</span>data_loader,</span>
<span id="cb13-39"><a href="#cb13-39" aria-hidden="true" tabindex="-1"></a>    top_n<span class="op">=</span>top_n,</span>
<span id="cb13-40"><a href="#cb13-40" aria-hidden="true" tabindex="-1"></a>    is_cuda<span class="op">=</span><span class="va">True</span></span>
<span id="cb13-41"><a href="#cb13-41" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb13-42"><a href="#cb13-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-43"><a href="#cb13-43" aria-hidden="true" tabindex="-1"></a>d_min, d_max, d_num <span class="op">=</span> <span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">30</span> <span class="co"># 5장의 30을 사용</span></span>
<span id="cb13-44"><a href="#cb13-44" aria-hidden="true" tabindex="-1"></a>lambda1 <span class="op">=</span> np.linspace(d_min, d_max, d_num).astype(np.float32)</span>
<span id="cb13-45"><a href="#cb13-45" aria-hidden="true" tabindex="-1"></a>lambda2 <span class="op">=</span> np.linspace(d_min, d_max, d_num).astype(np.float32)</span>
<span id="cb13-46"><a href="#cb13-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-47"><a href="#cb13-47" aria-hidden="true" tabindex="-1"></a>x, y, z <span class="op">=</span> xy_perturb_loss(</span>
<span id="cb13-48"><a href="#cb13-48" aria-hidden="true" tabindex="-1"></a>    model<span class="op">=</span>trained_model,</span>
<span id="cb13-49"><a href="#cb13-49" aria-hidden="true" tabindex="-1"></a>    top_eigenvectors<span class="op">=</span>top_eigenvectors,</span>
<span id="cb13-50"><a href="#cb13-50" aria-hidden="true" tabindex="-1"></a>    data_loader<span class="op">=</span>data_loader,</span>
<span id="cb13-51"><a href="#cb13-51" aria-hidden="true" tabindex="-1"></a>    loss_func<span class="op">=</span>loss_func,</span>
<span id="cb13-52"><a href="#cb13-52" aria-hidden="true" tabindex="-1"></a>    lambda1<span class="op">=</span>lambda1,</span>
<span id="cb13-53"><a href="#cb13-53" aria-hidden="true" tabindex="-1"></a>    lambda2<span class="op">=</span>lambda2,</span>
<span id="cb13-54"><a href="#cb13-54" aria-hidden="true" tabindex="-1"></a>    device<span class="op">=</span>device <span class="co"># device 추가</span></span>
<span id="cb13-55"><a href="#cb13-55" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb13-56"><a href="#cb13-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-57"><a href="#cb13-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-58"><a href="#cb13-58" aria-hidden="true" tabindex="-1"></a><span class="co"># --- Optimization and Visualization ---</span></span>
<span id="cb13-59"><a href="#cb13-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-60"><a href="#cb13-60" aria-hidden="true" tabindex="-1"></a><span class="co"># Find the parameters that best fit the data.</span></span>
<span id="cb13-61"><a href="#cb13-61" aria-hidden="true" tabindex="-1"></a>popt, _, offset <span class="op">=</span> get_opt_params(x, y, z)  <span class="co"># offset 사용</span></span>
<span id="cb13-62"><a href="#cb13-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-63"><a href="#cb13-63" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Optimal parameters: </span><span class="sc">{</span>popt<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb13-64"><a href="#cb13-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-65"><a href="#cb13-65" aria-hidden="true" tabindex="-1"></a><span class="co"># Get a new z using the optimized surface function (Gaussian).</span></span>
<span id="cb13-66"><a href="#cb13-66" aria-hidden="true" tabindex="-1"></a><span class="co"># No need for global g_offset, we can use the returned offset.</span></span>
<span id="cb13-67"><a href="#cb13-67" aria-hidden="true" tabindex="-1"></a>z_fitted <span class="op">=</span> gaussian_func((x, y), <span class="op">*</span>popt,offset) <span class="co"># offset을 더해야 함.</span></span>
<span id="cb13-68"><a href="#cb13-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-69"><a href="#cb13-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-70"><a href="#cb13-70" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> [(x, y, z_fitted)]  <span class="co"># Use z_fitted</span></span>
<span id="cb13-71"><a href="#cb13-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-72"><a href="#cb13-72" aria-hidden="true" tabindex="-1"></a>axes <span class="op">=</span> visualize_loss_surface(data, act_name<span class="op">=</span>act_name, color<span class="op">=</span><span class="st">"C0"</span>, size<span class="op">=</span><span class="dv">6</span>, levels<span class="op">=</span><span class="dv">80</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, plot_3d<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb13-73"><a href="#cb13-73" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> axes[<span class="dv">0</span>]</span>
<span id="cb13-74"><a href="#cb13-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-75"><a href="#cb13-75" aria-hidden="true" tabindex="-1"></a><span class="co"># Train with different weight decays and plot trajectories.</span></span>
<span id="cb13-76"><a href="#cb13-76" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> n, weight_decay <span class="kw">in</span> <span class="bu">enumerate</span>([<span class="fl">0.0</span>, <span class="fl">6.0</span>, <span class="fl">10.0</span>, <span class="fl">18.0</span>, <span class="fl">20.0</span>]):</span>
<span id="cb13-77"><a href="#cb13-77" aria-hidden="true" tabindex="-1"></a><span class="co"># for n, weight_decay in enumerate([0.0]):  # For faster testing</span></span>
<span id="cb13-78"><a href="#cb13-78" aria-hidden="true" tabindex="-1"></a>    points_sgd_m <span class="op">=</span> train_loss_surface(</span>
<span id="cb13-79"><a href="#cb13-79" aria-hidden="true" tabindex="-1"></a>        <span class="kw">lambda</span> params: optim.SGD(params, lr<span class="op">=</span><span class="fl">0.1</span>, momentum<span class="op">=</span><span class="fl">0.7</span>, weight_decay<span class="op">=</span>weight_decay),</span>
<span id="cb13-80"><a href="#cb13-80" aria-hidden="true" tabindex="-1"></a>        [d_min, d_max],</span>
<span id="cb13-81"><a href="#cb13-81" aria-hidden="true" tabindex="-1"></a>        <span class="dv">200</span>,</span>
<span id="cb13-82"><a href="#cb13-82" aria-hidden="true" tabindex="-1"></a>        (<span class="op">*</span>popt, offset) <span class="co"># unpack popt and offset</span></span>
<span id="cb13-83"><a href="#cb13-83" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb13-84"><a href="#cb13-84" aria-hidden="true" tabindex="-1"></a>    ax.plot(</span>
<span id="cb13-85"><a href="#cb13-85" aria-hidden="true" tabindex="-1"></a>        points_sgd_m[<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>],</span>
<span id="cb13-86"><a href="#cb13-86" aria-hidden="true" tabindex="-1"></a>        points_sgd_m[<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>],</span>
<span id="cb13-87"><a href="#cb13-87" aria-hidden="true" tabindex="-1"></a>        color<span class="op">=</span><span class="ss">f"C</span><span class="sc">{</span>n<span class="sc">}</span><span class="ss">"</span>,</span>
<span id="cb13-88"><a href="#cb13-88" aria-hidden="true" tabindex="-1"></a>        marker<span class="op">=</span><span class="st">"o"</span>,</span>
<span id="cb13-89"><a href="#cb13-89" aria-hidden="true" tabindex="-1"></a>        markersize<span class="op">=</span><span class="dv">10</span>,</span>
<span id="cb13-90"><a href="#cb13-90" aria-hidden="true" tabindex="-1"></a>        zorder<span class="op">=</span><span class="dv">2</span>,</span>
<span id="cb13-91"><a href="#cb13-91" aria-hidden="true" tabindex="-1"></a>        label<span class="op">=</span><span class="ss">f"wd=</span><span class="sc">{</span>weight_decay<span class="sc">:0.1f}</span><span class="ss">"</span></span>
<span id="cb13-92"><a href="#cb13-92" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb13-93"><a href="#cb13-93" aria-hidden="true" tabindex="-1"></a>    ax.ticklabel_format(axis<span class="op">=</span><span class="st">'both'</span>, style<span class="op">=</span><span class="st">'scientific'</span>, scilimits<span class="op">=</span>(<span class="dv">0</span>, <span class="dv">0</span>))</span>
<span id="cb13-94"><a href="#cb13-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-95"><a href="#cb13-95" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb13-96"><a href="#cb13-96" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Function parameters = [ 4.59165436  0.34582255 -0.03204057 -1.09810435  1.54530407]
Optimal parameters: [ 4.59165436  0.34582255 -0.03204057 -1.09810435  1.54530407]

train_loss_surface: SGD
SGD: Iter=1 loss=4.7671 w=[-0.8065, 0.9251]
SGD: Iter=200 loss=1.9090 w=[0.3458, -0.0320]

train_loss_surface: SGD
SGD: Iter=1 loss=4.7671 w=[-0.2065, 0.3251]
SGD: Iter=200 loss=1.9952 w=[0.1327, -0.0077]

train_loss_surface: SGD
SGD: Iter=1 loss=4.7671 w=[0.1935, -0.0749]
SGD: Iter=200 loss=2.0293 w=[0.0935, -0.0051]

train_loss_surface: SGD
SGD: Iter=1 loss=4.7671 w=[0.9935, -0.8749]
SGD: Iter=200 loss=2.0641 w=[0.0587, -0.0030]

train_loss_surface: SGD
SGD: Iter=1 loss=4.7671 w=[1.1935, -1.0749]
SGD: Iter=200 loss=2.0694 w=[0.0537, -0.0027]</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="06_과적합과 해결 기법의 발전_files/figure-html/cell-11-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>그림에서 볼 수 있듯이, L2 규제(weight decay)가 클수록 옵티마이저가 도달한 최종 지점이 손실 함수의 최저점에서 멀어지는 것을 확인할 수 있습니다. 이는 L2 규제가 가중치가 너무 커지는 것을 방지하여 모델이 과적합되지 않도록 도와주기 때문입니다.</p>
<p>L1 규제는 일부 가중치를 0으로 만들어 희소 모델(sparse model)을 생성합니다. 모델의 복잡도를 낮추고 불필요한 특성을 제거하고 싶을 때 유용합니다. 반면, L2 규제는 가중치를 완전히 0으로 만들지는 않고, 모든 가중치를 작게 유지합니다. L2 규제는 일반적으로 더 안정적인 수렴을 보이며, 가중치를 점차적으로 줄여나가기 때문에 ’부드러운 규제’라고도 합니다.</p>
<p>L1 규제와 L2 규제는 문제의 특성, 데이터, 모델의 목적에 따라 다르게 적용됩니다. 일반적으로 L2 규제가 더 널리 사용되지만, 경우에 따라 두 가지 규제를 모두 시도해보고, 어떤 것이 더 나은 성능을 보이는지 확인하는 것이 좋습니다. 또한, L1 규제와 L2 규제를 결합한 Elastic Net 규제도 고려해볼 수 있습니다.</p>
<div class="callout callout-style-default callout-note callout-titled" title="클릭하여 내용 보기 (딥 다이브 : Elastic Net 규제 - L1과 L2의 조화)">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-1-contents" aria-controls="callout-1" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
클릭하여 내용 보기 (딥 다이브 : Elastic Net 규제 - L1과 L2의 조화)
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-1" class="callout-1-contents callout-collapse collapse">
<section id="elastic-net-규제---l1과-l2의-조화" class="level2 callout-body-container callout-body">
<h2 class="anchored" data-anchor-id="elastic-net-규제---l1과-l2의-조화">Elastic Net 규제 - L1과 L2의 조화</h2>
<p>Elastic Net은 L1 규제와 L2 규제를 결합한 정규화 방법입니다. 각 규제의 장점을 취하고 단점을 보완하여, 더 유연하고 효과적인 모델을 만들 수 있습니다.</p>
<p><strong>핵심:</strong></p>
<ul>
<li><strong>L1 규제 (Lasso):</strong> 가중치의 절대값 합을 제한합니다. 일부 가중치를 <em>정확히 0으로</em> 만들어 희소한(sparse) 모델을 생성합니다. 특성 선택(feature selection) 효과가 있어, 불필요한 특성을 제거하고 모델을 단순화합니다.</li>
<li><strong>L2 규제 (Ridge):</strong> 가중치의 제곱 합을 제한합니다. 모든 가중치를 <em>작게</em> 유지하여 모델의 과적합(overfitting)을 방지합니다. 수렴이 안정적이고 부드럽게 가중치를 줄입니다.</li>
<li><strong>Elastic Net:</strong> L1 규제와 L2 규제를 <em>동시에</em> 적용합니다. 두 규제의 효과를 모두 얻을 수 있습니다.</li>
</ul>
<p><strong>수식:</strong></p>
<p>Elastic Net의 비용 함수는 다음과 같이 표현됩니다.</p>
<p><span class="math inline">\(Cost = Loss + \lambda_1 \sum_{i} |w_i| + \lambda_2 \sum_{i} (w_i)^2\)</span></p>
<ul>
<li><code>Loss</code>: 원래 모델의 손실 함수 (예: MSE, Cross-Entropy)</li>
<li><code>λ₁</code>: L1 규제의 강도를 조절하는 하이퍼파라미터</li>
<li><code>λ₂</code>: L2 규제의 강도를 조절하는 하이퍼파라미터</li>
<li><code>wᵢ</code>: 모델의 가중치</li>
</ul>
<p><strong>장점:</strong></p>
<ul>
<li><strong>특성 선택 + 과적합 방지:</strong> L1 규제의 특성 선택 효과와 L2 규제의 과적합 방지 효과를 모두 얻을 수 있습니다.</li>
<li><strong>상관관계가 높은 특성 처리:</strong> L1 규제는 상관관계가 높은 특성 중 하나만 선택하고 나머지는 0으로 만드는 경향이 있습니다. Elastic Net은 L2 규제를 통해 이러한 문제를 완화하여, 상관관계가 높은 특성들을 <em>함께</em> 선택하거나 <em>함께</em> 제거하는 경향을 보입니다.</li>
<li><strong>유연성:</strong> <code>λ₁</code>과 <code>λ₂</code>를 조절하여 L1 규제와 L2 규제의 비중을 조절할 수 있습니다. <code>λ₁=0</code>이면 L2 규제(Ridge), <code>λ₂=0</code>이면 L1 규제(Lasso)가 됩니다.</li>
</ul>
<p><strong>단점:</strong></p>
<ul>
<li><strong>하이퍼파라미터 튜닝:</strong> <code>λ₁</code>과 <code>λ₂</code> 두 개의 하이퍼파라미터를 튜닝해야 하므로, L1이나 L2 규제보다 튜닝이 더 복잡할 수 있습니다.</li>
<li><strong>계산 비용:</strong> L1, L2를 동시에 계산해야 하므로, 계산 비용이 약간 더 증가할 수 있습니다(현대 머신러닝에서는 큰 문제는 아님).</li>
</ul>
<p><strong>적용하는 경우</strong></p>
<ul>
<li>특성(feature)이 많고, 그 중 일부만 중요할 것으로 예상될 때 (특성 선택이 필요할 때)</li>
<li>특성 간에 상관관계가 높을 때</li>
<li>L1 규제와 L2 규제 중 어떤 것이 더 좋을지 불확실할 때 (두 가지를 모두 시도해보고 싶을 때)</li>
<li>과적합을 방지하면서도, 어느 정도 희소한 모델을 만들고 싶을 때</li>
</ul>
<p><strong>요약:</strong> Elastic Net은 L1과 L2의 장점을 결합한 강력한 규제 방법입니다. 하이퍼파라미터 튜닝이 필요하지만, 다양한 문제에서 좋은 성능을 보일 수 있습니다.</p>
</section>
</div>
</div>
</section>
</section>
<section id="드롭아웃dropout" class="level2">
<h2 class="anchored" data-anchor-id="드롭아웃dropout">6.3 드롭아웃(Dropout)</h2>
<section id="드롭아웃의-원리" class="level3">
<h3 class="anchored" data-anchor-id="드롭아웃의-원리">6.3.1 드롭아웃의 원리</h3>
<p>드롭아웃은 신경망에서 과적합을 방지하는 강력한 규제 방법 중 하나입니다. 학습 과정에서 무작위로 일부 뉴런을 비활성화(dropout)하여, 특정 뉴런이나 뉴런 간의 조합이 학습 데이터에 과도하게 의존하는 것을 방지합니다. 이는 마치 여러 사람이 각자 다른 부분을 학습한 후 힘을 합쳐 문제를 해결하는 앙상블 학습과 유사한 효과를 냅니다. 각 뉴런이 독립적으로 중요한 특징을 학습하도록 유도하여, 모델의 일반화 성능을 향상시킵니다. 일반적으로 완전연결층(fully connected layer)에 적용되며, 비활성화 비율은 20%에서 50% 사이로 설정됩니다. 드롭아웃은 학습 시에만 적용되고, 추론(inference) 시에는 모든 뉴런을 사용합니다.</p>
</section>
<section id="파이토치에서-드롭아웃의-구현" class="level3">
<h3 class="anchored" data-anchor-id="파이토치에서-드롭아웃의-구현">6.3.2 파이토치에서 드롭아웃의 구현</h3>
<p>파이토치에서 드롭아웃은 다음과 같이 간단하게 구현할 수 있습니다.</p>
<div id="cell-25" class="cell" data-execution_count="9">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.nn <span class="im">as</span> nn</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Dropout(nn.Module):</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, dropout_rate):</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>(Dropout, <span class="va">self</span>).<span class="fu">__init__</span>()</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.dropout_rate <span class="op">=</span> dropout_rate</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, x):</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.training:</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>            mask <span class="op">=</span> torch.bernoulli(torch.ones_like(x) <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> <span class="va">self</span>.dropout_rate)) <span class="op">/</span> (<span class="dv">1</span> <span class="op">-</span> <span class="va">self</span>.dropout_rate)</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> x <span class="op">*</span> mask</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> x</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Usage example.  Drops out 0.5 (50%).</span></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>dropout <span class="op">=</span> Dropout(dropout_rate<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Example input data</span></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>inputs <span class="op">=</span> torch.randn(<span class="dv">1000</span>, <span class="dv">100</span>)</span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Forward pass (during training)</span></span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a>dropout.train()</span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a>outputs_train <span class="op">=</span> dropout(inputs)</span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a><span class="co"># Forward pass (during inference)</span></span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a>dropout.<span class="bu">eval</span>()</span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true" tabindex="-1"></a>outputs_test <span class="op">=</span> dropout(inputs)</span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-29"><a href="#cb15-29" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Input shape:"</span>, inputs.shape)</span>
<span id="cb15-30"><a href="#cb15-30" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Training output shape:"</span>, outputs_train.shape)</span>
<span id="cb15-31"><a href="#cb15-31" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Test output shape"</span>, outputs_test.shape)</span>
<span id="cb15-32"><a href="#cb15-32" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Dropout rate (should be close to 0.5):"</span>, <span class="dv">1</span> <span class="op">-</span> torch.count_nonzero(outputs_train) <span class="op">/</span> outputs_train.numel())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Input shape: torch.Size([1000, 100])
Training output shape: torch.Size([1000, 100])
Test output shape torch.Size([1000, 100])
Dropout rate (should be close to 0.5): tensor(0.4997)</code></pre>
</div>
</div>
<p>구현은 매우 간단합니다. <code>mask</code> 값을 입력 텐서에 곱하여 일정 비율의 뉴런을 비활성화합니다. 드롭아웃 층은 별도의 학습 가능한 파라미터를 가지지 않으며, 단순히 입력의 일부를 무작위로 0으로 만드는 역할을 합니다. 실제 신경망에서는 드롭아웃 층을 다른 층들 (예: 선형 층, 합성곱 층) 사이에 삽입하여 사용합니다. 드롭아웃은 훈련 시에는 무작위로 뉴런을 제거하지만, 추론 시에는 모든 뉴런을 사용합니다. 이때, 훈련 시와 추론 시의 출력 값의 스케일을 맞추기 위해, <em>inverted dropout</em> 방식을 사용합니다. Inverted dropout은 훈련 시에 (1 - dropout_rate)로 나누어 스케일링을 미리 수행함으로써, 추론 시에는 별도의 연산 없이 그대로 사용할 수 있게 합니다. 이렇게 하면 추론 시에도 앙상블 학습과 유사한 효과를 얻을 수 있습니다. 즉, 여러 개의 부분 네트워크(sub-network)를 평균 내는 것과 같은 효과를 내면서, 동시에 계산 효율성도 높일 수 있습니다.</p>
<p>단순한 데이터를 이용해서 드롭아웃이 얼마나 효과적인지 그래프를 통해 살펴보겠습니다. 소스코드는 <code>chapter_06/plot_dropout.py</code>이며 중요하지 않은 코드라 지면상 소개는 생략합니다. 상세히 주석이 달려 있으므로 소스코드를 보는 것은 어렵지 않습니다. 그래프를 그려보면 드롭아웃을 적용한 모델(파란색)이 테스트 정확도가 훨씬 높다는 것을 알 수 있습니다.</p>
<div id="cell-27" class="cell" data-execution_count="11">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_06.plot_dropout <span class="im">import</span> plot_dropout_effect</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>plot_dropout_effect()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="06_과적합과 해결 기법의 발전_files/figure-html/cell-13-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>드롭아웃을 적용한 모델(With Dropout)의 훈련 정확도는 드롭아웃을 적용하지 않은 모델(Without Dropout)보다 낮지만, 검증 정확도는 더 높습니다. 이는 드롭아웃이 훈련 데이터에 대한 과적합을 줄이고, 모델의 일반화 성능을 향상시켰음을 의미합니다.</p>
</section>
</section>
<section id="배치-정규화batch-normalization" class="level2">
<h2 class="anchored" data-anchor-id="배치-정규화batch-normalization">6.4 배치 정규화(batch normalization)</h2>
<section id="배치정규화의-개념과-효과" class="level3">
<h3 class="anchored" data-anchor-id="배치정규화의-개념과-효과">6.4.1 배치정규화의 개념과 효과</h3>
<p>배치 정규화는 규제의 역할과 동시에 훈련 시 데이터의 안정성을 높이는 방법입니다. 배치 정규화는 2015년 Ioffe와 Szegedy의 논문 [참고 2]에서 처음 제안되었습니다. 딥러닝에서 데이터가 각 층을 통과하면서 활성화 값의 분포가 변화하는 현상(internal covariate shift)이 발생합니다. 이로 인해 훈련 속도가 느려지고 모델이 불안정해집니다 (분포가 바뀌므로 계산 스텝이 더 소요됨). 특히나 층이 많을수록 이런 문제는 심해집니다. 배치 정규화는 이를 완화하기 위해 미니 배치 단위로 데이터를 정규화합니다.</p>
<p>배치 정규화의 핵심 아이디어는 미니 배치 단위로 데이터를 정규화하는 것입니다. 다음 코드를 보면 쉽게 이해됩니다.</p>
<div id="cell-30" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate the mean and variance of the mini-batch</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>batch_mean <span class="op">=</span> x.mean(dim<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>batch_var <span class="op">=</span> x.var(dim<span class="op">=</span><span class="dv">0</span>, unbiased<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Perform normalization</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>x_norm <span class="op">=</span> (x <span class="op">-</span> batch_mean) <span class="op">/</span> torch.sqrt(batch_var <span class="op">+</span> epsilon)</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply scale and shift parameters</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> gamma <span class="op">*</span> x_norm <span class="op">+</span> beta</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>일반적으로 배치 정규화는 1개 미니 배치 안에서 데이터의 분산과 평균을 가지고 전체 데이터를 적절히 분포 변화를 가져오게 합니다. 먼저 정규화를 수행한 다음 일정한 정도의 스케일 파라미터와 이동 파라미터를 적용합니다. 위의 gamma가 스케일 파라미터이고 beta가 이동 파라미터입니다. 단순히 <span class="math inline">\(y = ax + b\)</span> 를 생각하면 편리합니다. 정규화 수행 중에 사용하는 epsilon은 수치 해석에서 흔히 나오는 아주 작은 상수값(1e-5나 1e-7)입니다. 수치적 안정성(numerical stability)을 위해 사용되는 값입니다. 배치 정규화는 다음과 같은 추가적인 효과를 제공합니다.</p>
<ul>
<li><strong>학습 속도 향상</strong>: 각 층의 활성화 값 분포를 안정화시켜 gradient vanishing/exploding 문제를 완화하고, 더 큰 학습률(learning rate)을 사용할 수 있게 해줍니다.</li>
<li><strong>초기화 의존성 감소</strong>: 가중치 초기화에 덜 민감하게 만들어, 학습을 더 쉽게 시작할 수 있습니다.</li>
<li><strong>규제 효과</strong>: 미니 배치 단위로 통계를 계산하기 때문에, 약간의 노이즈를 추가하는 효과가 있어 과적합(overfitting)을 방지하는 데 도움이 됩니다. (Dropout과 함께 사용하면 효과가 더 좋습니다.)</li>
</ul>
<p>특성이 2개가 있는 데이터를 임의로 만들고 이를 순수 정규화 적용한 경우와 스케일, 이동 파라미터를 적용한 경우를 그래프로 비교해 보겠습니다. 시각화를 통해서 미니배치에 대한 정규화가 어떤 수치적 의미를 가지는지 쉽게 이해할 수 있습니다.</p>
<div id="cell-32" class="cell" data-execution_count="21">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate data</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">42</span>)</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.random.rand(<span class="dv">50</span>, <span class="dv">2</span>) <span class="op">*</span> <span class="dv">10</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Batch normalization (including scaling parameters)</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> batch_normalize(x, epsilon<span class="op">=</span><span class="fl">1e-5</span>, gamma<span class="op">=</span><span class="fl">1.0</span>, beta<span class="op">=</span><span class="fl">0.0</span>):</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>    mean <span class="op">=</span> x.mean(axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>    var <span class="op">=</span> x.var(axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>    x_norm <span class="op">=</span> (x <span class="op">-</span> mean) <span class="op">/</span> np.sqrt(var <span class="op">+</span> epsilon)</span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>    x_scaled <span class="op">=</span> gamma <span class="op">*</span> x_norm <span class="op">+</span> beta</span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x_norm, mean, x_scaled</span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Perform normalization (gamma=1.0, beta=0.0 is pure normalization)</span></span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>x_norm, mean, x_norm_scaled <span class="op">=</span> batch_normalize(x, gamma<span class="op">=</span><span class="fl">1.0</span>, beta<span class="op">=</span><span class="fl">0.0</span>)</span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Perform normalization and scaling (apply gamma=2.0, beta=1.0)</span></span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a>_, _, x_scaled <span class="op">=</span> batch_normalize(x, gamma<span class="op">=</span><span class="fl">2.0</span>, beta<span class="op">=</span><span class="fl">1.0</span>)</span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Set Seaborn style</span></span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a>sns.set_style(<span class="st">"whitegrid"</span>)</span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a>sns.set_context(<span class="st">"notebook"</span>, font_scale<span class="op">=</span><span class="fl">1.2</span>)</span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true" tabindex="-1"></a><span class="co"># Visualization</span></span>
<span id="cb19-27"><a href="#cb19-27" aria-hidden="true" tabindex="-1"></a>fig, (ax1, ax2, ax3) <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">18</span>, <span class="dv">5</span>))</span>
<span id="cb19-28"><a href="#cb19-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-29"><a href="#cb19-29" aria-hidden="true" tabindex="-1"></a><span class="co"># Original data</span></span>
<span id="cb19-30"><a href="#cb19-30" aria-hidden="true" tabindex="-1"></a>sns.scatterplot(x<span class="op">=</span>x[:, <span class="dv">0</span>], y<span class="op">=</span>x[:, <span class="dv">1</span>], ax<span class="op">=</span>ax1, color<span class="op">=</span><span class="st">'royalblue'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb19-31"><a href="#cb19-31" aria-hidden="true" tabindex="-1"></a>ax1.scatter(mean[<span class="dv">0</span>], mean[<span class="dv">1</span>], color<span class="op">=</span><span class="st">'red'</span>, marker<span class="op">=</span><span class="st">'*'</span>, s<span class="op">=</span><span class="dv">200</span>, label<span class="op">=</span><span class="st">'Mean'</span>)</span>
<span id="cb19-32"><a href="#cb19-32" aria-hidden="true" tabindex="-1"></a>ax1.<span class="bu">set</span>(title<span class="op">=</span><span class="st">'Original Data'</span>,</span>
<span id="cb19-33"><a href="#cb19-33" aria-hidden="true" tabindex="-1"></a>        xlabel<span class="op">=</span><span class="st">'Feature 1'</span>,</span>
<span id="cb19-34"><a href="#cb19-34" aria-hidden="true" tabindex="-1"></a>        ylabel<span class="op">=</span><span class="st">'Feature 2'</span>,</span>
<span id="cb19-35"><a href="#cb19-35" aria-hidden="true" tabindex="-1"></a>        xlim<span class="op">=</span>(<span class="op">-</span><span class="dv">2</span>, <span class="dv">12</span>),</span>
<span id="cb19-36"><a href="#cb19-36" aria-hidden="true" tabindex="-1"></a>        ylim<span class="op">=</span>(<span class="op">-</span><span class="dv">2</span>, <span class="dv">12</span>))</span>
<span id="cb19-37"><a href="#cb19-37" aria-hidden="true" tabindex="-1"></a>ax1.legend()</span>
<span id="cb19-38"><a href="#cb19-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-39"><a href="#cb19-39" aria-hidden="true" tabindex="-1"></a><span class="co"># After normalization (gamma=1, beta=0)</span></span>
<span id="cb19-40"><a href="#cb19-40" aria-hidden="true" tabindex="-1"></a>sns.scatterplot(x<span class="op">=</span>x_norm[:, <span class="dv">0</span>], y<span class="op">=</span>x_norm[:, <span class="dv">1</span>], ax<span class="op">=</span>ax2, color<span class="op">=</span><span class="st">'crimson'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb19-41"><a href="#cb19-41" aria-hidden="true" tabindex="-1"></a>ax2.scatter(<span class="dv">0</span>, <span class="dv">0</span>, color<span class="op">=</span><span class="st">'blue'</span>, marker<span class="op">=</span><span class="st">'*'</span>, s<span class="op">=</span><span class="dv">200</span>, label<span class="op">=</span><span class="st">'Mean (0,0)'</span>)</span>
<span id="cb19-42"><a href="#cb19-42" aria-hidden="true" tabindex="-1"></a>ax2.axhline(y<span class="op">=</span><span class="dv">0</span>, color<span class="op">=</span><span class="st">'k'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb19-43"><a href="#cb19-43" aria-hidden="true" tabindex="-1"></a>ax2.axvline(x<span class="op">=</span><span class="dv">0</span>, color<span class="op">=</span><span class="st">'k'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb19-44"><a href="#cb19-44" aria-hidden="true" tabindex="-1"></a>ax2.<span class="bu">set</span>(title<span class="op">=</span><span class="st">'After Normalization (γ=1, β=0)'</span>,</span>
<span id="cb19-45"><a href="#cb19-45" aria-hidden="true" tabindex="-1"></a>        xlabel<span class="op">=</span><span class="st">'Normalized Feature 1'</span>,</span>
<span id="cb19-46"><a href="#cb19-46" aria-hidden="true" tabindex="-1"></a>        ylabel<span class="op">=</span><span class="st">'Normalized Feature 2'</span>,</span>
<span id="cb19-47"><a href="#cb19-47" aria-hidden="true" tabindex="-1"></a>        xlim<span class="op">=</span>(<span class="op">-</span><span class="dv">2</span>, <span class="dv">12</span>),</span>
<span id="cb19-48"><a href="#cb19-48" aria-hidden="true" tabindex="-1"></a>        ylim<span class="op">=</span>(<span class="op">-</span><span class="dv">2</span>, <span class="dv">12</span>))</span>
<span id="cb19-49"><a href="#cb19-49" aria-hidden="true" tabindex="-1"></a>ax2.legend()</span>
<span id="cb19-50"><a href="#cb19-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-51"><a href="#cb19-51" aria-hidden="true" tabindex="-1"></a><span class="co"># After scaling and shifting (gamma=2, beta=1)</span></span>
<span id="cb19-52"><a href="#cb19-52" aria-hidden="true" tabindex="-1"></a>sns.scatterplot(x<span class="op">=</span>x_scaled[:, <span class="dv">0</span>], y<span class="op">=</span>x_scaled[:, <span class="dv">1</span>], ax<span class="op">=</span>ax3, color<span class="op">=</span><span class="st">'green'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb19-53"><a href="#cb19-53" aria-hidden="true" tabindex="-1"></a>ax3.scatter(<span class="dv">1</span>, <span class="dv">1</span>, color<span class="op">=</span><span class="st">'purple'</span>, marker<span class="op">=</span><span class="st">'*'</span>, s<span class="op">=</span><span class="dv">200</span>, label<span class="op">=</span><span class="st">'New Mean'</span>)</span>
<span id="cb19-54"><a href="#cb19-54" aria-hidden="true" tabindex="-1"></a>ax3.axhline(y<span class="op">=</span><span class="dv">1</span>, color<span class="op">=</span><span class="st">'k'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb19-55"><a href="#cb19-55" aria-hidden="true" tabindex="-1"></a>ax3.axvline(x<span class="op">=</span><span class="dv">1</span>, color<span class="op">=</span><span class="st">'k'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb19-56"><a href="#cb19-56" aria-hidden="true" tabindex="-1"></a>ax3.<span class="bu">set</span>(title<span class="op">=</span><span class="st">'After Scale &amp; Shift (γ=2, β=1)'</span>,</span>
<span id="cb19-57"><a href="#cb19-57" aria-hidden="true" tabindex="-1"></a>        xlabel<span class="op">=</span><span class="st">'Scaled Feature 1'</span>,</span>
<span id="cb19-58"><a href="#cb19-58" aria-hidden="true" tabindex="-1"></a>        ylabel<span class="op">=</span><span class="st">'Scaled Feature 2'</span>,</span>
<span id="cb19-59"><a href="#cb19-59" aria-hidden="true" tabindex="-1"></a>        xlim<span class="op">=</span>(<span class="op">-</span><span class="dv">2</span>, <span class="dv">12</span>),</span>
<span id="cb19-60"><a href="#cb19-60" aria-hidden="true" tabindex="-1"></a>        ylim<span class="op">=</span>(<span class="op">-</span><span class="dv">2</span>, <span class="dv">12</span>))</span>
<span id="cb19-61"><a href="#cb19-61" aria-hidden="true" tabindex="-1"></a>ax3.legend()</span>
<span id="cb19-62"><a href="#cb19-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-63"><a href="#cb19-63" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb19-64"><a href="#cb19-64" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb19-65"><a href="#cb19-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-66"><a href="#cb19-66" aria-hidden="true" tabindex="-1"></a><span class="co"># Print statistics</span></span>
<span id="cb19-67"><a href="#cb19-67" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Original Data Statistics:"</span>)</span>
<span id="cb19-68"><a href="#cb19-68" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Mean: </span><span class="sc">{</span>mean<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb19-69"><a href="#cb19-69" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Variance: </span><span class="sc">{</span>x<span class="sc">.</span>var(axis<span class="op">=</span><span class="dv">0</span>)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb19-70"><a href="#cb19-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-71"><a href="#cb19-71" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Normalized Data Statistics (γ=1, β=0):"</span>)</span>
<span id="cb19-72"><a href="#cb19-72" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Mean: </span><span class="sc">{</span>x_norm<span class="sc">.</span>mean(axis<span class="op">=</span><span class="dv">0</span>)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb19-73"><a href="#cb19-73" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Variance: </span><span class="sc">{</span>x_norm<span class="sc">.</span>var(axis<span class="op">=</span><span class="dv">0</span>)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb19-74"><a href="#cb19-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-75"><a href="#cb19-75" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Scaled Data Statistics (γ=2, β=1):"</span>)</span>
<span id="cb19-76"><a href="#cb19-76" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Mean: </span><span class="sc">{</span>x_scaled<span class="sc">.</span>mean(axis<span class="op">=</span><span class="dv">0</span>)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb19-77"><a href="#cb19-77" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Variance: </span><span class="sc">{</span>x_scaled<span class="sc">.</span>var(axis<span class="op">=</span><span class="dv">0</span>)<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="06_과적합과 해결 기법의 발전_files/figure-html/cell-15-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
Original Data Statistics:
Mean: [4.40716778 4.99644709]
Variance: [8.89458134 8.45478364]

Normalized Data Statistics (γ=1, β=0):
Mean: [-2.70894418e-16 -3.59712260e-16]
Variance: [0.99999888 0.99999882]

Scaled Data Statistics (γ=2, β=1):
Mean: [1. 1.]
Variance: [3.9999955  3.99999527]</code></pre>
</div>
</div>
<p>seed(42)에서 흔히 랜덤 초기값을 42로 설정하는 것을 볼 수 있습니다. 이는 프로그래머적 관행으로 다른 숫자를 해도 됩니다. 42는 더글라스 애덤스 소설 “은하수를 여행하는 히치하이커를 위한 안내서”에서 “생명, 우주, 그리고 모든 것에 대한 해답”으로 나오는 숫자입니다. 이 때문에 프로그래머 사이에 예제 코드등에 흔히 관용처럼 애용됩니다.</p>
</section>
<section id="파이토치에서의-배치-정규화-구현" class="level3">
<h3 class="anchored">6.4.2 파이토치에서의 배치 정규화 구현</h3>
<p>파이토치에서 구현은 통상 신경망 층에 배치정규화 층을 삽입합니다. 다음이 그 예입니다.</p>
<div id="cell-35" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.nn <span class="im">as</span> nn</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> SimpleNet(nn.Module):</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.network <span class="op">=</span> nn.Sequential(</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>            nn.Linear(<span class="dv">784</span>, <span class="dv">256</span>),</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>            nn.BatchNorm1d(<span class="dv">256</span>),  <span class="co"># 배치 정규화 층</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>            nn.ReLU(),</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>            nn.Linear(<span class="dv">256</span>, <span class="dv">10</span>)</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, x):</span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.network(x)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>파이토치에서 배치정규화 구현을 원 소스코드를 기반으로 단순화 하면 다음과 같습니다. 앞장에서 했듯이 간략하게 학습 목적으로 구현한 것입니다.</p>
<div id="cell-37" class="cell" data-execution_count="23">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.nn <span class="im">as</span> nn</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BatchNorm1d(nn.Module):</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, num_features, eps<span class="op">=</span><span class="fl">1e-5</span>, momentum<span class="op">=</span><span class="fl">0.1</span>):</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.num_features <span class="op">=</span> num_features</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.eps <span class="op">=</span> eps</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.momentum <span class="op">=</span> momentum</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Trainable parameters</span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.gamma <span class="op">=</span> nn.Parameter(torch.ones(num_features))  <span class="co"># scale</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.beta <span class="op">=</span> nn.Parameter(torch.zeros(num_features))  <span class="co"># shift</span></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Running statistics to be tracked</span></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.register_buffer(<span class="st">'running_mean'</span>, torch.zeros(num_features))</span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.register_buffer(<span class="st">'running_var'</span>, torch.ones(num_features))</span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, x):</span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.training:</span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Calculate mini-batch statistics</span></span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a>            batch_mean <span class="op">=</span> x.mean(dim<span class="op">=</span><span class="dv">0</span>)  <span class="co"># Mean per channel</span></span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a>            batch_var <span class="op">=</span> x.var(dim<span class="op">=</span><span class="dv">0</span>, unbiased<span class="op">=</span><span class="va">False</span>)  <span class="co"># Variance per channel</span></span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Update running statistics (important)</span></span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.running_mean <span class="op">=</span> (<span class="dv">1</span> <span class="op">-</span> <span class="va">self</span>.momentum) <span class="op">*</span> <span class="va">self</span>.running_mean <span class="op">+</span> <span class="va">self</span>.momentum <span class="op">*</span> batch_mean</span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.running_var <span class="op">=</span> (<span class="dv">1</span> <span class="op">-</span> <span class="va">self</span>.momentum) <span class="op">*</span> <span class="va">self</span>.running_var <span class="op">+</span> <span class="va">self</span>.momentum <span class="op">*</span> batch_var</span>
<span id="cb22-28"><a href="#cb22-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-29"><a href="#cb22-29" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Normalize</span></span>
<span id="cb22-30"><a href="#cb22-30" aria-hidden="true" tabindex="-1"></a>            x_norm <span class="op">=</span> (x <span class="op">-</span> batch_mean) <span class="op">/</span> torch.sqrt(batch_var <span class="op">+</span> <span class="va">self</span>.eps)</span>
<span id="cb22-31"><a href="#cb22-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-32"><a href="#cb22-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb22-33"><a href="#cb22-33" aria-hidden="true" tabindex="-1"></a>            <span class="co"># During inference, use the stored statistics</span></span>
<span id="cb22-34"><a href="#cb22-34" aria-hidden="true" tabindex="-1"></a>            x_norm <span class="op">=</span> (x <span class="op">-</span> <span class="va">self</span>.running_mean) <span class="op">/</span> torch.sqrt(<span class="va">self</span>.running_var <span class="op">+</span> <span class="va">self</span>.eps)</span>
<span id="cb22-35"><a href="#cb22-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-36"><a href="#cb22-36" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Apply scale and shift</span></span>
<span id="cb22-37"><a href="#cb22-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.gamma <span class="op">*</span> x_norm <span class="op">+</span> <span class="va">self</span>.beta</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>앞서 기본 구현과 가장 다른 부분은 실행 중 통계를 업데이트하는 부분입니다. 훈련 시 미니 배치의 통계값(평균과 분산)이 이동하는 것을 누적해서 전체 평균과 분산을 최종적으로 알 수 있게 합니다. 이동을 추적하는 것은 모멘텀(기본값 0.1)을 사용한 지수 이동 평균(Exponential Moving Average)을 사용합니다. 훈련 시 얻어진 이 평균과 분산을 추론 시에 이용함으로써 추론 데이터에 대해 정확한 분산, 편차를 적용하게 되고 학습과 추론의 일관성이 보장됩니다.</p>
<p>물론 이 구현은 학습 목적으로 매우 단순화한 것입니다. 참고를 한 코드 위치는 (https://github.com/pytorch/pytorch/blob/main/torch/nn/modules/batchnorm.py) 입니다. BatchNorm1d의 실제 구현은 훨씬 더 복잡합니다. 이는 통상 파이토치, 텐서플로우 등 프레임워크에서는 기본적인 로직 이외에도 CUDA 최적화, 그래디언트 최적화, 다양한 설정 처리, C/C++과의 연동 등 다양한 로직을 포함하기 때문입니다.</p>
<div class="callout callout-style-default callout-note callout-titled" title="클릭하여 내용 보기 (딥다이브: 배치 정규화의 수식 유도 및 역전파 과정 상세 분석)">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-2-contents" aria-controls="callout-2" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
클릭하여 내용 보기 (딥다이브: 배치 정규화의 수식 유도 및 역전파 과정 상세 분석)
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-2" class="callout-2-contents callout-collapse collapse">
<section id="배치-정규화의-수식-유도-및-역전파-과정-상세-분석" class="level2 callout-body-container callout-body">
<h2 class="anchored" data-anchor-id="배치-정규화의-수식-유도-및-역전파-과정-상세-분석">배치 정규화의 수식 유도 및 역전파 과정 상세 분석</h2>
<p>배치 정규화(Batch Normalization, BN)는 2015년 Ioffe &amp; Szegedy에 의해 제안된 이후, 딥러닝 모델 학습의 핵심 기법 중 하나로 자리 잡았습니다. BN은 각 층의 입력을 정규화하여 학습 속도를 가속화하고, 기울기 소실/폭주 문제를 완화하며, 어느 정도의 규제(regularization) 효과도 제공합니다. 이 딥다이브에서는 BN의 순전파 및 역전파 과정을 자세히 살펴보고, 그 효과를 수학적으로 분석합니다.</p>
<section id="배치-정규화의-순전파forward-pass-수식-유도" class="level3">
<h3 class="anchored" data-anchor-id="배치-정규화의-순전파forward-pass-수식-유도">배치 정규화의 순전파(Forward Pass) 수식 유도</h3>
<p>배치 정규화는 미니 배치(mini-batch) 단위로 수행됩니다. 미니 배치의 크기를 <span class="math inline">\(B\)</span>, 특성(feature)의 차원을 <span class="math inline">\(D\)</span>라고 할 때, 미니 배치 입력 데이터는 <span class="math inline">\(B \times D\)</span> 행렬 <span class="math inline">\(\mathbf{X}\)</span>로 표현됩니다. BN은 각 특성 차원별로 독립적으로 수행되므로, 설명을 위해 하나의 특성 차원에 대한 연산만 고려하겠습니다.</p>
<ol type="1">
<li><p><strong>미니 배치 평균 계산:</strong></p>
<p><span class="math inline">\(\mu_B = \frac{1}{B} \sum_{i=1}^{B} x_i\)</span></p>
<p>여기서 <span class="math inline">\(x_i\)</span>는 미니 배치의 <span class="math inline">\(i\)</span>번째 샘플의 해당 특성 값을 나타냅니다.</p></li>
<li><p><strong>미니 배치 분산 계산:</strong></p>
<p><span class="math inline">\(\sigma_B^2 = \frac{1}{B} \sum_{i=1}^{B} (x_i - \mu_B)^2\)</span></p></li>
<li><p><strong>정규화(Normalization):</strong></p>
<p><span class="math inline">\(\hat{x_i} = \frac{x_i - \mu_B}{\sqrt{\sigma_B^2 + \epsilon}}\)</span></p>
<p>여기서 <span class="math inline">\(\epsilon\)</span>은 분모가 0이 되는 것을 방지하기 위한 작은 상수입니다.</p></li>
<li><p><strong>스케일링 및 시프트(Scale and Shift):</strong></p>
<p><span class="math inline">\(y_i = \gamma \hat{x_i} + \beta\)</span></p>
<p>여기서 <span class="math inline">\(\gamma\)</span>와 <span class="math inline">\(\beta\)</span>는 학습 가능한 파라미터로, 각각 스케일링과 시프트를 담당합니다. 이 파라미터들은 정규화된 데이터의 표현력을 복원하는 역할을 합니다.</p></li>
</ol>
</section>
<section id="배치-정규화의-역전파backward-pass-수식-유도---계산그래프-포함" class="level3">
<h3 class="anchored" data-anchor-id="배치-정규화의-역전파backward-pass-수식-유도---계산그래프-포함">배치 정규화의 역전파(Backward Pass) 수식 유도 - 계산그래프 포함</h3>
<p>배치 정규화의 역전파는 연쇄 법칙(chain rule)을 사용하여 각 파라미터에 대한 손실 함수(loss function)의 기울기를 계산하는 과정입니다. 계산 그래프를 통해 이 과정을 시각적으로 표현하면 다음과 같습니다. (여기서는 ASCII art로 간략하게 표현)</p>
<pre><code>     x_i   --&gt;   [-]   --&gt;   [/]   --&gt;   [*]   --&gt;   [+]   --&gt;   y_i
      |          ^          ^          ^          ^
      |          |          |          |          |
      |          |          |          |          +---&gt; beta
      |          |          |          +---&gt; gamma
      |          |          +---&gt; sqrt(...) + epsilon
      |          +---&gt; mu_B, sigma_B^2</code></pre>
<ul>
<li><span class="math inline">\(x_i\)</span>: 입력</li>
<li><span class="math inline">\([-]\)</span>: 뺄셈 (<span class="math inline">\(x_i - \mu_B\)</span>)</li>
<li><span class="math inline">\([/]\)</span>: 나눗셈 (<span class="math inline">\((x_i - \mu_B) / \sqrt{\sigma_B^2 + \epsilon}\)</span>)</li>
<li><span class="math inline">\([*]\)</span>: 곱셈 (<span class="math inline">\(\gamma \hat{x_i}\)</span>)</li>
<li><span class="math inline">\([+]\)</span>: 덧셈 (<span class="math inline">\(\gamma \hat{x_i} + \beta\)</span>)</li>
<li><span class="math inline">\(y_i\)</span>: 출력</li>
<li><span class="math inline">\(\mu_B\)</span>: 평균</li>
<li><span class="math inline">\(\sigma_B^2\)</span>: 분산</li>
<li><span class="math inline">\(\epsilon\)</span>: 분모가 0이 되는 것을 막는 작은 수</li>
<li><span class="math inline">\(\gamma, \beta\)</span>: 학습 파라미터</li>
</ul>
<p>이제, 각 단계별로 역전파를 계산해 보겠습니다. 손실 함수를 <span class="math inline">\(\mathcal{L}\)</span>이라고 하고, <span class="math inline">\(\frac{\partial \mathcal{L}}{\partial y_i}\)</span>가 주어졌다고 가정합니다.</p>
<ol type="1">
<li><p><strong><span class="math inline">\(\frac{\partial \mathcal{L}}{\partial \beta}\)</span> 와 <span class="math inline">\(\frac{\partial \mathcal{L}}{\partial \gamma}\)</span> 계산:</strong></p>
<p><span class="math inline">\(\frac{\partial \mathcal{L}}{\partial \beta} = \sum_{i=1}^{B} \frac{\partial \mathcal{L}}{\partial y_i} \cdot \frac{\partial y_i}{\partial \beta} = \sum_{i=1}^{B} \frac{\partial \mathcal{L}}{\partial y_i}\)</span></p>
<p><span class="math inline">\(\frac{\partial \mathcal{L}}{\partial \gamma} = \sum_{i=1}^{B} \frac{\partial \mathcal{L}}{\partial y_i} \cdot \frac{\partial y_i}{\partial \gamma} = \sum_{i=1}^{B} \frac{\partial \mathcal{L}}{\partial y_i} \cdot \hat{x_i}\)</span></p></li>
<li><p><strong><span class="math inline">\(\frac{\partial \mathcal{L}}{\partial \hat{x_i}}\)</span> 계산:</strong></p>
<p><span class="math inline">\(\frac{\partial \mathcal{L}}{\partial \hat{x_i}} = \frac{\partial \mathcal{L}}{\partial y_i} \cdot \frac{\partial y_i}{\partial \hat{x_i}} = \frac{\partial \mathcal{L}}{\partial y_i} \cdot \gamma\)</span></p></li>
<li><p><strong><span class="math inline">\(\frac{\partial \mathcal{L}}{\partial \sigma_B^2}\)</span> 계산:</strong></p>
<p><span class="math inline">\(\frac{\partial \mathcal{L}}{\partial \sigma_B^2} = \sum_{i=1}^{B} \frac{\partial \mathcal{L}}{\partial \hat{x_i}} \cdot \frac{\partial \hat{x_i}}{\partial \sigma_B^2} = \sum_{i=1}^{B} \frac{\partial \mathcal{L}}{\partial \hat{x_i}} \cdot (x_i - \mu_B) \cdot (-\frac{1}{2})(\sigma_B^2 + \epsilon)^{-3/2}\)</span></p></li>
<li><p><strong><span class="math inline">\(\frac{\partial \mathcal{L}}{\partial \mu_B}\)</span> 계산:</strong></p>
<p><span class="math inline">\(\frac{\partial \mathcal{L}}{\partial \mu_B} = \sum_{i=1}^{B} \frac{\partial \mathcal{L}}{\partial \hat{x_i}} \cdot \frac{\partial \hat{x_i}}{\partial \mu_B} + \frac{\partial \mathcal{L}}{\partial \sigma_B^2} \cdot \frac{\partial \sigma_B^2}{\partial \mu_B}  = \sum_{i=1}^{B} \frac{\partial \mathcal{L}}{\partial \hat{x_i}} \cdot \frac{-1}{\sqrt{\sigma_B^2 + \epsilon}} + \frac{\partial \mathcal{L}}{\partial \sigma_B^2} \cdot (-2)\frac{1}{B}\sum_{i=1}^B (x_i-\mu_B)\)</span></p>
<p><span class="math inline">\(\sum_{i=1}^B (x_i - \mu_B) = 0\)</span> 이므로</p>
<p><span class="math inline">\(\frac{\partial \mathcal{L}}{\partial \mu_B} =  \sum_{i=1}^{B} \frac{\partial \mathcal{L}}{\partial \hat{x_i}} \cdot \frac{-1}{\sqrt{\sigma_B^2 + \epsilon}}\)</span></p></li>
<li><p><strong><span class="math inline">\(\frac{\partial \mathcal{L}}{\partial x_i}\)</span> 계산:</strong></p>
<p><span class="math inline">\(\frac{\partial \mathcal{L}}{\partial x_i} = \frac{\partial \mathcal{L}}{\partial \hat{x_i}} \cdot \frac{\partial \hat{x_i}}{\partial x_i} + \frac{\partial \mathcal{L}}{\partial \mu_B} \cdot \frac{\partial \mu_B}{\partial x_i}  + \frac{\partial \mathcal{L}}{\partial \sigma_B^2} \cdot \frac{\partial \sigma_B^2}{\partial x_i} = \frac{\partial \mathcal{L}}{\partial \hat{x_i}} \cdot \frac{1}{\sqrt{\sigma_B^2 + \epsilon}} + \frac{\partial \mathcal{L}}{\partial \mu_B} \cdot \frac{1}{B} +  \frac{\partial \mathcal{L}}{\partial \sigma_B^2} \cdot \frac{2}{B}(x_i - \mu_B)\)</span></p></li>
</ol>
</section>
<section id="배치-정규화가-경사-소실폭주-문제를-완화하는-원리-설명" class="level3">
<h3 class="anchored" data-anchor-id="배치-정규화가-경사-소실폭주-문제를-완화하는-원리-설명">배치 정규화가 경사 소실/폭주 문제를 완화하는 원리 설명</h3>
<p>배치 정규화는 각 층의 입력을 정규화함으로써, 활성화 함수의 입력이 극단적인 값으로 치우치는 것을 방지합니다. 이는 시그모이드나 tanh와 같은 활성화 함수에서 발생하는 기울기 소실/폭주 문제를 완화하는 데 도움이 됩니다.</p>
<ul>
<li><p><strong>기울기 소실 문제:</strong> 활성화 함수의 입력이 매우 크거나 작으면, 해당 함수의 기울기가 0에 가까워져서 역전파 과정에서 기울기가 소멸하는 현상입니다. 배치 정규화는 입력을 평균 0, 분산 1로 정규화하여 활성화 함수의 입력이 적절한 범위에 있도록 유지하므로, 기울기 소실 문제를 완화합니다.</p></li>
<li><p><strong>기울기 폭주 문제:</strong> 활성화 함수의 입력이 매우 커서 기울기가 극단적으로 커지는 현상입니다. 배치 정규화는 입력의 범위를 제한하므로, 기울기 폭주 문제도 완화합니다.</p></li>
</ul>
</section>
<section id="배치-정규화의-이동-평균running-mean-running-variance-계산-및-추론-시-활용" class="level3">
<h3 class="anchored" data-anchor-id="배치-정규화의-이동-평균running-mean-running-variance-계산-및-추론-시-활용">배치 정규화의 이동 평균(running mean, running variance) 계산 및 추론 시 활용</h3>
<p>배치 정규화는 훈련 시에는 미니 배치 단위로 평균과 분산을 계산하지만, 추론(inference) 시에는 전체 훈련 데이터에 대한 평균과 분산의 추정치가 필요합니다. 이를 위해 배치 정규화는 훈련 과정에서 이동 평균(running mean)과 이동 분산(running variance)을 계산합니다.</p>
<ul>
<li><p><strong>이동 평균 계산:</strong></p>
<p><span class="math inline">\(\text{running\_mean} = (1 - \text{momentum}) \times \text{running\_mean} + \text{momentum} \times \mu_B\)</span></p></li>
<li><p><strong>이동 분산 계산:</strong></p>
<p><span class="math inline">\(\text{running\_var} = (1 - \text{momentum}) \times \text{running\_var} + \text{momentum} \times \sigma_B^2\)</span></p></li>
</ul>
<p>여기서 <code>momentum</code>은 일반적으로 0.1 또는 0.01과 같은 작은 값으로 설정되는 하이퍼파라미터입니다.</p>
<p>추론 시에는 훈련 과정에서 계산된 <code>running_mean</code>과 <code>running_var</code>를 사용하여 입력을 정규화합니다.</p>
</section>
<section id="배치-정규화와-다른-정규화-기법layer-normalization-instance-normalization-group-normalization과의-비교" class="level3">
<h3 class="anchored" data-anchor-id="배치-정규화와-다른-정규화-기법layer-normalization-instance-normalization-group-normalization과의-비교">배치 정규화와 다른 정규화 기법(Layer Normalization, Instance Normalization, Group Normalization)과의 비교</h3>
<ul>
<li><p><strong>배치 정규화 (Batch Normalization, BN):</strong> 미니 배치 내의 샘플 간의 통계를 사용합니다. 배치 크기에 영향을 받으며, RNN에는 적용하기 어렵습니다.</p></li>
<li><p><strong>층 정규화 (Layer Normalization, LN):</strong> 각 샘플 내에서 특성 차원에 대한 통계를 사용합니다. 배치 크기에 영향을 받지 않으며, RNN에 적용하기 쉽습니다.</p></li>
<li><p><strong>인스턴스 정규화 (Instance Normalization, IN):</strong> 각 샘플, 각 채널별로 독립적으로 통계를 계산합니다. 주로 스타일 전이(style transfer)와 같은 이미지 생성 작업에 사용됩니다.</p></li>
<li><p><strong>그룹 정규화 (Group Normalization, GN):</strong> 채널을 그룹으로 나누어 각 그룹 내에서 통계를 계산합니다. 배치 크기가 작을 때 BN의 대안으로 사용될 수 있습니다.</p></li>
</ul>
<p>각 정규화 기법은 서로 다른 상황에서 장단점을 가지므로, 문제의 특성과 모델 아키텍처에 따라 적절한 기법을 선택해야 합니다.</p>
</section>
</section>
</div>
</div>
</section>
<section id="통계-추적과-추론-시-적용" class="level3">
<h3 class="anchored" data-anchor-id="통계-추적과-추론-시-적용">6.4.3 통계 추적과 추론 시 적용</h3>
</section>
</section>
<section id="하이퍼파라미터의-최적화" class="level2">
<h2 class="anchored" data-anchor-id="하이퍼파라미터의-최적화">6.5 하이퍼파라미터의 최적화</h2>
<p>하이퍼파라미터 최적화는 모델 성능에 매우 중요한 영향을 미칩니다. 그 중요성은 1990년대부터 알려지기 시작했습니다. 1990년대 후반 서포트 벡터 머신(SVM)에서 동일한 모델이라도 커널 함수의 파라미터(C, gamma 등)가 성능에 결정적인 역할을 한다는 것이 발견되었습니다. 2015년 무렵 베이지안 최적화가 수동 튜닝보다 더 나은 결과를 도출한다는 것이 입증되었고, 이는 자동화된 튜닝(automated tuning) 방법인 Google AutoML (2017년)의 핵심적인 기반이 되었습니다.</p>
<section id="최적화-방법론-비교" class="level3">
<h3 class="anchored" data-anchor-id="최적화-방법론-비교">6.5.1 최적화 방법론 비교</h3>
<p>하이퍼파라미터를 최적화하는 방법에는 여러 가지가 있습니다. 대표적인 방법들은 다음과 같습니다.</p>
<ol type="1">
<li><p><strong>그리드 탐색 (Grid Search):</strong> 가장 기본적인 방법으로, 각 하이퍼파라미터의 가능한 값들을 리스트로 지정하고, 이 값들의 모든 조합을 시도합니다. 하이퍼파라미터 개수가 적고, 각 파라미터가 가질 수 있는 값의 범위가 제한적일 때 유용하지만, 모든 조합을 테스트해야 하므로 계산 비용이 매우 높습니다. 간단한 모델을 테스트하거나, 탐색 공간이 매우 작은 경우에 적합합니다.</p></li>
<li><p><strong>랜덤 탐색 (Random Search):</strong> 각 하이퍼파라미터의 값을 무작위로 선택하여 조합을 생성하고, 이 조합들로 모델을 학습시켜 성능을 평가합니다. 하이퍼파라미터 중 일부가 성능에 큰 영향을 미치는 경우, 그리드 탐색보다 효과적일 수 있습니다. (Bergstra &amp; Bengio, 2012)</p></li>
<li><p><strong>베이지안 최적화 (Bayesian Optimization):</strong> 이전 탐색 결과를 기반으로, 확률 모델(일반적으로 가우시안 프로세스)을 사용하여 다음으로 시도할 하이퍼파라미터 조합을 <em>지능적</em>으로 선택합니다. 획득 함수(acquisition function)를 최대화하는 지점을 다음 탐색 지점으로 선택합니다. 하이퍼파라미터 탐색 공간을 효율적으로 탐색하므로, 그리드 탐색이나 랜덤 탐색보다 적은 횟수의 시도로 더 좋은 조합을 찾을 수 있습니다.</p></li>
</ol>
<p>이 외에도 유전 알고리즘을 이용한 진화 알고리즘(Evolutionary Algorithms), 기울기 기반 최적화(Gradient-based Optimization) 등의 방법이 있습니다.</p>
<p>다음은 베이지안 최적화를 사용하여 간단한 신경망 모델의 하이퍼파라미터를 최적화하는 예제입니다.</p>
</section>
<section id="bayes-opt를-이용한-최적화" class="level3">
<h3 class="anchored" data-anchor-id="bayes-opt를-이용한-최적화">6.5.2 Bayes-Opt를 이용한 최적화</h3>
<p>베이지안 최적화는 2010년대부터 주목받기 시작했습니다. 특히 2012년 “Practical Bayesian Optimization of Machine Learning Algorithms” 논문이 발표된 후, 딥러닝 모델의 하이퍼파라미터 최적화의 주요 방법 중 하나로 자리 잡았습니다. 그리드 탐색이나 랜덤 탐색과 달리, 이전 시도 결과를 바탕으로 다음 탐색할 파라미터를 <em>지능적</em>으로 선택한다는 점에서 큰 장점을 가집니다.</p>
<p>베이지안 최적화는 크게 다음 세 단계를 반복합니다.</p>
<ol type="1">
<li><strong>초기 샘플링 (Initialization):</strong> <code>init_points</code>에 지정된 횟수만큼 무작위로 하이퍼파라미터 조합을 선택하여 모델을 훈련하고 성능을 평가합니다.</li>
<li><strong>대리 모델 (Surrogate Model) 구축:</strong> 지금까지의 실험 결과를 바탕으로, 하이퍼파라미터와 성능 사이의 관계를 모델링하는 대리 모델(주로 가우시안 프로세스)을 구축합니다.</li>
<li><strong>획득 함수 (Acquisition Function) 최적화:</strong> 대리 모델을 바탕으로, 다음으로 시도할 가장 유망한 하이퍼파라미터 조합을 선택합니다. 이 때 획득 함수(acquisition function)를 사용하는데, 획득 함수는 현재까지의 정보(대리 모델)를 바탕으로, “탐색(exploration)”과 “활용(exploitation)”의 균형을 맞추면서 다음 탐색 지점을 결정합니다.</li>
<li>2~3 단계를 반복</li>
</ol>
<div id="cell-42" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.nn <span class="im">as</span> nn</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.optim <span class="im">as</span> optim</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_04.models.base <span class="im">import</span> SimpleNetwork  </span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_04.utils.data <span class="im">import</span> get_data_loaders, get_device  </span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> bayes_opt <span class="im">import</span> BayesianOptimization</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_04.experiments.model_training <span class="im">import</span> train_model, eval_loop  </span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> train_simple_net(hidden_layers, learning_rate, batch_size, epochs):</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Trains a SimpleNetwork model with given hyperparameters.</span></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a><span class="co">       Uses CIFAR100 dataset and train_model from Chapter 4.</span></span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>    device <span class="op">=</span> get_device()  <span class="co"># Use the utility function to get device</span></span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Get data loaders for CIFAR100</span></span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a>    train_loader, test_loader <span class="op">=</span> get_data_loaders(dataset<span class="op">=</span><span class="st">"CIFAR100"</span>, batch_size<span class="op">=</span>batch_size)</span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Instantiate the model with specified activation and hidden layers.</span></span>
<span id="cb24-20"><a href="#cb24-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># CIFAR100 images are 3x32x32, so the input size is 3*32*32 = 3072.</span></span>
<span id="cb24-21"><a href="#cb24-21" aria-hidden="true" tabindex="-1"></a>    model <span class="op">=</span> SimpleNetwork(act_func<span class="op">=</span>nn.ReLU(), input_shape<span class="op">=</span><span class="dv">3</span><span class="op">*</span><span class="dv">32</span><span class="op">*</span><span class="dv">32</span>, hidden_shape<span class="op">=</span>hidden_layers, num_labels<span class="op">=</span><span class="dv">100</span>).to(device)</span>
<span id="cb24-22"><a href="#cb24-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-23"><a href="#cb24-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Optimizer: Use Adam</span></span>
<span id="cb24-24"><a href="#cb24-24" aria-hidden="true" tabindex="-1"></a>    optimizer <span class="op">=</span> optim.Adam(model.parameters(), lr<span class="op">=</span>learning_rate)</span>
<span id="cb24-25"><a href="#cb24-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-26"><a href="#cb24-26" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Train the model using the training function from Chapter 4</span></span>
<span id="cb24-27"><a href="#cb24-27" aria-hidden="true" tabindex="-1"></a>    results <span class="op">=</span> train_model(model, train_loader, test_loader, device, optimizer<span class="op">=</span>optimizer, epochs<span class="op">=</span>epochs, save_dir<span class="op">=</span><span class="st">"./tmp/tune"</span>,</span>
<span id="cb24-28"><a href="#cb24-28" aria-hidden="true" tabindex="-1"></a>                         retrain<span class="op">=</span><span class="va">True</span>) <span class="co"># retrain=True로 설정</span></span>
<span id="cb24-29"><a href="#cb24-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-30"><a href="#cb24-30" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Return the final test accuracy</span></span>
<span id="cb24-31"><a href="#cb24-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> results[<span class="st">'test_accuracies'</span>][<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb24-32"><a href="#cb24-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-33"><a href="#cb24-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-34"><a href="#cb24-34" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> train_wrapper(learning_rate, batch_size, hidden1, hidden2):</span>
<span id="cb24-35"><a href="#cb24-35" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Wrapper function for Bayesian optimization."""</span></span>
<span id="cb24-36"><a href="#cb24-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> train_simple_net(</span>
<span id="cb24-37"><a href="#cb24-37" aria-hidden="true" tabindex="-1"></a>        hidden_layers<span class="op">=</span>[<span class="bu">int</span>(hidden1), <span class="bu">int</span>(hidden2)],</span>
<span id="cb24-38"><a href="#cb24-38" aria-hidden="true" tabindex="-1"></a>        learning_rate<span class="op">=</span>learning_rate,</span>
<span id="cb24-39"><a href="#cb24-39" aria-hidden="true" tabindex="-1"></a>        batch_size<span class="op">=</span><span class="bu">int</span>(batch_size),</span>
<span id="cb24-40"><a href="#cb24-40" aria-hidden="true" tabindex="-1"></a>        epochs<span class="op">=</span><span class="dv">10</span></span>
<span id="cb24-41"><a href="#cb24-41" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb24-42"><a href="#cb24-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-43"><a href="#cb24-43" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> optimize_hyperparameters():</span>
<span id="cb24-44"><a href="#cb24-44" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Runs hyperparameter optimization."""</span></span>
<span id="cb24-45"><a href="#cb24-45" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Set the parameter ranges to be optimized.</span></span>
<span id="cb24-46"><a href="#cb24-46" aria-hidden="true" tabindex="-1"></a>    pbounds <span class="op">=</span> {</span>
<span id="cb24-47"><a href="#cb24-47" aria-hidden="true" tabindex="-1"></a>        <span class="st">"learning_rate"</span>: (<span class="fl">1e-4</span>, <span class="fl">1e-2</span>),</span>
<span id="cb24-48"><a href="#cb24-48" aria-hidden="true" tabindex="-1"></a>        <span class="st">"batch_size"</span>: (<span class="dv">64</span>, <span class="dv">256</span>),</span>
<span id="cb24-49"><a href="#cb24-49" aria-hidden="true" tabindex="-1"></a>        <span class="st">"hidden1"</span>: (<span class="dv">64</span>, <span class="dv">512</span>),  <span class="co"># First hidden layer</span></span>
<span id="cb24-50"><a href="#cb24-50" aria-hidden="true" tabindex="-1"></a>        <span class="st">"hidden2"</span>: (<span class="dv">32</span>, <span class="dv">256</span>)   <span class="co"># Second hidden layer</span></span>
<span id="cb24-51"><a href="#cb24-51" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb24-52"><a href="#cb24-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-53"><a href="#cb24-53" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create a Bayesian optimization object.</span></span>
<span id="cb24-54"><a href="#cb24-54" aria-hidden="true" tabindex="-1"></a>    optimizer <span class="op">=</span> BayesianOptimization(</span>
<span id="cb24-55"><a href="#cb24-55" aria-hidden="true" tabindex="-1"></a>        f<span class="op">=</span>train_wrapper,</span>
<span id="cb24-56"><a href="#cb24-56" aria-hidden="true" tabindex="-1"></a>        pbounds<span class="op">=</span>pbounds,</span>
<span id="cb24-57"><a href="#cb24-57" aria-hidden="true" tabindex="-1"></a>        random_state<span class="op">=</span><span class="dv">1</span>,</span>
<span id="cb24-58"><a href="#cb24-58" aria-hidden="true" tabindex="-1"></a>        allow_duplicate_points<span class="op">=</span><span class="va">True</span></span>
<span id="cb24-59"><a href="#cb24-59" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb24-60"><a href="#cb24-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-61"><a href="#cb24-61" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Run optimization</span></span>
<span id="cb24-62"><a href="#cb24-62" aria-hidden="true" tabindex="-1"></a>    optimizer.maximize(</span>
<span id="cb24-63"><a href="#cb24-63" aria-hidden="true" tabindex="-1"></a>        init_points<span class="op">=</span><span class="dv">4</span>,</span>
<span id="cb24-64"><a href="#cb24-64" aria-hidden="true" tabindex="-1"></a>        n_iter<span class="op">=</span><span class="dv">10</span>,</span>
<span id="cb24-65"><a href="#cb24-65" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb24-66"><a href="#cb24-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-67"><a href="#cb24-67" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Print the best parameters and accuracy</span></span>
<span id="cb24-68"><a href="#cb24-68" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Best parameters found:"</span>)</span>
<span id="cb24-69"><a href="#cb24-69" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Learning Rate: </span><span class="sc">{</span>optimizer<span class="sc">.</span><span class="bu">max</span>[<span class="st">'params'</span>][<span class="st">'learning_rate'</span>]<span class="sc">:.6f}</span><span class="ss">"</span>)</span>
<span id="cb24-70"><a href="#cb24-70" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Batch Size: </span><span class="sc">{</span><span class="bu">int</span>(optimizer.<span class="bu">max</span>[<span class="st">'params'</span>][<span class="st">'batch_size'</span>])<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb24-71"><a href="#cb24-71" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Hidden Layer 1: </span><span class="sc">{</span><span class="bu">int</span>(optimizer.<span class="bu">max</span>[<span class="st">'params'</span>][<span class="st">'hidden1'</span>])<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb24-72"><a href="#cb24-72" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Hidden Layer 2: </span><span class="sc">{</span><span class="bu">int</span>(optimizer.<span class="bu">max</span>[<span class="st">'params'</span>][<span class="st">'hidden2'</span>])<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb24-73"><a href="#cb24-73" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Best accuracy: </span><span class="sc">{</span>optimizer<span class="sc">.</span><span class="bu">max</span>[<span class="st">'target'</span>]<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb24-74"><a href="#cb24-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-75"><a href="#cb24-75" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">"__main__"</span>:</span>
<span id="cb24-76"><a href="#cb24-76" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Starting hyperparameter optimization..."</span>)</span>
<span id="cb24-77"><a href="#cb24-77" aria-hidden="true" tabindex="-1"></a>    optimize_hyperparameters()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>위 예제는 <code>BayesOpt</code> 패키지를 사용하여 하이퍼파라미터 최적화를 수행합니다. <code>SimpleNetwork</code> (4장에서 정의)를 훈련 대상으로 하며, CIFAR100 데이터셋을 사용합니다. <code>train_wrapper</code> 함수는 <code>BayesOpt</code>가 사용할 목적 함수(objective function) 역할을 하며, 주어진 하이퍼파라미터 조합으로 모델을 훈련하고 최종 테스트 정확도를 반환합니다.</p>
<p><code>pbounds</code>는 각 하이퍼파라미터의 탐색 범위를 지정합니다. <code>optimizer.maximize</code>에서 <code>init_points</code>는 초기 무작위 탐색 횟수, <code>n_iter</code>는 베이지안 최적화 반복 횟수입니다. 따라서 총 실험 횟수는 <code>init_points + n_iter</code>가 됩니다.</p>
<p>하이퍼파라미터 탐색 시 주의할 점은 다음과 같습니다.</p>
<ol type="1">
<li><strong>파라미터 범위:</strong> 너무 넓은 범위는 탐색 시간을 증가시키고, 너무 좁은 범위는 최적점을 놓칠 수 있습니다. 일반적으로 학습률은 로그 스케일(1e-4 ~ 1e-2), 뉴런 수는 2의 거듭제곱 단위로 설정하는 것이 일반적입니다.</li>
<li><strong>반복 횟수:</strong> 총 시도 횟수는 대략 (파라미터 개수) x 20 정도로 설정하는 것이 경험적으로 좋은 결과를 줍니다. 위 예제에서는 파라미터가 4개이므로, 총 14회의 시도(init_points=4, n_iter=10)는 조금 적을 수 있습니다. 더 나은 결과를 위해서는 <code>n_iter</code>를 늘리는 것을 고려할 수 있습니다.</li>
</ol>
</section>
<section id="botorch를-이용한-최적화" class="level3">
<h3 class="anchored" data-anchor-id="botorch를-이용한-최적화">6.5.3 BoTorch를 이용한 최적화</h3>
<p>최근 BoTorch라는 프레임워크가 딥러닝 하이퍼파라미터 최적화 분야에서 주목받고 있습니다. BoTorch는 2019년 FAIR (Facebook AI Research, 현재 Meta AI)에서 개발한 PyTorch 기반의 베이지안 최적화 프레임워크입니다. Bayes-Opt는 2016년부터 개발된, 더 오래된 베이지안 최적화 라이브러리이며, 직관적이고 간단한 인터페이스(scikit-learn 스타일의 API)를 제공하여 널리 사용됩니다.</p>
<p>두 라이브러리의 장단점은 명확합니다.</p>
<ul>
<li><strong>BoTorch:</strong>
<ul>
<li><strong>장점:</strong> 딥러닝 모델과의 통합, GPU 가속, 높은 샘플링 효율성, 다양한 고급 베이지안 최적화 기법(multi-fidelity, multi-task, 제약 조건 최적화 등), 자동 미분(automatic differentiation) 지원 등 딥러닝 모델의 하이퍼파라미터 최적화에 특화된 기능들을 제공합니다. 특히 대규모 모델, 고차원 파라미터 공간, 계산 비용이 큰 실험에 적합합니다.</li>
<li><strong>단점:</strong> Bayes-Opt에 비해 상대적으로 더 많은 학습이 필요하고, 초기 설정이 복잡할 수 있습니다.</li>
</ul></li>
<li><strong>Bayes-Opt:</strong>
<ul>
<li><strong>장점:</strong> 간단하고 직관적인 API를 제공하여 사용하기 쉽습니다. 설치가 간편하고, 튜토리얼과 예제 코드가 풍부합니다.</li>
<li><strong>단점:</strong> BoTorch에 비해 고급 기능이 부족하고, 딥러닝 모델과의 통합이 상대적으로 덜 매끄럽습니다. 대규모/고차원 문제에서는 성능이 저하될 수 있습니다.</li>
</ul></li>
</ul>
<p>따라서, 간단한 문제나 빠른 프로토타입 제작에는 Bayes-Opt를, 딥러닝 모델의 복잡한 하이퍼파라미터 최적화, 대규모/고차원 문제, 고급 베이지안 최적화 기법(예: multi-task, constrained optimization)이 필요한 경우에는 BoTorch를 사용하는 것이 좋습니다.</p>
<p>BoTorch를 사용하려면 Bayes-Opt와 달리, 초기 설정에 필요한 몇 가지 핵심 개념(대리 모델, 입력 데이터 정규화, 획득 함수)을 이해해야 합니다.</p>
<ol type="1">
<li><p><strong>대리(Surrogate) 모델:</strong></p>
<p>대리 모델은 실제 목적 함수(objective function, 여기서는 딥러닝 모델의 검증 정확도)를 근사하는 모델입니다. 일반적으로 가우시안 프로세스(GP)가 사용됩니다. GP는 계산 비용이 많이 드는 실제 목적 함수 대신, 빠르고 저렴하게 결과를 예측하는 데 사용됩니다. BoTorch에서는 다음과 같은 GP 모델들을 제공합니다.</p>
<ul>
<li><code>SingleTaskGP</code>: 가장 기본적인 가우시안 프로세스 모델입니다. 단일 목적(single-objective) 최적화 문제에 적합하며, 1000개 이하의 비교적 적은 데이터 포인트에서 효과적입니다.</li>
<li><code>MultiTaskGP</code>: 여러 목적 함수를 동시에 최적화하는 경우(multi-objective optimization)에 사용됩니다. 예를 들어, 모델의 정확도와 추론 시간을 함께 최적화할 수 있습니다.</li>
<li><code>SAASBO</code> (Sparsity-Aware Adaptive Subspace Bayesian Optimization): 고차원 파라미터 공간에 특화된 모델입니다. 고차원 공간에서는 희소성(sparsity)이 존재한다고 가정하고, 효율적인 탐색을 수행합니다.</li>
</ul></li>
<li><p><strong>입력 데이터 정규화:</strong></p>
<p>가우시안 프로세스는 데이터의 스케일에 민감하므로, 입력 데이터(하이퍼파라미터)를 정규화하는 것이 중요합니다. 일반적으로 모든 하이퍼파라미터를 [0, 1] 범위로 변환합니다. BoTorch는 <code>Normalize</code>와 <code>Standardize</code> 변환을 제공합니다.</p></li>
<li><p><strong>획득 함수 (Acquisition Function):</strong></p>
<p>획득 함수는 대리 모델(GP)을 기반으로, 다음으로 실험할 하이퍼파라미터 조합을 결정하는 데 사용됩니다. 획득 함수는 “탐색(exploration)”과 “활용(exploitation)” 사이의 균형을 맞추는 역할을 합니다. BoTorch는 다음과 같은 다양한 획득 함수를 제공합니다.</p>
<ul>
<li><code>ExpectedImprovement (EI)</code>: 가장 일반적인 획득 함수 중 하나입니다. 현재까지의 최적값보다 더 좋은 결과를 얻을 가능성과 그 향상 정도를 고려합니다.</li>
<li><code>LogExpectedImprovement (LogEI)</code>: EI의 로그 변환 버전입니다. 수치적으로 더 안정적이며, 작은 변화에도 민감하게 반응합니다.</li>
<li><code>UpperConfidenceBound (UCB)</code>: 탐색에 더 중점을 둔 획득 함수입니다. 불확실성이 높은 영역을 더 적극적으로 탐색합니다.</li>
<li><code>ProbabilityOfImprovement (PI)</code>: 현재 최적값보다 좋아질 확률을 나타냅니다.</li>
<li><code>qExpectedImprovement (qEI)</code>: q-batch EI라고도 하며, 병렬 최적화에 사용됩니다. 한 번에 여러 개의 후보를 선택합니다.</li>
<li><code>qNoisyExpectedImprovement (qNEI)</code>: q-batch Noisy EI. 노이즈가 있는 환경에서 사용됩니다.</li>
</ul></li>
</ol>
<p>전체 코드는 <code>package/botorch_optimization.py</code>에 있습니다. 명령행으로 직접 실행할 수 있습니다. 전체 코드에 자세한 주석이 포함되어 있으므로, 여기서는 각 코드의 중요한 부분만 설명하겠습니다.</p>
<div id="cell-45" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, max_trials: <span class="bu">int</span> <span class="op">=</span> <span class="dv">80</span>, init_samples: <span class="bu">int</span> <span class="op">=</span> <span class="dv">10</span>):</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>.param_bounds <span class="op">=</span> torch.tensor([</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>        [<span class="fl">1e-4</span>, <span class="fl">64.0</span>, <span class="fl">32.0</span>, <span class="fl">32.0</span>],      <span class="co"># 최소값</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>        [<span class="fl">1e-2</span>, <span class="fl">256.0</span>, <span class="fl">512.0</span>, <span class="fl">512.0</span>]    <span class="co"># 최대값</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>    ], dtype<span class="op">=</span>torch.float64)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>초기화 부분에서는 각 하이퍼파라미터의 최소, 최대값을 설정합니다. max_trials는 총 시도 횟수, init_samples는 초기 무작위 실험 횟수(Bayes-Opt의 init_points와 동일)입니다. init_samples는 통상 파라미터 개수의 2~3배로 설정합니다. 위 예에서는 하이퍼파라미터가 4개이므로, 8~12개 정도가 적절합니다. torch.float64를 사용하는 이유는 수치 안정성을 위해서입니다. 베이지안 최적화, 특히 가우시안 프로세스는 커널 행렬 계산 시 촐레스키 분해(Cholesky decomposition)를 사용하는데, 이 과정에서 float32는 정밀도 문제로 인해 오류가 발생할 수 있습니다.</p>
<div id="cell-47" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> tune(<span class="va">self</span>):</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 가우시안 프로세스 모델 학습</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>    model <span class="op">=</span> SingleTaskGP(configs, accuracies)</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>    mll <span class="op">=</span> ExactMarginalLogLikelihood(model.likelihood, model)</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>    fit_gpytorch_mll(mll)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>가우시안 프로세스 기반의 대리 모델로 <code>SingleTaskGP</code>를 사용합니다. <code>ExactMarginalLogLikelihood</code>는 모델 학습을 위한 손실 함수이며, <code>fit_gpytorch_mll</code>은 이 손실 함수를 사용하여 모델을 학습시킵니다.</p>
<div id="cell-49" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>acq_func <span class="op">=</span> LogExpectedImprovement(</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>    model, </span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>    best_f<span class="op">=</span>accuracies.<span class="bu">max</span>().item()</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>획득 함수로는 <code>LogExpectedImprovement</code>를 사용합니다. 로그를 사용하므로 수치적 안정성이 높고, 작은 변화에도 민감하게 반응합니다.</p>
<div id="cell-51" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>candidate, _ <span class="op">=</span> optimize_acqf(                                   <span class="co"># 획득 함수 최적화로 다음 실험할 파라미터 선택</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>    acq_func, bounds<span class="op">=</span>bounds,                                    <span class="co"># 획득 함수와 파라미터 범위 지정</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>    q<span class="op">=</span><span class="dv">1</span>,                                                        <span class="co"># 한 번에 하나의 설정만 선택</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>    num_restarts<span class="op">=</span><span class="dv">10</span>,                                            <span class="co"># 최적화 재시작 횟수</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>    raw_samples<span class="op">=</span><span class="dv">512</span>                                             <span class="co"># 초기 샘플링 수</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p><code>optimize_acqf</code> 함수는 획득 함수를 최적화하여 다음 실험할 하이퍼파라미터 조합(<code>candidate</code>)을 선택합니다.</p>
<ul>
<li><code>q=1</code>: 한 번에 하나의 후보만 선택합니다 (q-batch 최적화가 아님).</li>
<li><code>num_restarts=10</code>: 각 단계의 최적화를 수행할 때, 서로 다른 시작점에서 10번 반복하여 지역 최적해(local optima)에 빠지는 것을 방지합니다.</li>
<li><code>raw_samples=512</code>: 획득 함수 값을 추정하기 위해 가우시안 프로세스로부터 512개의 샘플을 추출합니다.</li>
</ul>
<p><code>num_restarts</code>와 <code>raw_samples</code>는 베이지안 최적화의 탐색-활용(exploration-exploitation) 트레이드오프에 중요한 영향을 미칩니다. <code>num_restarts</code>는 최적화의 철저함(thoroughness)을, <code>raw_samples</code>는 획득 함수 추정의 정확도를 결정합니다. 두 값이 클수록 계산 비용은 증가하지만, 더 좋은 결과를 얻을 가능성이 높아집니다. 일반적으로 다음과 같은 값을 사용할 수 있습니다.</p>
<ul>
<li>빠른 실행: <code>num_restarts=5</code>, <code>raw_samples=256</code></li>
<li>균형 설정: <code>num_restarts=10</code>, <code>raw_samples=512</code></li>
<li>정확도 중심: <code>num_restarts=20</code>, <code>raw_samples=1024</code></li>
</ul>
<div id="cell-53" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_06.botorch_optimizer <span class="im">import</span> run_botorch_optimization</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>run_botorch_optimization(max_trials<span class="op">=</span><span class="dv">80</span>, init_samples<span class="op">=</span><span class="dv">5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p><strong>결과</strong> 데이터셋 : FashionMNIST 에포크 : 20 초기 실험 : 5회 반복 실험 : 80회</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>최적 파라미터</th>
<th>Bayes-Opt</th>
<th>Botorch</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>학습률</td>
<td>6e-4</td>
<td>1e-4</td>
</tr>
<tr class="even">
<td>배치 크기</td>
<td>173</td>
<td>158</td>
</tr>
<tr class="odd">
<td>hid 1</td>
<td>426</td>
<td>512</td>
</tr>
<tr class="even">
<td>hid 2</td>
<td>197</td>
<td>512</td>
</tr>
<tr class="odd">
<td>정확도</td>
<td>0.7837</td>
<td>0.8057</td>
</tr>
</tbody>
</table>
<p>단순 비교이지만 BoTorch의 정확도가 더 높습니다. 간단한 최적 탐색에서는 Bayes-Opt를 전문적인 탐색에서는 BoTorch를 추천합니다.</p>
</section>
</section>
<section id="가우시안-프로세스" class="level2">
<h2 class="anchored" data-anchor-id="가우시안-프로세스">6.6 가우시안 프로세스</h2>
<blockquote class="blockquote">
<p><strong>도전과제:</strong> 모델의 예측 불확실성을 정량화하고, 이를 활용하여 능동적으로 학습할 수 있는 방법은 무엇일까?</p>
<p><strong>연구자의 고뇌:</strong> 전통적인 딥러닝 모델은 예측 결과를 점 추정(point estimate)으로 제공하지만, 실제 응용에서는 예측의 불확실성을 아는 것이 매우 중요합니다. 예를 들어, 자율 주행 자동차는 보행자의 다음 위치를 예측할 때, 그 예측이 얼마나 불확실한지를 알아야 안전하게 운전할 수 있습니다. 가우시안 프로세스는 베이지안 확률론에 기반하여 예측의 불확실성을 정량화하는 강력한 도구였지만, 계산 복잡도가 높고 대규모 데이터에 적용하기 어렵다는 단점이 있었습니다.</p>
</blockquote>
<p>가우시안 프로세스(Gaussian Process, GP)는 베이지안 머신러닝에서 불확실성을 포함한 예측(uncertainty-aware prediction)을 제공하는 핵심적인 모델입니다. 앞서 베이지안 최적화에서 가우시안 프로세스를 대리 모델(surrogate model)로 사용하는 것을 간략하게 살펴보았는데, 여기서는 가우시안 프로세스 자체의 기본 원리와 중요성을 좀 더 자세히 알아보겠습니다.</p>
<p>GP는 “함수 값들의 집합에 대한 확률 분포”로 정의됩니다. <span class="math inline">\(y = f(x)\)</span> 와 같은 결정론적 함수(deterministic function)와 달리, GP는 주어진 입력 <span class="math inline">\(x\)</span>에 대해 하나의 출력 값 <span class="math inline">\(y\)</span>를 예측하는 것이 아니라, 가능한 출력 값들의 <em>분포</em>를 예측합니다. 예를 들어, “내일 최고 기온은 25도”라고 확정적으로 예측하는 대신, “내일 최고 기온은 23도에서 27도 사이일 확률이 95%입니다”와 같이 예측의 불확실성을 함께 제공합니다. 만약 자전거를 타고 집으로 돌아가는 중이라면 대략의 경로는 이미 정해져 있지만, 매번 실제 경로는 다를 것입니다. 이렇게 결정론적인 예측이 아닌 불확실성을 포함하는 예측이 필요합니다.</p>
<p>불확실성을 포함한 예측을 다루는 수학적 도구의 기반은 19세기 수학자 가우스가 제안한 정규분포(가우시안 분포)입니다. 이를 기반으로 1940년대 GP가 발전합니다. 당시는 2차 세계대전 시기로 레이더 신호 처리, 암호 해독, 기상 정보 처리등 어떤 때보다 불확실한 데이터를 과학자들이 다뤄야 했던 때였습니다. 대표적 예는 노버트 위너(Norbert Wiener)가 고민했던 대공포 정확도 향상을 위해 비행기의 미래 위치를 예측하는 것이었습니다. 그는 비행기 움직임을 확률적 과정으로 보는(현재 위치 - 잠시 후 어느 정도 위치는 예측 가능 - 시간이 지날수록 불확실성이 커진다) “워너 프로세스”를 고안해냈고 이는 향후 GP의 중요한 토대가 됩니다. 비슷한 시기 해롤드 크레이머(Harald Cramér)는 시계열 분석에서 안드레이 콜모고로프(Andrey Kolmogorov)는 확률론에서 GP의 수학적 기초를 다지고 있었습니다. 1951년 다니엘 크리깅(Daniel Krige)이 광맥의 분포 예측을 하는 GP의 실질적인 응용을 만들어냅니다. 이후 1970년대에 이르러 통계학자들에 의해 공간 통계학 응용, 컴퓨터 실험설계, ML에서의 베이지안 최적화 등으로 체계화 됩니다. 오늘날에는 인공지능, 로봇공학, 기후 예측 등 불확실성을 다루는 거의 모든 분야에서 핵심적인 역할을 하고 있습니다. 특히 딥러닝에서는 최근 메타러닝을 통한 심층 커널 GP가 주목받고 있으며, 특히 분자 특성 예측과 같은 분야에서 뛰어난 성능을 보여주고 있습니다.</p>
<p>오늘날 GP는 인공지능, 로봇 공학, 기후 모델링 등 다양한 분야에서 활용되고 있습니다. 특히, 딥러닝에서는 최근 메타 러닝(meta-learning)을 통한 심층 커널 GP, 분자 특성 예측 등에서 뛰어난 성능을 보이고 있습니다.</p>
<div class="callout callout-style-default callout-note callout-titled" title="클릭하여 내용 보기 (딥다이브: 가우시안 프로세스의 수학적 기초와 머신러닝 응용)">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-3-contents" aria-controls="callout-3" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
클릭하여 내용 보기 (딥다이브: 가우시안 프로세스의 수학적 기초와 머신러닝 응용)
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-3" class="callout-3-contents callout-collapse collapse">
<section id="가우시안-프로세스의-수학적-기초와-머신러닝-응용" class="level2 callout-body-container callout-body">
<h2 class="anchored" data-anchor-id="가우시안-프로세스의-수학적-기초와-머신러닝-응용">가우시안 프로세스의 수학적 기초와 머신러닝 응용</h2>
<p>가우시안 프로세스(Gaussian Process, GP)는 커널 방법(kernel method)을 기반으로 하는 확률적 모델(probabilistic model)로, 회귀(regression) 및 분류(classification) 문제에 널리 사용됩니다. GP는 함수 자체에 대한 분포를 정의하여, 예측의 불확실성을 정량화할 수 있다는 장점을 가집니다. 이 딥다이브에서는 가우시안 프로세스의 수학적 기초를 다변량 정규 분포(multivariate normal distribution)부터 시작하여 확률적 과정(stochastic process) 관점까지 자세히 살펴보고, 다양한 머신러닝 응용을 탐구합니다.</p>
<section id="다변량-정규-분포-multivariate-normal-distribution" class="level3">
<h3 class="anchored" data-anchor-id="다변량-정규-분포-multivariate-normal-distribution">1. 다변량 정규 분포 (Multivariate Normal Distribution)</h3>
<p>가우시안 프로세스를 이해하기 위한 첫걸음은 다변량 정규 분포에 대한 이해입니다. <span class="math inline">\(d\)</span>차원 확률 벡터 <span class="math inline">\(\mathbf{x} = (x_1, x_2, ..., x_d)^T\)</span>가 다변량 정규 분포를 따른다는 것은 다음과 같은 확률 밀도 함수(probability density function)를 갖는다는 것을 의미합니다.</p>
<p><span class="math inline">\(p(\mathbf{x}) = \frac{1}{(2\pi)^{d/2}|\mathbf{\Sigma}|^{1/2}} \exp\left(-\frac{1}{2}(\mathbf{x} - \boldsymbol{\mu})^T \mathbf{\Sigma}^{-1} (\mathbf{x} - \boldsymbol{\mu})\right)\)</span></p>
<p>여기서 <span class="math inline">\(\boldsymbol{\mu} \in \mathbb{R}^d\)</span>는 평균 벡터, <span class="math inline">\(\mathbf{\Sigma} \in \mathbb{R}^{d \times d}\)</span>는 공분산 행렬(covariance matrix)입니다. 공분산 행렬은 양의 정부호(positive definite) 행렬이어야 합니다.</p>
<p><strong>핵심 속성:</strong></p>
<ul>
<li><p><strong>선형 변환:</strong> 다변량 정규 분포를 따르는 확률 변수의 선형 변환은 여전히 다변량 정규 분포를 따릅니다. 즉, <span class="math inline">\(\mathbf{x} \sim \mathcal{N}(\boldsymbol{\mu}, \mathbf{\Sigma})\)</span>이고, <span class="math inline">\(\mathbf{y} = \mathbf{A}\mathbf{x} + \mathbf{b}\)</span>이면, <span class="math inline">\(\mathbf{y} \sim \mathcal{N}(\mathbf{A}\boldsymbol{\mu} + \mathbf{b}, \mathbf{A}\mathbf{\Sigma}\mathbf{A}^T)\)</span>입니다.</p></li>
<li><p><strong>조건부 분포 (Conditional Distribution):</strong> 다변량 정규 분포의 조건부 분포 역시 정규 분포를 따릅니다. <span class="math inline">\(\mathbf{x}\)</span>를 <span class="math inline">\(\mathbf{x} = (\mathbf{x}_1, \mathbf{x}_2)^T\)</span>로 분할하고, 평균과 공분산 행렬을 다음과 같이 분할하면:</p>
<p><span class="math inline">\(\boldsymbol{\mu} = \begin{pmatrix} \boldsymbol{\mu}_1 \\ \boldsymbol{\mu}_2 \end{pmatrix}, \quad \mathbf{\Sigma} = \begin{pmatrix} \mathbf{\Sigma}_{11} &amp; \mathbf{\Sigma}_{12} \\ \mathbf{\Sigma}_{21} &amp; \mathbf{\Sigma}_{22} \end{pmatrix}\)</span></p>
<p><span class="math inline">\(\mathbf{x}_1\)</span>이 주어졌을 때 <span class="math inline">\(\mathbf{x}_2\)</span>의 조건부 분포는 다음과 같습니다.</p>
<p><span class="math inline">\(p(\mathbf{x}_2 | \mathbf{x}_1) = \mathcal{N}(\boldsymbol{\mu}_{2|1}, \mathbf{\Sigma}_{2|1})\)</span></p>
<p><span class="math inline">\(\boldsymbol{\mu}_{2|1} = \boldsymbol{\mu}_2 + \mathbf{\Sigma}_{21}\mathbf{\Sigma}_{11}^{-1}(\mathbf{x}_1 - \boldsymbol{\mu}_1)\)</span></p>
<p><span class="math inline">\(\mathbf{\Sigma}_{2|1} = \mathbf{\Sigma}_{22} - \mathbf{\Sigma}_{21}\mathbf{\Sigma}_{11}^{-1}\mathbf{\Sigma}_{12}\)</span></p></li>
<li><p><strong>주변 분포 (Marginal Distribution):</strong> 다변량 정규 분포의 주변 분포 역시 정규 분포를 따릅니다. 위와 같은 분할에서 <span class="math inline">\(\mathbf{x}_1\)</span>의 주변 분포는 다음과 같습니다. <span class="math inline">\(p(\mathbf{x}_1) = \mathcal{N}(\boldsymbol{\mu_1}, \mathbf{\Sigma}_{11})\)</span></p></li>
</ul>
</section>
<section id="가우시안-프로세스의-정의와-확률적-과정-관점에서의-해석" class="level3">
<h3 class="anchored" data-anchor-id="가우시안-프로세스의-정의와-확률적-과정-관점에서의-해석">2. 가우시안 프로세스의 정의와 확률적 과정 관점에서의 해석</h3>
<p>가우시안 프로세스는 <em>함수</em>에 대한 확률 분포입니다. 즉, 어떤 함수 <span class="math inline">\(f(x)\)</span>가 가우시안 프로세스를 따른다는 것은, 임의의 유한한 입력 점들의 집합 <span class="math inline">\(\{x_1, x_2, ..., x_n\}\)</span>에 대한 함수 값들의 벡터 <span class="math inline">\((f(x_1), f(x_2), ..., f(x_n))^T\)</span>가 다변량 정규 분포를 따른다는 것을 의미합니다.</p>
<p><strong>정의:</strong> 가우시안 프로세스는 평균 함수(mean function) <span class="math inline">\(m(x)\)</span>와 공분산 함수(covariance function, 또는 커널 함수) <span class="math inline">\(k(x, x')\)</span>로 정의됩니다.</p>
<p><span class="math inline">\(f(x) \sim \mathcal{GP}(m(x), k(x, x'))\)</span></p>
<ul>
<li><strong>평균 함수:</strong> <span class="math inline">\(m(x) = \mathbb{E}[f(x)]\)</span></li>
<li><strong>공분산 함수:</strong> <span class="math inline">\(k(x, x') = \mathbb{E}[(f(x) - m(x))(f(x') - m(x'))]\)</span></li>
</ul>
<p><strong>확률적 과정(Stochastic Process) 관점:</strong> 가우시안 프로세스는 확률적 과정의 일종으로, 인덱스 집합(index set, 여기서는 입력 공간)의 각 원소에 대해 확률 변수를 할당하는 과정입니다. 가우시안 프로세스에서는 이 확률 변수들이 결합 정규 분포(joint Gaussian distribution)를 이룹니다.</p>
</section>
<section id="커널-함수kernel-function의-역할과-다양한-커널-함수-소개" class="level3">
<h3 class="anchored" data-anchor-id="커널-함수kernel-function의-역할과-다양한-커널-함수-소개">3. 커널 함수(Kernel Function)의 역할과 다양한 커널 함수 소개</h3>
<p>커널 함수는 가우시안 프로세스에서 가장 중요한 요소 중 하나입니다. 커널 함수는 두 입력 <span class="math inline">\(x\)</span>와 <span class="math inline">\(x'\)</span> 사이의 유사도를 나타내며, 가우시안 프로세스의 성질을 결정합니다.</p>
<p><strong>핵심 역할:</strong></p>
<ul>
<li><strong>공분산 정의:</strong> 커널 함수는 함수 값들 사이의 공분산을 정의합니다. 즉, <span class="math inline">\(k(x, x')\)</span>는 <span class="math inline">\(f(x)\)</span>와 <span class="math inline">\(f(x')\)</span> 사이의 공분산을 나타냅니다.</li>
<li><strong>함수의 부드러움(Smoothness) 결정:</strong> 커널 함수는 생성되는 함수의 부드러움을 결정합니다. 예를 들어, RBF 커널은 무한히 미분 가능한 함수를 생성하는 반면, Matern 커널은 미분 가능성을 조절할 수 있습니다.</li>
<li><strong>양의 정부호성 (Positive Definiteness):</strong> 유효한 공분산 함수가 되기 위해, 커널 함수는 양의 정부호성을 만족해야 합니다. 즉, 임의의 입력 점들에 대해 생성되는 커널 행렬(kernel matrix, Gram matrix)이 양의 정부호 행렬이어야 합니다.</li>
</ul>
<p><strong>다양한 커널 함수:</strong></p>
<ul>
<li><p><strong>RBF (Radial Basis Function) 커널 (또는 Squared Exponential 커널):</strong></p>
<p><span class="math inline">\(k(x, x') = \sigma^2 \exp\left(-\frac{\|x - x'\|^2}{2l^2}\right)\)</span></p>
<ul>
<li><span class="math inline">\(\sigma^2\)</span>: 분산(variance)</li>
<li><span class="math inline">\(l\)</span>: 길이 척도(length scale)</li>
<li>매우 부드러운 함수를 생성합니다.</li>
</ul></li>
<li><p><strong>Matern 커널:</strong></p>
<p><span class="math inline">\(k(x, x') = \sigma^2 \frac{2^{1-\nu}}{\Gamma(\nu)}\left(\sqrt{2\nu}\frac{\|x - x'\|}{l}\right)^\nu K_\nu\left(\sqrt{2\nu}\frac{\|x - x'\|}{l}\right)\)</span></p>
<ul>
<li><span class="math inline">\(\nu\)</span>: 부드러움 파라미터 (smoothness parameter)</li>
<li><span class="math inline">\(K_\nu\)</span>: 수정 베셀 함수(modified Bessel function)</li>
<li><span class="math inline">\(\nu = 1/2, 3/2, 5/2\)</span>와 같이 반정수(half-integer) 값을 주로 사용합니다.</li>
<li><span class="math inline">\(\nu\)</span>가 커질수록 RBF 커널에 가까워집니다.</li>
</ul></li>
<li><p><strong>주기 함수 (Periodic) 커널:</strong></p>
<p><span class="math inline">\(k(x, x') = \sigma^2 \exp\left(-\frac{2\sin^2(\pi|x-x'|/p)}{l^2}\right)\)</span></p>
<ul>
<li><span class="math inline">\(p\)</span> : 주기</li>
</ul></li>
<li><p><strong>선형 (Linear) 커널:</strong></p>
<p><span class="math inline">\(k(x,x') = \sigma_b^2 + \sigma_v^2(x - c)(x' -c)\)</span></p></li>
</ul>
</section>
<section id="가우시안-프로세스를-이용한-회귀regression-및-분류classification-문제-해결" class="level3">
<h3 class="anchored" data-anchor-id="가우시안-프로세스를-이용한-회귀regression-및-분류classification-문제-해결">4. 가우시안 프로세스를 이용한 회귀(Regression) 및 분류(Classification) 문제 해결</h3>
<p><strong>회귀 (Regression):</strong></p>
<p>가우시안 프로세스 회귀는 주어진 훈련 데이터 <span class="math inline">\(\mathcal{D} = \{(\mathbf{x}_i, y_i)\}_{i=1}^n\)</span>를 바탕으로 새로운 입력 <span class="math inline">\(\mathbf{x}_*\)</span>에 대한 출력 <span class="math inline">\(f(\mathbf{x}_*)\)</span>를 예측하는 문제입니다. 가우시안 프로세스의 사전 분포(prior distribution)와 훈련 데이터를 결합하여 사후 분포(posterior distribution)를 계산하고, 이를 통해 예측 분포(predictive distribution)를 얻습니다.</p>
<ul>
<li><strong>사전 분포:</strong> <span class="math inline">\(f(\mathbf{x}) \sim \mathcal{GP}(0, k(\mathbf{x}, \mathbf{x}'))\)</span> (편의상 평균 함수를 0으로 가정)</li>
<li><strong>훈련 데이터:</strong> <span class="math inline">\(\mathbf{y} = (y_1, y_2, ..., y_n)^T\)</span></li>
<li><strong>커널 행렬:</strong> <span class="math inline">\(\mathbf{K} = k(\mathbf{X}, \mathbf{X})\)</span>, 여기서 <span class="math inline">\(\mathbf{X} = [\mathbf{x}_1, \mathbf{x}_2, ..., \mathbf{x}_n]\)</span></li>
<li><strong>예측 분포:</strong> <span class="math inline">\(p(f(\mathbf{x}_*) | \mathbf{y}, \mathbf{X}, \mathbf{x}_*) = \mathcal{N}(\mu_*, \sigma_*^2)\)</span>
<ul>
<li><span class="math inline">\(\mu_* = \mathbf{k}_*^T \mathbf{K}^{-1} \mathbf{y}\)</span></li>
<li><span class="math inline">\(\sigma_*^2 = k(\mathbf{x}_*, \mathbf{x}_*) - \mathbf{k}_*^T \mathbf{K}^{-1} \mathbf{k}_*\)</span></li>
<li><span class="math inline">\(\mathbf{k}_* = [k(\mathbf{x}_*, \mathbf{x}_1), k(\mathbf{x}_*, \mathbf{x}_2), ..., k(\mathbf{x}_*, \mathbf{x}_n)]^T\)</span></li>
</ul></li>
</ul>
<p><strong>분류 (Classification):</strong></p>
<p>가우시안 프로세스 분류는 잠재 함수(latent function) <span class="math inline">\(f(\mathbf{x})\)</span>를 가우시안 프로세스로 모델링하고, 이 잠재 함수를 통해 분류 확률을 정의합니다. 예를 들어, 이진 분류(binary classification) 문제에서는 로지스틱 함수(logistic function)나 프로빗 함수(probit function)를 사용하여 잠재 함수 값을 확률로 변환합니다.</p>
<ul>
<li><strong>잠재 함수:</strong> <span class="math inline">\(f(\mathbf{x}) \sim \mathcal{GP}(0, k(\mathbf{x}, \mathbf{x}'))\)</span></li>
<li><strong>이진 분류:</strong> <span class="math inline">\(p(y = 1 | f(\mathbf{x})) = \sigma(f(\mathbf{x}))\)</span> (여기서 <span class="math inline">\(\sigma\)</span>는 로지스틱 함수)</li>
</ul>
<p>분류 문제에서는 사후 분포가 닫힌 형태(closed form)로 주어지지 않기 때문에, 라플라스 근사(Laplace approximation)나 변분 추론(variational inference)과 같은 근사적인 추론 방법을 사용합니다.</p>
</section>
<section id="가우시안-프로세스의-장단점-및-딥러닝과의-비교" class="level3">
<h3 class="anchored" data-anchor-id="가우시안-프로세스의-장단점-및-딥러닝과의-비교">5. 가우시안 프로세스의 장단점 및 딥러닝과의 비교</h3>
<p><strong>장점:</strong></p>
<ul>
<li><strong>불확실성 정량화:</strong> 예측의 불확실성을 예측 분산(predictive variance) 형태로 제공합니다.</li>
<li><strong>데이터 효율성:</strong> 비교적 적은 양의 데이터로도 좋은 성능을 낼 수 있습니다.</li>
<li><strong>커널 선택의 유연성:</strong> 다양한 커널 함수를 사용하여 문제의 특성에 맞는 모델을 설계할 수 있습니다.</li>
<li><strong>베이지안 해석:</strong> 베이지안 프레임워크에서 자연스럽게 해석됩니다.</li>
</ul>
<p><strong>단점:</strong></p>
<ul>
<li><strong>계산 복잡도:</strong> 훈련 데이터의 크기 <span class="math inline">\(n\)</span>에 대해 <span class="math inline">\(O(n^3)\)</span>의 계산 복잡도를 가집니다. (역행렬 계산 때문)</li>
<li><strong>모델 선택:</strong> 적절한 커널 함수와 하이퍼파라미터를 선택하는 것이 중요하며, 이는 어려울 수 있습니다.</li>
<li><strong>고차원 입력:</strong> 고차원 입력 공간에서는 성능이 저하될 수 있습니다.</li>
</ul>
<p><strong>딥러닝과의 비교:</strong></p>
<ul>
<li><strong>데이터 요구량:</strong> 딥러닝 모델은 일반적으로 가우시안 프로세스보다 훨씬 많은 양의 데이터를 필요로 합니다.</li>
<li><strong>계산 비용:</strong> 딥러닝 모델은 훈련에는 많은 계산 비용이 들지만, 추론(inference)은 상대적으로 빠릅니다. 가우시안 프로세스는 훈련은 (데이터가 적을 때) 빠르지만, 추론은 데이터 크기에 비례하는 계산 비용이 듭니다.</li>
<li><strong>불확실성:</strong> 딥러닝 모델은 일반적으로 예측의 불확실성을 제공하지 않습니다. (물론, 베이지안 딥러닝(Bayesian deep learning)과 같은 예외도 있습니다.)</li>
<li><strong>표현력:</strong> 딥러닝 모델은 매우 복잡한 함수를 표현할 수 있는 반면, 가우시안 프로세스는 커널 함수에 의해 표현력이 제한됩니다.</li>
<li><strong>해석 가능성</strong>: 가우시안 프로세스는 커널함수를 통해 모델의 가정을 명시할 수 있고, 예측 결과의 불확실성을 정량화하여 제공합니다.</li>
</ul>
<p>최근에는 딥러닝과 가우시안 프로세스를 결합한 모델(예: Deep Kernel Learning)도 연구되고 있습니다.</p>
</section>
</section>
</div>
</div>
<section id="불확실성-처리의-수학적-기초" class="level3">
<h3 class="anchored" data-anchor-id="불확실성-처리의-수학적-기초">6.6.1 불확실성 처리의 수학적 기초</h3>
<p>일반적으로 우리는 함수를 하나의 선으로 생각하지만, 가우시안 프로세스는 이를 “가능한 여러 선들의 집합”으로 간주합니다. 수학적으로는 다음과 같습니다.</p>
<p><span class="math inline">\(f(t) \sim \mathcal{GP}(m(t), k(t,t'))\)</span></p>
<p>자전거 위치를 예로 들면 <span class="math inline">\(m(t)\)</span>는 평균 함수로 “대체로 이런 경로를 따를 것”이라는 예측을 나타냅니다. <span class="math inline">\(k(t,t')\)</span>는 공분산 함수(또는 커널)로, “서로 다른 시점의 위치가 얼마나 관련되어 있을까?”를 나타냅니다. 커널은 대표적인 것들이 몇가지 존재합니다. 가장 많이 사용되는 커널 함수 중 하나는 RBF(Radial Basis Function)입니다.</p>
<p><span class="math inline">\(k(t,t') = \sigma^2 \exp\left(-\frac{(t-t')^2}{2l^2}\right)\)</span></p>
<p>이 수식은 매우 직관적입니다. 두 시점 <span class="math inline">\(t\)</span>와 <span class="math inline">\(t'\)</span>가 가까울수록 큰 값을 가지고, 멀수록 작은 값을 가집니다. 마치 “지금 위치를 알면 잠시 후의 위치는 어느 정도 예측할 수 있지만, 먼 미래의 위치는 잘 모르겠어”와 유사합니다.</p>
<p>커널(<span class="math inline">\(K\)</span>)을 RBF라 하고 실제 예를 보겠습니다. 여러분이 자전거 공유 서비스(혹은 자율주행차도 좋습니다)를 한다고 생각해 봅시다. GPS로 관측된 몇개의 데이터만으로 자전거의 전체 이동 경로를 추정한다고 합시다.</p>
<p><strong>예측의 기본 수식</strong></p>
<p><span class="math inline">\(f_* | X, y, X_* \sim \mathcal{N}(\mu_*, \Sigma_*)\)</span></p>
<p>이 수식은 “우리가 가진 GPS 기록(<span class="math inline">\(X\)</span>, <span class="math inline">\(y\)</span>)을 바탕으로, 모르는 시점(<span class="math inline">\(X_*\)</span>)의 자전거 위치는 평균이 <span class="math inline">\(\mu_*\)</span>이고 불확실성이 <span class="math inline">\(\Sigma_*\)</span>인 정규분포를 따른다”란 의미를 표현하게 됩니다.</p>
<p><strong>위치 예측 계산</strong></p>
<p><span class="math inline">\(\mu_* = K_*K^{-1}y\)</span></p>
<p>이 수식은 자전거의 위치를 예측하는 방법을 보여줍니다. <span class="math inline">\(K_*\)</span> 는 예측하려는 시점과 GPS 기록 시점들 사이의 ’시간적 연관성’을 <span class="math inline">\(K^{-1}\)</span>는 GPS 기록들 사이의 관계를 고려한 ’가중치 조정’을 <span class="math inline">\(y\)</span>는 실제 GPS로 기록된 위치들 나타냅니다. 예를 들어, 오후 2시 15분의 위치를 예측할 때: 1. 2시 10분과 2시 20분의 GPS 기록(<span class="math inline">\(y\)</span>)을 참고하되 2. 각 시점과의 시간 차이(<span class="math inline">\(K_*\)</span>)를 고려하고 3. GPS 기록들 간의 시간적 연속성(<span class="math inline">\(K^{-1}\)</span>)도 반영합니다</p>
<p><strong>불확실성 추정</strong></p>
<p><span class="math inline">\(\Sigma_* = K_{**} - K_*K^{-1}K_*^T\)</span></p>
<p>이 수식은 위치 예측의 불확실성을 계산합니다. <span class="math inline">\(K_{**}\)</span>는 예측 시점 자체의 ’기본 불확실성’을, <span class="math inline">\(K_*K^{-1}K_*^T\)</span>는 GPS 기록으로 인해 ’줄어드는 불확실성’을 계산합니다. <span class="math inline">\(K\)</span>는 기존 관측 데이터들 사이의 관계를 나타내는 행렬이므로 데이터가 촘촘할수록 값은 커지게 됩니다. <span class="math inline">\(K_*\)</span>는 새로운 예측 지점과 기존 데이터 간의 관계를 나타내므로 데이터가 촘촘할수록 더 많은 주변 데이터와의 관계를 고려할 수 있습니다</p>
<p>실제 상황으로 설명하면: 1. 처음에는 자전거가 어디든 갈 수 있다고 가정(<span class="math inline">\(K_{**}\)</span>가 큼) 2. GPS 기록이 많을수록(<span class="math inline">\(K_*\)</span>가 큼) 3. 그리고 기록들이 일관적일수록(<span class="math inline">\(K^{-1}\)</span>이 안정적 일수록) 4. 위치 추정의 불확실성이 감소합니다</p>
<p><strong>데이터에 따른 수식효과</strong> GPS 데이터량에 따라 불확실성을 포함한 예측은 다음과 같이 나타나게 됩니다. 1. GPS 기록이 빈번한 구간: 낮은 불확실성 - <span class="math inline">\(K_*\)</span>가 크고 데이터가 많아 <span class="math inline">\(K_*K^{-1}K_*^T\)</span>가 큼 - 따라서 <span class="math inline">\(\Sigma_*\)</span>가 작아져서 경로 추정이 정확함 2. GPS 기록이 드문 구간: 높은 불확실성 - <span class="math inline">\(K_*\)</span>가 작고 데이터가 적어 <span class="math inline">\(K_*K^{-1}K_*^T\)</span>가 작음 - 따라서 <span class="math inline">\(\Sigma_*\)</span>가 커서 경로 추정의 불확실성이 큼</p>
<p>간단히 생각하면 <span class="math inline">\(K\)</span>는 촘촘한 시간 간격 데이터가 많을 수록 커지게 되고 따라서 불확실성은 낮아지게 됩니다.</p>
<p>자전거 경로를 예측하는 예제로 이해를 해봅시다.</p>
<div id="cell-58" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a><span class="co"># 시각화 스타일 설정</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>sns.set_style(<span class="st">"whitegrid"</span>)</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>plt.rcParams[<span class="st">'font.size'</span>] <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a><span class="co"># 데이터셋 1: 5개 관측점</span></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>time1 <span class="op">=</span> np.array([<span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">8</span>, <span class="dv">10</span>]).reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>position1 <span class="op">=</span> np.array([<span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">4</span>])</span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a><span class="co"># 데이터셋 2: 8개 관측점</span></span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a>time2 <span class="op">=</span> np.array([<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">8</span>, <span class="dv">10</span>]).reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a>position2 <span class="op">=</span> np.array([<span class="dv">0</span>, <span class="dv">1</span>, <span class="fl">2.5</span>, <span class="fl">1.5</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">4</span>])  <span class="co"># 더 큰 변동성 추가</span></span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-17"><a href="#cb30-17" aria-hidden="true" tabindex="-1"></a><span class="co"># 예측할 시간점 생성: 0~10분 구간을 100개로 분할</span></span>
<span id="cb30-18"><a href="#cb30-18" aria-hidden="true" tabindex="-1"></a>time_pred <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">100</span>).reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb30-19"><a href="#cb30-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-20"><a href="#cb30-20" aria-hidden="true" tabindex="-1"></a><span class="co"># RBF 커널 함수 정의</span></span>
<span id="cb30-21"><a href="#cb30-21" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> kernel(T1, T2, l<span class="op">=</span><span class="fl">2.0</span>):</span>
<span id="cb30-22"><a href="#cb30-22" aria-hidden="true" tabindex="-1"></a>    sqdist <span class="op">=</span> np.<span class="bu">sum</span>(T1<span class="op">**</span><span class="dv">2</span>, <span class="dv">1</span>).reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>) <span class="op">+</span> np.<span class="bu">sum</span>(T2<span class="op">**</span><span class="dv">2</span>, <span class="dv">1</span>) <span class="op">-</span> <span class="dv">2</span> <span class="op">*</span> np.dot(T1, T2.T)</span>
<span id="cb30-23"><a href="#cb30-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.exp(<span class="op">-</span><span class="fl">0.5</span> <span class="op">*</span> sqdist <span class="op">/</span> l<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb30-24"><a href="#cb30-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-25"><a href="#cb30-25" aria-hidden="true" tabindex="-1"></a><span class="co"># 가우시안 프로세스 예측 함수</span></span>
<span id="cb30-26"><a href="#cb30-26" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> predict_gp(time, position, time_pred):</span>
<span id="cb30-27"><a href="#cb30-27" aria-hidden="true" tabindex="-1"></a>    K <span class="op">=</span> kernel(time, time)</span>
<span id="cb30-28"><a href="#cb30-28" aria-hidden="true" tabindex="-1"></a>    K_star <span class="op">=</span> kernel(time_pred, time)</span>
<span id="cb30-29"><a href="#cb30-29" aria-hidden="true" tabindex="-1"></a>    K_star_star <span class="op">=</span> kernel(time_pred, time_pred)</span>
<span id="cb30-30"><a href="#cb30-30" aria-hidden="true" tabindex="-1"></a>    mu_star <span class="op">=</span> K_star.dot(np.linalg.inv(K)).dot(position)</span>
<span id="cb30-31"><a href="#cb30-31" aria-hidden="true" tabindex="-1"></a>    sigma_star <span class="op">=</span> K_star_star <span class="op">-</span> K_star.dot(np.linalg.inv(K)).dot(K_star.T)</span>
<span id="cb30-32"><a href="#cb30-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> mu_star, sigma_star</span>
<span id="cb30-33"><a href="#cb30-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-34"><a href="#cb30-34" aria-hidden="true" tabindex="-1"></a><span class="co"># 두 데이터셋에 대한 예측 수행</span></span>
<span id="cb30-35"><a href="#cb30-35" aria-hidden="true" tabindex="-1"></a>mu1, sigma1 <span class="op">=</span> predict_gp(time1, position1, time_pred)</span>
<span id="cb30-36"><a href="#cb30-36" aria-hidden="true" tabindex="-1"></a>mu2, sigma2 <span class="op">=</span> predict_gp(time2, position2, time_pred)</span>
<span id="cb30-37"><a href="#cb30-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-38"><a href="#cb30-38" aria-hidden="true" tabindex="-1"></a><span class="co"># 2개의 서브플롯 생성</span></span>
<span id="cb30-39"><a href="#cb30-39" aria-hidden="true" tabindex="-1"></a>fig, (ax1, ax2) <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">16</span>, <span class="dv">4</span>))</span>
<span id="cb30-40"><a href="#cb30-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-41"><a href="#cb30-41" aria-hidden="true" tabindex="-1"></a><span class="co"># 첫 번째 그래프 (5개 데이터)</span></span>
<span id="cb30-42"><a href="#cb30-42" aria-hidden="true" tabindex="-1"></a>ax1.fill_between(time_pred.flatten(),</span>
<span id="cb30-43"><a href="#cb30-43" aria-hidden="true" tabindex="-1"></a>                mu1 <span class="op">-</span> <span class="dv">2</span><span class="op">*</span>np.sqrt(np.diag(sigma1)),</span>
<span id="cb30-44"><a href="#cb30-44" aria-hidden="true" tabindex="-1"></a>                mu1 <span class="op">+</span> <span class="dv">2</span><span class="op">*</span>np.sqrt(np.diag(sigma1)),</span>
<span id="cb30-45"><a href="#cb30-45" aria-hidden="true" tabindex="-1"></a>                color<span class="op">=</span><span class="st">'blue'</span>, alpha<span class="op">=</span><span class="fl">0.2</span>, label<span class="op">=</span><span class="st">'95</span><span class="sc">% c</span><span class="st">onfidence interval'</span>)</span>
<span id="cb30-46"><a href="#cb30-46" aria-hidden="true" tabindex="-1"></a>ax1.plot(time_pred, mu1, <span class="st">'b-'</span>, linewidth<span class="op">=</span><span class="fl">1.5</span>, label<span class="op">=</span><span class="st">'Predicted path'</span>)</span>
<span id="cb30-47"><a href="#cb30-47" aria-hidden="true" tabindex="-1"></a>ax1.plot(time1, position1, <span class="st">'ro'</span>, markersize<span class="op">=</span><span class="dv">6</span>, label<span class="op">=</span><span class="st">'GPS records'</span>)</span>
<span id="cb30-48"><a href="#cb30-48" aria-hidden="true" tabindex="-1"></a>ax1.set_xlabel(<span class="st">'Time (min)'</span>)</span>
<span id="cb30-49"><a href="#cb30-49" aria-hidden="true" tabindex="-1"></a>ax1.set_ylabel(<span class="st">'Position (km)'</span>)</span>
<span id="cb30-50"><a href="#cb30-50" aria-hidden="true" tabindex="-1"></a>ax1.set_title(<span class="st">'Route Estimation (5 GPS points)'</span>)</span>
<span id="cb30-51"><a href="#cb30-51" aria-hidden="true" tabindex="-1"></a>ax1.legend(fontsize<span class="op">=</span><span class="dv">8</span>)</span>
<span id="cb30-52"><a href="#cb30-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-53"><a href="#cb30-53" aria-hidden="true" tabindex="-1"></a><span class="co"># 두 번째 그래프 (8개 데이터)</span></span>
<span id="cb30-54"><a href="#cb30-54" aria-hidden="true" tabindex="-1"></a>ax2.fill_between(time_pred.flatten(),</span>
<span id="cb30-55"><a href="#cb30-55" aria-hidden="true" tabindex="-1"></a>                mu2 <span class="op">-</span> <span class="dv">2</span><span class="op">*</span>np.sqrt(np.diag(sigma2)),</span>
<span id="cb30-56"><a href="#cb30-56" aria-hidden="true" tabindex="-1"></a>                mu2 <span class="op">+</span> <span class="dv">2</span><span class="op">*</span>np.sqrt(np.diag(sigma2)),</span>
<span id="cb30-57"><a href="#cb30-57" aria-hidden="true" tabindex="-1"></a>                color<span class="op">=</span><span class="st">'blue'</span>, alpha<span class="op">=</span><span class="fl">0.2</span>, label<span class="op">=</span><span class="st">'95</span><span class="sc">% c</span><span class="st">onfidence interval'</span>)</span>
<span id="cb30-58"><a href="#cb30-58" aria-hidden="true" tabindex="-1"></a>ax2.plot(time_pred, mu2, <span class="st">'b-'</span>, linewidth<span class="op">=</span><span class="fl">1.5</span>, label<span class="op">=</span><span class="st">'Predicted path'</span>)</span>
<span id="cb30-59"><a href="#cb30-59" aria-hidden="true" tabindex="-1"></a>ax2.plot(time2, position2, <span class="st">'ro'</span>, markersize<span class="op">=</span><span class="dv">6</span>, label<span class="op">=</span><span class="st">'GPS records'</span>)</span>
<span id="cb30-60"><a href="#cb30-60" aria-hidden="true" tabindex="-1"></a>ax2.set_xlabel(<span class="st">'Time (min)'</span>)</span>
<span id="cb30-61"><a href="#cb30-61" aria-hidden="true" tabindex="-1"></a>ax2.set_ylabel(<span class="st">'Position (km)'</span>)</span>
<span id="cb30-62"><a href="#cb30-62" aria-hidden="true" tabindex="-1"></a>ax2.set_title(<span class="st">'Route Estimation (8 GPS points)'</span>)</span>
<span id="cb30-63"><a href="#cb30-63" aria-hidden="true" tabindex="-1"></a>ax2.legend(fontsize<span class="op">=</span><span class="dv">8</span>)</span>
<span id="cb30-64"><a href="#cb30-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-65"><a href="#cb30-65" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb30-66"><a href="#cb30-66" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="06_과적합과 해결 기법의 발전_files/figure-html/cell-24-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>위 코드는 두 가지 시나리오(5개 관측점, 8개 관측점)에서 GP를 사용하여 자전거 경로를 추정하는 예제입니다. 각 그래프에서 파란색 실선은 예측된 평균 경로, 파란색 음영 영역은 95% 신뢰 구간(confidence interval)을 나타냅니다.</p>
<ul>
<li><strong>데이터가 적을 때</strong> (왼쪽 그래프): GPS 기록이 듬성듬성 있기 때문에, 예측의 불확실성(신뢰 구간의 폭)이 큽니다.</li>
<li><strong>데이터가 많을 때</strong> (오른쪽 그래프): GPS 기록이 더 촘촘해지면서, 예측의 불확실성이 줄어들고, 예측된 경로가 실제 경로에 더 가까워집니다.</li>
</ul>
<p>이처럼 GP는 예측 결과뿐만 아니라 예측의 불확실성까지 함께 제공하므로, 의사 결정 과정에서 불확실성을 고려해야 하는 다양한 분야(예: 자율 주행, 로봇 제어, 의료 진단)에서 유용하게 활용될 수 있습니다.</p>
</section>
<section id="현대적-응용" class="level3">
<h3 class="anchored" data-anchor-id="현대적-응용">6.6.2 현대적 응용</h3>
<p>가우시안 프로세스는 로봇 제어, 센서 네트워크 최적화, 분자 구조 예측, 기후 모델링, 천체 물리학 데이터 분석 등 다양한 과학/공학 분야에서 응용되고 있습니다. 머신러닝에서의 대표적인 응용은 이미 살펴본 하이퍼파라미터 최적화입니다. 또 다른 불확실성을 포함한 예측이 필요한 대표적인 분야는 자율 주행 자동차입니다. 상대 차량의 미래 위치를 예측해서 불확실성이 큰 구간에서는 더 방어적으로 운전하게 합니다. 또한, 환자 상태 변화를 예측하는 의료 분야, 주가를 예측하고 불확실성에 따른 리스크 관리를 하는 자산 시장 분야에서도 널리 응용됩니다. 최근에는 강화 학습(reinforcement learning) 분야와 딥러닝에서 생성 모델(generative model)과의 결합, 인과 관계 추론(causal inference), 메타 학습(meta-learning) 등에서 GP 응용이 활발히 연구되고 있습니다.</p>
</section>
<section id="심층-커널-학습deep-kernel-learning" class="level3">
<h3 class="anchored" data-anchor-id="심층-커널-학습deep-kernel-learning">6.6.3 심층 커널 학습(Deep Kernel Learning)</h3>
<p>가우시안 프로세스에서 가장 중요한 것은 커널(공분산 함수)입니다. 딥러닝은 표현(representation)을 데이터로부터 학습하는 데 강점이 있습니다. GP의 예측 능력과 딥러닝의 표현 학습 능력을 효율적으로 결합하려는 시도는 자연스러운 연구 방향입니다. 대표적인 방법이 커널을 RBF 커널처럼 미리 정의하는 대신, 신경망을 사용하여 데이터로부터 직접 학습하는 심층 커널 학습(Deep Kernel Learning, DKL)입니다.</p>
<p>DKL의 일반적인 구조는 다음과 같습니다.</p>
<ol type="1">
<li><strong>특징 추출 (Feature Extraction)</strong>: 입력 데이터는 먼저 심층 신경망(일반적으로 CNN 또는 Transformer)을 통과하여 저차원의 특징 벡터(feature vector)로 변환됩니다.</li>
<li><strong>커널 계산 (Kernel Computation)</strong>: 추출된 특징 벡터를 입력으로 받아, 가우시안 프로세스의 커널 함수(예: RBF 커널)를 사용하여 커널 행렬을 계산합니다.</li>
<li><strong>가우시안 프로세스 (Gaussian Process)</strong>: 계산된 커널 행렬과 훈련 데이터를 사용하여 가우시안 프로세스 모델을 학습하고, 새로운 입력에 대한 예측(평균 및 분산)을 수행합니다. DKL은 신경망을 통해 데이터로부터 유용한 특징 표현과 데이터 간의 유사도를 동시에 학습할 수 있다는 장점을 가집니다. 이를 통해 복잡한 데이터(예: 이미지, 그래프, 텍스트)에 대해서도 불확실성을 고려한 예측을 수행할 수 있습니다.</li>
</ol>
<p>DKL은 다양한 분야에서 활용되고 있습니다.</p>
<ul>
<li><strong>이미지 분류 (Image Classification)</strong>: CNN을 사용하여 이미지 특징을 추출하고, GP를 사용하여 분류를 수행합니다.</li>
<li><strong>그래프 분류 (Graph Classification)</strong>: 그래프 신경망(Graph Neural Network, GNN)을 사용하여 그래프 구조에서 특징을 추출하고, GP를 사용하여 그래프 분류를 수행합니다.</li>
<li><strong>분자 특성 예측 (Molecular Property Prediction)</strong>: 분자 그래프를 입력으로 받아, 분자의 특성(예: 용해도, 독성)을 예측합니다.</li>
<li><strong>시계열 예측 (Time Series Forecasting)</strong>: RNN을 사용하여 시계열 데이터의 특징을 추출하고, GP를 사용하여 미래 값을 예측합니다. 여기서는 DKL의 간단한 예제를 실행해보고, 파트 2에서 더 자세한 내용과 응용 사례를 살펴보겠습니다.</li>
</ul>
<p><strong>심층 커널 네트워크</strong></p>
<p>먼저 심층 커널 네트워크를 정의합니다. 커널 네트워크는 커널 함수를 학습하는 신경망입니다. 이 신경망은 입력 데이터를 받아서 특징 표현을 출력합니다. 이 특징 표현은 커널 행렬을 계산하는 데 사용됩니다.</p>
<div id="cell-60" class="cell" data-execution_count="2">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.nn <span class="im">as</span> nn</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.optim <span class="im">as</span> optim</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> torch.distributions <span class="im">import</span> Normal</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Set seed for reproducibility</span></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>torch.manual_seed(<span class="dv">42</span>)</span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">42</span>)</span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Define a neural network to learn the kernel</span></span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> DeepKernel(nn.Module):</span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, input_dim, hidden_dim, output_dim):</span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>(DeepKernel, <span class="va">self</span>).<span class="fu">__init__</span>()</span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.fc1 <span class="op">=</span> nn.Linear(input_dim, hidden_dim)</span>
<span id="cb31-18"><a href="#cb31-18" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.fc2 <span class="op">=</span> nn.Linear(hidden_dim, hidden_dim)</span>
<span id="cb31-19"><a href="#cb31-19" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.fc3 <span class="op">=</span> nn.Linear(hidden_dim, output_dim)</span>
<span id="cb31-20"><a href="#cb31-20" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.activation <span class="op">=</span> nn.ReLU()</span>
<span id="cb31-21"><a href="#cb31-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-22"><a href="#cb31-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, x):</span>
<span id="cb31-23"><a href="#cb31-23" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> <span class="va">self</span>.activation(<span class="va">self</span>.fc1(x))</span>
<span id="cb31-24"><a href="#cb31-24" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> <span class="va">self</span>.activation(<span class="va">self</span>.fc2(x))</span>
<span id="cb31-25"><a href="#cb31-25" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> <span class="va">self</span>.fc3(x)  <span class="co"># No activation on the final layer</span></span>
<span id="cb31-26"><a href="#cb31-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>심층 커널 신경망의 입력은 일반적으로 2D 텐서로, 첫 번째 차원은 배치 크기, 두 번째 차원은 입력 데이터의 차원입니다. 출력은 (배치 크기, 특징 표현 차원) 형태의 2D 텐서입니다.</p>
<p><strong>GP 레이어 정의</strong></p>
<p>GP 레이어는 심층 커널 네트워크의 출력을 받아 커널 행렬을 계산하고, 예측 분포를 계산합니다.</p>
<div id="cell-62" class="cell" data-execution_count="3">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.nn <span class="im">as</span> nn</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Define the Gaussian Process layer</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> GaussianProcessLayer(nn.Module):</span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, num_dim, num_data):</span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>(GaussianProcessLayer, <span class="va">self</span>).<span class="fu">__init__</span>()</span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.num_dim <span class="op">=</span> num_dim</span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.num_data <span class="op">=</span> num_data</span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.lengthscale <span class="op">=</span> nn.Parameter(torch.ones(num_dim))  <span class="co"># Length-scale for each dimension</span></span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.noise_var <span class="op">=</span> nn.Parameter(torch.ones(<span class="dv">1</span>))  <span class="co"># Noise variance</span></span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.outputscale <span class="op">=</span> nn.Parameter(torch.ones(<span class="dv">1</span>))  <span class="co"># Output scale</span></span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, x, y):</span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Calculate the kernel matrix (using RBF kernel)</span></span>
<span id="cb32-17"><a href="#cb32-17" aria-hidden="true" tabindex="-1"></a>        dist_matrix <span class="op">=</span> torch.cdist(x, x)  <span class="co"># Pairwise distances between inputs</span></span>
<span id="cb32-18"><a href="#cb32-18" aria-hidden="true" tabindex="-1"></a>        kernel_matrix <span class="op">=</span> <span class="va">self</span>.outputscale <span class="op">*</span> torch.exp(<span class="op">-</span><span class="fl">0.5</span> <span class="op">*</span> dist_matrix<span class="op">**</span><span class="dv">2</span> <span class="op">/</span> <span class="va">self</span>.lengthscale<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb32-19"><a href="#cb32-19" aria-hidden="true" tabindex="-1"></a>        kernel_matrix <span class="op">+=</span> <span class="va">self</span>.noise_var <span class="op">*</span> torch.eye(<span class="va">self</span>.num_data)</span>
<span id="cb32-20"><a href="#cb32-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-21"><a href="#cb32-21" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Calculate the predictive distribution (using Cholesky decomposition)</span></span>
<span id="cb32-22"><a href="#cb32-22" aria-hidden="true" tabindex="-1"></a>        L <span class="op">=</span> torch.linalg.cholesky(kernel_matrix)</span>
<span id="cb32-23"><a href="#cb32-23" aria-hidden="true" tabindex="-1"></a>        alpha <span class="op">=</span> torch.cholesky_solve(y.unsqueeze(<span class="op">-</span><span class="dv">1</span>), L)  <span class="co"># Add unsqueeze for correct shape</span></span>
<span id="cb32-24"><a href="#cb32-24" aria-hidden="true" tabindex="-1"></a>        predictive_mean <span class="op">=</span> torch.matmul(kernel_matrix, alpha).squeeze(<span class="op">-</span><span class="dv">1</span>) <span class="co"># Remove extra dimension</span></span>
<span id="cb32-25"><a href="#cb32-25" aria-hidden="true" tabindex="-1"></a>        v <span class="op">=</span> torch.linalg.solve_triangular(L, kernel_matrix, upper<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb32-26"><a href="#cb32-26" aria-hidden="true" tabindex="-1"></a>        predictive_var <span class="op">=</span> kernel_matrix <span class="op">-</span> torch.matmul(v.T, v)</span>
<span id="cb32-27"><a href="#cb32-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-28"><a href="#cb32-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-29"><a href="#cb32-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> predictive_mean, predictive_var</span>
<span id="cb32-30"><a href="#cb32-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-31"><a href="#cb32-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> predictive_mean, predictive_var</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>GP 레이어의 입력은 (배치 크기, 특징 표현 차원) 형태의 2D 텐서입니다. 출력은 예측 평균과 분산을 포함하는 튜플입니다. 커널 행렬 계산에는 RBF 커널을 사용하며, 예측 분포 계산에는 촐레스키 분해(Cholesky decomposition)를 활용하여 계산 효율성을 높였습니다. <code>y.unsqueeze(-1)</code>와 <code>.squeeze(-1)</code>은 y와 커널 행렬 간의 차원을 맞추기 위한 것입니다.</p>
<div id="cell-64" class="cell" data-execution_count="4">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 데이터를 생성</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">10</span>, <span class="dv">10</span>, <span class="dv">100</span>)</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> np.sin(x) <span class="op">+</span> <span class="fl">0.1</span> <span class="op">*</span> np.random.randn(<span class="dv">100</span>)</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a><span class="co"># 데이터를 텐서로 변환</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>x_tensor <span class="op">=</span> torch.tensor(x, dtype<span class="op">=</span>torch.float32).unsqueeze(<span class="op">-</span><span class="dv">1</span>)  <span class="co"># (100,) -&gt; (100, 1)</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>y_tensor <span class="op">=</span> torch.tensor(y, dtype<span class="op">=</span>torch.float32)  <span class="co"># (100,)</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a><span class="co"># 딥 커널과 GP 레이어를 초기화</span></span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a>deep_kernel <span class="op">=</span> DeepKernel(input_dim<span class="op">=</span><span class="dv">1</span>, hidden_dim<span class="op">=</span><span class="dv">50</span>, output_dim<span class="op">=</span><span class="dv">1</span>)  <span class="co"># output_dim=1로 수정</span></span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a>gp_layer <span class="op">=</span> GaussianProcessLayer(num_dim<span class="op">=</span><span class="dv">1</span>, num_data<span class="op">=</span><span class="bu">len</span>(x))</span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true" tabindex="-1"></a><span class="co"># 손실 함수와 최적화기를 정의</span></span>
<span id="cb33-15"><a href="#cb33-15" aria-hidden="true" tabindex="-1"></a>loss_fn <span class="op">=</span> nn.MSELoss()  <span class="co"># Use MSE loss</span></span>
<span id="cb33-16"><a href="#cb33-16" aria-hidden="true" tabindex="-1"></a>optimizer <span class="op">=</span> optim.Adam(<span class="bu">list</span>(deep_kernel.parameters()) <span class="op">+</span> <span class="bu">list</span>(gp_layer.parameters()), lr<span class="op">=</span><span class="fl">0.01</span>)</span>
<span id="cb33-17"><a href="#cb33-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-18"><a href="#cb33-18" aria-hidden="true" tabindex="-1"></a>num_epochs <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb33-19"><a href="#cb33-19" aria-hidden="true" tabindex="-1"></a><span class="co"># 모델을 학습</span></span>
<span id="cb33-20"><a href="#cb33-20" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> epoch <span class="kw">in</span> <span class="bu">range</span>(num_epochs):</span>
<span id="cb33-21"><a href="#cb33-21" aria-hidden="true" tabindex="-1"></a>    optimizer.zero_grad()</span>
<span id="cb33-22"><a href="#cb33-22" aria-hidden="true" tabindex="-1"></a>    kernel_output <span class="op">=</span> deep_kernel(x_tensor)</span>
<span id="cb33-23"><a href="#cb33-23" aria-hidden="true" tabindex="-1"></a>    predictive_mean, _ <span class="op">=</span> gp_layer(kernel_output, y_tensor) <span class="co"># predictive_var는 사용 안함</span></span>
<span id="cb33-24"><a href="#cb33-24" aria-hidden="true" tabindex="-1"></a>    loss <span class="op">=</span> loss_fn(predictive_mean, y_tensor)  <span class="co"># Use predictive_mean here</span></span>
<span id="cb33-25"><a href="#cb33-25" aria-hidden="true" tabindex="-1"></a>    loss.backward()</span>
<span id="cb33-26"><a href="#cb33-26" aria-hidden="true" tabindex="-1"></a>    optimizer.step()</span>
<span id="cb33-27"><a href="#cb33-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(epoch <span class="op">%</span> <span class="dv">10</span> <span class="op">==</span> <span class="dv">0</span>):</span>
<span id="cb33-28"><a href="#cb33-28" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f'Epoch </span><span class="sc">{</span>epoch<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">, Loss: </span><span class="sc">{</span>loss<span class="sc">.</span>item()<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb33-29"><a href="#cb33-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-30"><a href="#cb33-30" aria-hidden="true" tabindex="-1"></a><span class="co"># 예측을 수행</span></span>
<span id="cb33-31"><a href="#cb33-31" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> torch.no_grad():</span>
<span id="cb33-32"><a href="#cb33-32" aria-hidden="true" tabindex="-1"></a>    kernel_output <span class="op">=</span> deep_kernel(x_tensor)</span>
<span id="cb33-33"><a href="#cb33-33" aria-hidden="true" tabindex="-1"></a>    predictive_mean, predictive_var <span class="op">=</span> gp_layer(kernel_output, y_tensor)</span>
<span id="cb33-34"><a href="#cb33-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-35"><a href="#cb33-35" aria-hidden="true" tabindex="-1"></a><span class="co"># 결과를 시각화</span></span>
<span id="cb33-36"><a href="#cb33-36" aria-hidden="true" tabindex="-1"></a>sns.<span class="bu">set</span>()</span>
<span id="cb33-37"><a href="#cb33-37" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb33-38"><a href="#cb33-38" aria-hidden="true" tabindex="-1"></a>plt.plot(x, y, <span class="st">'bo'</span>, label<span class="op">=</span><span class="st">'Training Data'</span>)</span>
<span id="cb33-39"><a href="#cb33-39" aria-hidden="true" tabindex="-1"></a>plt.plot(x, predictive_mean.numpy(), <span class="st">'r-'</span>, label<span class="op">=</span><span class="st">'Predictive Mean'</span>)</span>
<span id="cb33-40"><a href="#cb33-40" aria-hidden="true" tabindex="-1"></a>plt.fill_between(x, predictive_mean.numpy() <span class="op">-</span> <span class="fl">1.96</span> <span class="op">*</span> np.sqrt(predictive_var.numpy().diagonal()),</span>
<span id="cb33-41"><a href="#cb33-41" aria-hidden="true" tabindex="-1"></a>                 predictive_mean.numpy() <span class="op">+</span> <span class="fl">1.96</span> <span class="op">*</span> np.sqrt(predictive_var.numpy().diagonal()),</span>
<span id="cb33-42"><a href="#cb33-42" aria-hidden="true" tabindex="-1"></a>                 alpha<span class="op">=</span><span class="fl">0.2</span>, label<span class="op">=</span><span class="st">'95% CI'</span>)</span>
<span id="cb33-43"><a href="#cb33-43" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb33-44"><a href="#cb33-44" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Epoch 1, Loss: 4.3467857893837725e-13
Epoch 11, Loss: 3.1288711313699757e-13
Epoch 21, Loss: 3.9212150236903054e-13
Epoch 31, Loss: 4.184870765894244e-13
Epoch 41, Loss: 2.9785689973499396e-13
Epoch 51, Loss: 3.8607078688482344e-13
Epoch 61, Loss: 3.9107123572454383e-13
Epoch 71, Loss: 2.359286811054462e-13
Epoch 81, Loss: 3.4729958167147024e-13
Epoch 91, Loss: 2.7600995490886793e-13</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>/tmp/ipykernel_1408185/2425174321.py:40: RuntimeWarning: invalid value encountered in sqrt
  plt.fill_between(x, predictive_mean.numpy() - 1.96 * np.sqrt(predictive_var.numpy().diagonal()),
/tmp/ipykernel_1408185/2425174321.py:41: RuntimeWarning: invalid value encountered in sqrt
  predictive_mean.numpy() + 1.96 * np.sqrt(predictive_var.numpy().diagonal()),</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="06_과적합과 해결 기법의 발전_files/figure-html/cell-27-output-3.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>모델 학습에는 평균 제곱 오차(Mean Squared Error, MSE) 손실 함수를 사용하고, Adam 옵티마이저를 사용하여 딥 커널 네트워크와 GP 레이어의 파라미터를 동시에 학습시킵니다.</p>
<section id="dkl의-가능성과-한계" class="level4">
<h4 class="anchored" data-anchor-id="dkl의-가능성과-한계">6.6.4 DKL의 가능성과 한계</h4>
<p>앞선 예제는 심층 커널 학습(Deep Kernel Learning, DKL)의 기본적인 아이디어를 보여줍니다. 딥러닝 모델(<code>DeepKernel</code> 클래스)을 사용하여 입력 데이터의 특징을 추출하고, 이 특징을 사용하여 가우시안 프로세스(GP)의 커널을 계산합니다. 그리고 GP를 사용하여 예측의 평균과 분산(불확실성)을 계산합니다. 이처럼 DKL은 딥러닝의 표현 학습 능력과 GP의 불확실성 추정 능력을 결합하여, 복잡한 데이터에서도 신뢰성 있는 예측을 가능하게 합니다.</p>
<p><strong>DKL의 가능성:</strong></p>
<ul>
<li><strong>데이터 효율성:</strong> GP는 데이터가 적을 때에도 잘 작동하는 경향이 있습니다. DKL은 딥러닝의 강력한 특징 추출 능력과 GP의 데이터 효율성을 결합하여, 적은 데이터로도 좋은 성능을 낼 수 있습니다.</li>
<li><strong>불확실성 추정:</strong> DKL은 예측의 불확실성을 정량화할 수 있습니다. 이는 안전성이 중요한 응용 분야(예: 의료 진단, 자율 주행)에서 매우 유용합니다.</li>
<li><strong>유연성:</strong> DKL은 다양한 종류의 데이터(이미지, 텍스트, 그래프 등)에 적용할 수 있습니다. 신경망 아키텍처를 자유롭게 선택하여 문제에 맞는 특징 추출기를 설계할 수 있습니다.</li>
<li><strong>베이지안 최적화와의 결합:</strong> DKL은 베이지안 최적화와 결합하여 모델의 하이퍼파라미터를 효율적으로 튜닝할 수 있습니다.</li>
</ul>
<p><strong>DKL의 한계:</strong></p>
<ul>
<li><strong>계산 비용:</strong> GP는 여전히 계산 비용이 높습니다. 특히, 훈련 데이터가 많아지면 커널 행렬의 크기가 커져서 계산이 어려워집니다.</li>
<li><strong>신경망 설계:</strong> DKL의 성능은 특징 추출기(신경망)의 설계에 크게 의존합니다. 적절한 신경망 아키텍처를 선택하는 것은 여전히 어려운 문제입니다.</li>
<li><strong>이론적 이해 부족:</strong> DKL의 이론적 분석은 아직 초기 단계입니다. 왜 DKL이 잘 작동하는지, 어떤 조건에서 좋은 성능을 보이는지에 대한 더 많은 연구가 필요합니다.</li>
</ul>
</section>
<section id="맺음말" class="level4">
<h4 class="anchored" data-anchor-id="맺음말">맺음말</h4>
<p>이 장에서는 딥러닝 모델의 과적합 문제를 해결하기 위한 다양한 기법들을 살펴보았습니다. L1/L2 규제, 드롭아웃, 배치 정규화와 같은 전통적인 방법부터, 베이지안 최적화, 가우시안 프로세스, 그리고 심층 커널 학습과 같은 고급 기법까지, 딥러닝 연구는 모델의 일반화 성능을 향상시키기 위해 끊임없이 발전해 왔습니다.</p>
<p>과적합은 딥러닝 모델이 훈련 데이터에만 지나치게 특화되어 새로운 데이터에 대한 예측 성능이 떨어지는 현상입니다. 이는 모델의 복잡도가 너무 높거나, 훈련 데이터가 부족하거나, 데이터에 노이즈가 많을 때 발생할 수 있습니다. 과적합을 방지하는 것은 딥러닝 모델을 실제 문제에 적용하는 데 있어 매우 중요한 과제입니다.</p>
<p>이 장에서 소개된 다양한 기법들은 각기 다른 방식으로 과적합 문제에 접근합니다.</p>
<ul>
<li><strong>규제:</strong> 모델의 복잡도에 페널티를 부여하여 가중치가 너무 커지는 것을 방지합니다. (L1, L2, Elastic Net)</li>
<li><strong>드롭아웃:</strong> 학습 과정에서 무작위로 뉴런을 제거하여, 특정 뉴런이나 뉴런 간의 조합에 모델이 의존하는 것을 막습니다.</li>
<li><strong>배치 정규화:</strong> 각 층의 입력을 정규화하여, 학습을 안정화하고 가속화합니다.</li>
<li><strong>하이퍼파라미터 최적화:</strong> 베이지안 최적화와 같은 방법을 사용하여 모델의 성능을 최적화하는 하이퍼파라미터 조합을 찾습니다.</li>
<li><strong>가우시안 프로세스, 심층커널학습</strong>: 불확실성을 명시적으로 모델링하여, 좀 더 신뢰도 있는 예측을 합니다.</li>
</ul>
<p>이러한 기법들을 적절히 조합하고, 문제의 특성에 맞게 튜닝하는 것은 딥러닝 엔지니어의 중요한 역량 중 하나입니다. “모든 경우에 완벽한” 단 하나의 해결책은 없으며, 실험과 분석을 통해 최적의 방법을 찾아나가야 합니다. 딥러닝 연구는 계속해서 빠르게 발전하고 있으며, 과적합을 해결하기 위한 새로운 기법들이 계속해서 등장할 것입니다.</p>
</section>
</section>
</section>
<section id="연습문제" class="level2">
<h2 class="anchored" data-anchor-id="연습문제">연습문제</h2>
<section id="기본-문제" class="level3">
<h3 class="anchored" data-anchor-id="기본-문제">기본 문제</h3>
<ol type="1">
<li>과적합(overfitting)과 과소적합(underfitting)의 개념을 설명하고, 각 현상이 발생했을 때 모델의 성능에 어떤 영향을 미치는지 설명하시오.</li>
<li>L1 규제와 L2 규제의 차이점을 설명하고, 각 규제가 모델의 가중치에 어떤 영향을 미치는지 설명하시오.</li>
<li>드롭아웃(dropout)의 작동 원리를 설명하고, 드롭아웃이 과적합을 방지하는 데 어떻게 도움이 되는지 설명하시오.</li>
<li>배치 정규화(batch normalization)의 개념을 설명하고, 배치 정규화가 딥러닝 모델의 학습에 어떤 이점을 제공하는지 설명하시오.</li>
<li>주어진 코드에서 custom_loss함수의 각 lambda를 변경해가면서 그래프에 어떠한 변화가 있는지 서술하라.</li>
<li>L1, L2 놈(norm)을 정의하시오.</li>
<li>배치 정규화의 수식에서 평균과 분산이 어떻게 계산되는지, 그리고 이들이 정규화 과정에 어떻게 사용되는지 설명하시오.</li>
</ol>
</section>
<section id="응용-문제" class="level3">
<h3 class="anchored" data-anchor-id="응용-문제">응용 문제</h3>
<ol type="1">
<li>주어진 데이터셋에 대해 다항식 회귀(polynomial regression) 모델을 학습시키고, 차수(degree)를 변화시키면서 과적합과 과소적합 현상을 관찰하시오. (Python 코드 작성)</li>
<li>간단한 신경망 모델을 만들고, L1 또는 L2 규제를 적용하여 모델의 가중치 변화를 관찰하고, 규제 강도에 따른 성능 변화를 비교하시오. (Python 코드 작성)</li>
<li>드롭아웃 비율을 다르게 설정하여 신경망 모델을 학습시키고, 각 비율에 따른 훈련/검증 손실과 정확도를 비교하시오. (Python 코드 작성)</li>
<li>배치 정규화 층을 추가하거나 제거하면서 신경망 모델의 학습 속도와 수렴 안정성을 비교하시오. (Python 코드 작성)</li>
<li>라그랑주 승수법(Lagrange multiplier method)을 사용하여 L1, L2 규제가 적용된 손실 함수의 최적해 조건을 유도하시오.</li>
<li>배치 정규화의 역전파(backpropagation) 과정을 유도하고, 배치 정규화가 기울기 소실 문제를 완화하는 데 어떻게 도움이 되는지 설명하시오.</li>
</ol>
</section>
<section id="심화-문제" class="level3">
<h3 class="anchored">심화 문제</h3>
<ol type="1">
<li>L1 규제와 L2 규제가 손실 평면(loss surface)에 미치는 영향을 시각화하고, 각 규제의 기하학적 의미를 설명하시오. (Python 코드 작성)</li>
<li>드롭아웃을 앙상블(ensemble) 학습의 관점에서 해석하고, 드롭아웃이 모델의 불확실성(uncertainty) 추정에 어떻게 활용될 수 있는지 설명하시오.</li>
<li>다양한 하이퍼파라미터 최적화 기법(그리드 탐색, 랜덤 탐색, 베이지안 최적화 등)을 비교하고, 각 기법의 장단점을 설명하시오.</li>
<li>BoTorch를 사용하지 말고, 베이지안 최적화의 핵심 아이디어를 구현하여 간단한 함수의 최적값을 찾는 코드를 작성하시오. (Python 코드 작성, 라이브러리 사용 가능)</li>
<li>가우시안 프로세스(Gaussian Process)의 기본 원리를 설명하고, 가우시안 프로세스가 불확실성을 포함한 예측을 어떻게 수행하는지 설명하시오.</li>
<li>가우시안 프로세스의 커널 함수(kernel function)가 만족해야 할 조건을 설명하고, RBF 커널이 이 조건을 만족함을 증명하시오.</li>
<li>베이지안 최적화에서 획득 함수(acquisition function)의 역할을 설명하고, Expected Improvement (EI) 획득 함수의 수식을 유도하고 그 의미를 설명하시오.</li>
</ol>
<div class="callout callout-style-default callout-note callout-titled" title="클릭하여 내용 보기 (연습문제 해답)">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-4-contents" aria-controls="callout-4" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
클릭하여 내용 보기 (연습문제 해답)
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-4" class="callout-4-contents callout-collapse collapse">
<section id="연습문제-해답" class="level2 callout-body-container callout-body">
<h2 class="anchored" data-anchor-id="연습문제-해답">연습문제 해답</h2>
<section id="기본-문제-1" class="level3">
<h3 class="anchored" data-anchor-id="기본-문제-1">기본 문제</h3>
<ol type="1">
<li><strong>과적합/과소적합:</strong>
<ul>
<li><strong>과적합 (Overfitting):</strong> 모델이 훈련 데이터에 너무 잘 맞춰져서 새로운 데이터(검증/테스트 데이터)에 대한 성능(일반화 성능)이 떨어지는 현상입니다. 훈련 데이터에서는 성능이 높지만, 검증/테스트 데이터에서는 성능이 낮습니다.</li>
<li><strong>과소적합 (Underfitting):</strong> 모델이 너무 단순해서 훈련 데이터의 패턴을 충분히 학습하지 못한 현상입니다. 훈련, 검증, 테스트 데이터 모두에서 낮은 성능을 보입니다.</li>
</ul></li>
<li><strong>L1/L2 규제:</strong>
<ul>
<li><strong>L1 규제 (Lasso):</strong> 손실 함수에 가중치의 절댓값 합을 더합니다. <span class="math inline">\(\lambda \sum_{i} |w_i|\)</span> 일부 가중치를 정확히 0으로 만들어 특성 선택(feature selection) 효과를 냅니다.</li>
<li><strong>L2 규제 (Ridge):</strong> 손실 함수에 가중치의 제곱 합을 더합니다. <span class="math inline">\(\lambda \sum_{i} (w_i)^2\)</span> 가중치를 0에 가깝게 만들지만, 완전히 0으로 만들지는 않습니다.</li>
</ul></li>
<li><strong>드롭아웃:</strong>
<ul>
<li><strong>작동 원리:</strong> 학습 과정에서 무작위로 일부 뉴런을 비활성화(출력을 0으로 만듦)합니다.</li>
<li><strong>과적합 방지:</strong> 매번 다른 뉴런 조합으로 학습하므로, 특정 뉴런에 의존하는 것을 막고 앙상블 학습 효과를 냅니다.</li>
</ul></li>
<li><strong>배치 정규화:</strong>
<ul>
<li><strong>개념:</strong> 각 층의 입력을 평균 0, 분산 1로 정규화합니다.</li>
<li><strong>이점:</strong> 학습 속도 향상, 기울기 소실/폭발 문제 완화, 더 높은 학습률 사용 가능, 약간의 규제 효과.</li>
</ul></li>
<li><strong><code>custom_loss</code> lambda 변화:</strong>
<ul>
<li><strong><code>lambda</code> 증가:</strong> 규제 항의 영향력이 커집니다. 가중치가 작아지고, 모델이 단순해져 과소적합될 가능성이 증가합니다.</li>
<li><strong><code>lambda</code> 감소:</strong> 규제 항의 영향력이 작아집니다. 가중치가 커지고, 모델이 복잡해져 과적합될 가능성이 증가합니다.</li>
</ul></li>
<li><strong>L1/L2 놈:</strong>
<ul>
<li><strong>L1 놈:</strong> 벡터 요소들의 절댓값 합. <span class="math inline">\(\| \mathbf{x} \|_1 = |x_1| + |x_2| + \dots + |x_n|\)</span></li>
<li><strong>L2 놈:</strong> 벡터 요소들의 제곱 합의 제곱근 (유클리드 거리). <span class="math inline">\(\| \mathbf{x} \|_2 = \sqrt{|x_1|^2 + |x_2|^2 + \dots + |x_n|^2}\)</span></li>
</ul></li>
<li><strong>배치 정규화 수식:</strong>
<ul>
<li><strong>평균 (μ):</strong> 미니 배치 내 샘플들의 평균. <span class="math inline">\(\mu = \frac{1}{m} \sum_{i=1}^{m} x_i\)</span></li>
<li><strong>분산 (σ²):</strong> 미니 배치 내 샘플들의 분산. <span class="math inline">\(\sigma^2 = \frac{1}{m} \sum_{i=1}^{m} (x_i - \mu)^2\)</span></li>
<li><strong>정규화:</strong> <span class="math inline">\(x_{i\_\text{norm}} = \frac{x_i - \mu}{\sqrt{\sigma^2 + \epsilon}}\)</span> (ε은 0으로 나누는 것을 방지하기 위한 작은 상수)</li>
</ul></li>
</ol>
</section>
<section id="응용-문제-1" class="level3">
<h3 class="anchored" data-anchor-id="응용-문제-1">응용 문제</h3>
<ol type="1">
<li><p><strong>다항식 회귀:</strong> (코드 생략) 차수를 너무 높이면 과적합, 너무 낮추면 과소적합됩니다.</p></li>
<li><p><strong>L1/L2 규제:</strong> (코드 생략) 규제 강도(<code>lambda</code>)가 강할수록 가중치가 작아지고, 성능 변화를 관찰합니다.</p></li>
<li><p><strong>드롭아웃 비율:</strong> (코드 생략) 적절한 드롭아웃 비율은 과적합을 방지하고 성능을 향상시킬 수 있습니다. 너무 높은 비율은 과소적합을 유발할 수 있습니다.</p></li>
<li><p><strong>배치 정규화:</strong> (코드 생략) 배치 정규화를 추가하면 학습 속도가 빨라지고, 수렴이 안정되는 경향을 보입니다.</p></li>
<li><p><strong>라그랑주 승수법:</strong></p>
<ul>
<li><strong>L2 규제:</strong> <span class="math inline">\(L(\mathbf{w}, \lambda) = \text{Loss}(\mathbf{w}) + \lambda (\|\mathbf{w}\|_2^2 - c)  \rightarrow  \nabla_\mathbf{w}L = \nabla_\mathbf{w}\text{Loss}(\mathbf{w}) + 2\lambda\mathbf{w} = 0\)</span></li>
<li><strong>L1 규제:</strong> <span class="math inline">\(L(\mathbf{w}, \lambda) = \text{Loss}(\mathbf{w}) + \lambda (\|\mathbf{w}\|_1 - c)  \rightarrow  \nabla_\mathbf{w}L = \nabla_\mathbf{w}\text{Loss}(\mathbf{w}) + \lambda \cdot \text{sign}(\mathbf{w}) = 0\)</span> (sign(w)는 w의 부호)</li>
</ul></li>
<li><p><strong>배치 정규화 역전파:</strong> (유도 생략) 배치 정규화는 각 층의 입력을 정규화하여 기울기 소실/폭발 문제를 완화하고, 학습을 안정화합니다.</p></li>
</ol>
</section>
<section id="심화-문제-1" class="level3">
<h3 class="anchored" data-anchor-id="심화-문제-1">심화 문제</h3>
<ol type="1">
<li><p><strong>손실 평면 시각화:</strong> (코드 생략) L1 규제는 마름모 형태, L2 규제는 원 형태의 제약 조건을 생성하여, 최적해가 다른 위치에서 형성됩니다.</p></li>
<li><p><strong>드롭아웃 앙상블:</strong> 드롭아웃은 매번 다른 네트워크 구조로 학습하는 효과를 내므로, 앙상블 학습과 유사합니다. 예측 시에는 모든 뉴런을 사용하여 (드롭아웃 없이) 평균적인 예측을 수행합니다. 몬테카를로 드롭아웃(Monte Carlo dropout)을 통해 예측의 불확실성을 추정할 수 있습니다.</p></li>
<li><p><strong>하이퍼파라미터 최적화 기법:</strong></p>
<ul>
<li><strong>그리드 탐색:</strong> 모든 조합 시도. 계산 비용이 매우 큽니다.</li>
<li><strong>랜덤 탐색:</strong> 무작위 조합 시도. 그리드 탐색보다 효율적일 수 있습니다.</li>
<li><strong>베이지안 최적화:</strong> 이전 탐색 결과를 바탕으로 확률 모델을 사용하여 다음 탐색 지점을 결정. 효율적입니다.</li>
</ul></li>
<li><p><strong>베이지안 최적화 구현:</strong> (코드 생략) 대리 모델(surrogate model, 예: 가우시안 프로세스)과 획득 함수(acquisition function, 예: Expected Improvement)를 사용하여 구현합니다.</p></li>
<li><p><strong>가우시안 프로세스:</strong> 함수에 대한 확률 분포입니다. 커널 함수를 사용하여 함수 값들 사이의 공분산을 정의합니다. 주어진 데이터를 바탕으로 사후 분포를 계산하여 예측의 평균과 분산(불확실성)을 제공합니다.</p></li>
<li><p><strong>커널 함수 조건:</strong> 양의 준정부호성(positive semi-definiteness)을 만족해야 합니다. 임의의 입력 점들에 대해 생성되는 커널 행렬(Gram matrix)이 양의 준정부호(positive semi-definite) 행렬이어야 합니다. RBF 커널은 이 조건을 만족합니다. (증명 생략)</p></li>
<li><p><strong>획득 함수:</strong> 베이지안 최적화에서 다음 탐색 지점을 결정하는 데 사용됩니다. Expected Improvement (EI)는 현재까지의 최적값보다 더 좋은 결과를 얻을 가능성과 그 향상 정도를 고려하여 다음 탐색 지점을 선택합니다. (수식 유도 생략)</p></li>
</ol>
</section>
</section>
</div>
</div>
<ol type="1">
<li><strong>Dropout: A Simple Way to Prevent Neural Networks from Overfitting</strong> (Srivastava et al., 2014): 드롭아웃의 개념과 효과를 설명하는 원 논문. (<a href="https://www.cs.toronto.edu/~rsalakhu/papers/srivastava14a.pdf">https://www.cs.toronto.edu/~rsalakhu/papers/srivastava14a.pdf</a>)</li>
<li><strong>Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift</strong> (Ioffe &amp; Szegedy, 2015): 배치 정규화의 개념과 효과를 설명하는 원 논문. (<a href="https://arxiv.org/abs/1502.03167">https://arxiv.org/abs/1502.03167</a>)</li>
<li><strong>Deep Learning</strong> (Goodfellow et al., 2016): 딥러닝 교과서. 7장 “Regularization for Deep Learning”에서 과적합 및 규제 기법을 자세히 다룹니다. (<a href="http://www.deeplearningbook.org/">http://www.deeplearningbook.org/</a>)</li>
<li><strong>Understanding the difficulty of training deep feedforward neural networks</strong> (Glorot &amp; Bengio, 2010): 초기 딥러닝 모델의 학습 어려움과 가중치 초기화 방법의 중요성을 설명. (<a href="http://proceedings.mlr.press/v9/glorot10a/glorot10a.pdf">http://proceedings.mlr.press/v9/glorot10a/glorot10a.pdf</a>)</li>
<li><strong>Regularization techniques for deep learning: A survey</strong> (Kukacka et al., 2017): 다양한 규제 기법들을 종합적으로 비교 분석한 논문.</li>
<li><strong>A Tutorial on Bayesian Optimization</strong> (Frazier, 2018): 베이지안 최적화의 기본 개념과 응용을 설명하는 튜토리얼. (<a href="https://arxiv.org/abs/1807.02811">https://arxiv.org/abs/1807.02811</a>)</li>
<li><strong>Bayesian Optimization</strong> (Garnett, 2023): 베이지안 최적화에 대한 종합적인 교과서 (<a href="https://www.bayesoptbook.com/">https://www.bayesoptbook.com/</a>)</li>
<li><strong>Gaussian Processes for Machine Learning</strong> (Rasmussen &amp; Williams, 2006): 가우시안 프로세스의 기본 원리와 머신러닝 응용을 다룬 교과서. (<a href="http://www.gaussianprocess.org/gpml/">http://www.gaussianprocess.org/gpml/</a>)</li>
<li><strong>Deep Kernel Learning</strong> (Wilson et al., 2016): 딥 커널 학습의 개념과 방법을 설명하는 논문. (<a href="https://arxiv.org/abs/1511.02222">https://arxiv.org/abs/1511.02222</a>)</li>
<li><strong>Hands-On Machine Learning with Scikit-Learn, Keras &amp; TensorFlow</strong> (Aurélien Géron, 2019): 머신러닝 및 딥러닝 실습 교과서. 과적합 및 규제 기법을 실제 코드 예제와 함께 설명합니다.</li>
<li><strong>Adam: A Method for Stochastic Optimization</strong> (Kingma &amp; Ba, 2014) (<a href="https://arxiv.org/abs/1412.6980">https://arxiv.org/abs/1412.6980</a>): Adam 옵티마이저에 대한 논문</li>
<li><strong>Decoupled Weight Decay Regularization</strong> (Loshchilov &amp; Hutter, 2017) (<a href="https://arxiv.org/abs/1711.05101">https://arxiv.org/abs/1711.05101</a>): AdamW에 대한 논문</li>
</ol>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>