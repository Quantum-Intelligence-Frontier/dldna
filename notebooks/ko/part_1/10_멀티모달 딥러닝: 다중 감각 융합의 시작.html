<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>quarto-input7173481295f7c1d9 – Deep Learning DNA: Surviving Architectures and Essential Principles</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap-f507c7d0488cb7630e20aad62ad8c2aa.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script>window.MathJax = {loader: {load: ['[tex]/boldsymbol']},tex: {packages: {'[+]': ['boldsymbol']}}};</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-sidebar docked">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../../notebooks/ko/part_1/01_딥러닝의 시작.html">part_1</a></li><li class="breadcrumb-item"><a href="../../../notebooks/ko/part_1/10_멀티모달 딥러닝: 다중 감각 융합의 시작.html">10. 멀티모달 딥러닝: 다중 감각 융합의 시작</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../../../">한국어</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Language</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../index_de.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Deutsch</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../index_en.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">English</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../index_es.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Español</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">한국어</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../index_zh.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">中文</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../notebooks/ko/part_1/00_서론.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">서론</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true">
 <span class="menu-text">part_1</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../notebooks/ko/part_1/01_딥러닝의 시작.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">1. 딥러닝의 시작</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../notebooks/ko/part_1/02_딥러닝의 수학.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">2. 딥러닝의 수학</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../notebooks/ko/part_1/03_딥러닝프레임워크.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">3. 딥러닝프레임워크</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../notebooks/ko/part_1/04_활성화함수.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">4. 활성화함수</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../notebooks/ko/part_1/05_최적화와 시각화.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">5. 최적화와 시각화</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../notebooks/ko/part_1/06_과적합과 해결 기법의 발전.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">6. 과적합과 해결 기법의 발전</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../notebooks/ko/part_1/07_합성곱 신경망의 진화.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">7. 합성곱 신경망의 진화</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../notebooks/ko/part_1/08_트랜스포머의 탄생.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">8. 트랜스포머의 탄생</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../notebooks/ko/part_1/09_트랜스포머의 진화.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">9. 트랜스포머의 진화</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../notebooks/ko/part_1/10_멀티모달 딥러닝: 다중 감각 융합의 시작.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">10. 멀티모달 딥러닝: 다중 감각 융합의 시작</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../notebooks/ko/part_1/11_멀티모달 딥러닝: 한계를 넘어선 지능.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">11. 멀티모달 딥러닝: 한계를 넘어선 지능</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true">
 <span class="menu-text">딥러닝의 최전선</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../notebooks/ko/딥러닝의 최전선/01_SLM: 작지만 강력한 언어모델.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">1. SLM: 작지만 강력한 언어모델</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../notebooks/ko/딥러닝의 최전선/02_자율주행.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">2. 자율주행</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#장-멀티모달-딥러닝-다중-감각-융합의-시작" id="toc-장-멀티모달-딥러닝-다중-감각-융합의-시작" class="nav-link active" data-scroll-target="#장-멀티모달-딥러닝-다중-감각-융합의-시작">10장 멀티모달 딥러닝: 다중 감각 융합의 시작</a>
  <ul class="collapse">
  <li><a href="#멀티모달과-딥러닝" id="toc-멀티모달과-딥러닝" class="nav-link" data-scroll-target="#멀티모달과-딥러닝">10.1 멀티모달과 딥러닝</a>
  <ul class="collapse">
  <li><a href="#멀티모달-데이터와-딥러닝의-만남" id="toc-멀티모달-데이터와-딥러닝의-만남" class="nav-link" data-scroll-target="#멀티모달-데이터와-딥러닝의-만남">10.1.1 멀티모달 데이터와 딥러닝의 만남</a></li>
  <li><a href="#멀티모달-딥러닝의-중요성과-응용-분야" id="toc-멀티모달-딥러닝의-중요성과-응용-분야" class="nav-link" data-scroll-target="#멀티모달-딥러닝의-중요성과-응용-분야">10.1.2 멀티모달 딥러닝의 중요성과 응용 분야</a></li>
  <li><a href="#멀티모달-딥러닝의-역사와-발전-과정" id="toc-멀티모달-딥러닝의-역사와-발전-과정" class="nav-link" data-scroll-target="#멀티모달-딥러닝의-역사와-발전-과정">10.1.3 멀티모달 딥러닝의 역사와 발전 과정</a></li>
  </ul></li>
  <li><a href="#초기-멀티모달-접근법" id="toc-초기-멀티모달-접근법" class="nav-link" data-scroll-target="#초기-멀티모달-접근법">10.2 초기 멀티모달 접근법</a>
  <ul class="collapse">
  <li><a href="#이미지-캡셔닝-멀티모달-융합의-첫걸음" id="toc-이미지-캡셔닝-멀티모달-융합의-첫걸음" class="nav-link" data-scroll-target="#이미지-캡셔닝-멀티모달-융합의-첫걸음">10.2.1 이미지 캡셔닝: 멀티모달 융합의 첫걸음</a></li>
  <li><a href="#시각-질의응답vqa-이미지-이해와-추론" id="toc-시각-질의응답vqa-이미지-이해와-추론" class="nav-link" data-scroll-target="#시각-질의응답vqa-이미지-이해와-추론">10.2.2 시각 질의응답(VQA): 이미지 이해와 추론</a></li>
  </ul></li>
  <li><a href="#멀티모달-융합fusion-이론-cmu-강의-기반-분류" id="toc-멀티모달-융합fusion-이론-cmu-강의-기반-분류" class="nav-link" data-scroll-target="#멀티모달-융합fusion-이론-cmu-강의-기반-분류">10.3 멀티모달 융합(Fusion) 이론 : CMU 강의 기반 분류</a>
  <ul class="collapse">
  <li><a href="#joint-representations" id="toc-joint-representations" class="nav-link" data-scroll-target="#joint-representations">10.3.1 Joint Representations</a></li>
  <li><a href="#coordinated-representations" id="toc-coordinated-representations" class="nav-link" data-scroll-target="#coordinated-representations">10.3.2 Coordinated Representations</a></li>
  <li><a href="#encoder-decoder" id="toc-encoder-decoder" class="nav-link" data-scroll-target="#encoder-decoder">10.3.3 Encoder-Decoder</a></li>
  <li><a href="#모달리티-통합-전략" id="toc-모달리티-통합-전략" class="nav-link" data-scroll-target="#모달리티-통합-전략">10.3.4 모달리티 통합 전략</a></li>
  </ul></li>
  <li><a href="#멀티모달-표현-학습-기법" id="toc-멀티모달-표현-학습-기법" class="nav-link" data-scroll-target="#멀티모달-표현-학습-기법">10.4 멀티모달 표현 학습 기법</a>
  <ul class="collapse">
  <li><a href="#모달리티-간-표현-학습" id="toc-모달리티-간-표현-학습" class="nav-link" data-scroll-target="#모달리티-간-표현-학습">10.4.1 모달리티 간 표현 학습</a></li>
  <li><a href="#크로스모달-어텐션-구조" id="toc-크로스모달-어텐션-구조" class="nav-link" data-scroll-target="#크로스모달-어텐션-구조">10.4.2 크로스모달 어텐션 구조</a></li>
  <li><a href="#perceiver-아키텍처" id="toc-perceiver-아키텍처" class="nav-link" data-scroll-target="#perceiver-아키텍처">10.4.3 Perceiver 아키텍처</a></li>
  <li><a href="#크로스-어텐션-구현과-훈련-안정성" id="toc-크로스-어텐션-구현과-훈련-안정성" class="nav-link" data-scroll-target="#크로스-어텐션-구현과-훈련-안정성">10.4.4 크로스 어텐션 구현과 훈련 안정성</a></li>
  </ul></li>
  <li><a href="#비전-트랜스포머vit" id="toc-비전-트랜스포머vit" class="nav-link" data-scroll-target="#비전-트랜스포머vit">10.5 비전 트랜스포머(ViT)</a>
  <ul class="collapse">
  <li><a href="#cnn에서-vit로의-패러다임-전환" id="toc-cnn에서-vit로의-패러다임-전환" class="nav-link" data-scroll-target="#cnn에서-vit로의-패러다임-전환">10.5.1 CNN에서 ViT로의 패러다임 전환</a></li>
  <li><a href="#이미지-패치-임베딩의-원리" id="toc-이미지-패치-임베딩의-원리" class="nav-link" data-scroll-target="#이미지-패치-임베딩의-원리">10.5.2 이미지 패치 임베딩의 원리</a></li>
  <li><a href="#포지셔널-인코딩-메커니즘" id="toc-포지셔널-인코딩-메커니즘" class="nav-link" data-scroll-target="#포지셔널-인코딩-메커니즘">10.5.3 포지셔널 인코딩 메커니즘</a></li>
  <li><a href="#vit의-구조와-주요-구성-요소" id="toc-vit의-구조와-주요-구성-요소" class="nav-link" data-scroll-target="#vit의-구조와-주요-구성-요소">10.5.4 ViT의 구조와 주요 구성 요소</a></li>
  <li><a href="#vit-훈련-예제" id="toc-vit-훈련-예제" class="nav-link" data-scroll-target="#vit-훈련-예제">10.5.5 ViT 훈련 예제</a></li>
  <li><a href="#vit-22b-극한의-스케일" id="toc-vit-22b-극한의-스케일" class="nav-link" data-scroll-target="#vit-22b-극한의-스케일">10.5.6 ViT-22B: 극한의 스케일</a></li>
  <li><a href="#mae-v3-자기-지도-학습" id="toc-mae-v3-자기-지도-학습" class="nav-link" data-scroll-target="#mae-v3-자기-지도-학습">10.5.7 MAE v3: 자기 지도 학습</a></li>
  </ul></li>
  <li><a href="#clip-멀티모달-학습의-이정표" id="toc-clip-멀티모달-학습의-이정표" class="nav-link" data-scroll-target="#clip-멀티모달-학습의-이정표">10.6 CLIP: 멀티모달 학습의 이정표</a>
  <ul class="collapse">
  <li><a href="#clip의-기본-구조-듀얼-인코더-dual-encoder" id="toc-clip의-기본-구조-듀얼-인코더-dual-encoder" class="nav-link" data-scroll-target="#clip의-기본-구조-듀얼-인코더-dual-encoder">10.6.1 CLIP의 기본 구조: 듀얼 인코더 (Dual Encoder)</a></li>
  <li><a href="#image-encoder" id="toc-image-encoder" class="nav-link" data-scroll-target="#image-encoder">10.6.2 Image Encoder</a></li>
  <li><a href="#text-encoder" id="toc-text-encoder" class="nav-link" data-scroll-target="#text-encoder">10.6.3 Text Encoder</a></li>
  <li><a href="#zero-shot-전이의-메커니즘" id="toc-zero-shot-전이의-메커니즘" class="nav-link" data-scroll-target="#zero-shot-전이의-메커니즘">10.6.4 Zero-shot 전이의 메커니즘</a></li>
  </ul></li>
  <li><a href="#연습문제" id="toc-연습문제" class="nav-link" data-scroll-target="#연습문제">연습문제</a></li>
  <li><a href="#참고-자료" id="toc-참고-자료" class="nav-link" data-scroll-target="#참고-자료">참고 자료</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../../notebooks/ko/part_1/01_딥러닝의 시작.html">part_1</a></li><li class="breadcrumb-item"><a href="../../../notebooks/ko/part_1/10_멀티모달 딥러닝: 다중 감각 융합의 시작.html">10. 멀티모달 딥러닝: 다중 감각 융합의 시작</a></li></ol></nav></header>




<p><a href="https://colab.research.google.com/github/Quantum-Intelligence-Frontier/dldna/blob/main/notebooks/ko/part_1/10_멀티모달 딥러닝%3A 다중 감각 융합의 시작.ipynb" target="_parent"> <img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"> </a></p>
<section id="장-멀티모달-딥러닝-다중-감각-융합의-시작" class="level1">
<h1>10장 멀티모달 딥러닝: 다중 감각 융합의 시작</h1>
<blockquote class="blockquote">
<p>“지각은 단일 감각의 파편이 아니라, 모든 감각이 조화롭게 융합된 교향곡이다.”, 제임스 깁슨, 생태심리학 창시자.</p>
</blockquote>
<p>인공지능 역사에서 오랫동안 풀리지 않던 난제가 있었습니다. 바로 “멀티모달리티(Multimodality)” 입니다. 인간은 세상을 인식할 때 시각, 청각, 촉각 등 다양한 감각(modality)을 동시에 사용하고, 이들을 유기적으로 통합합니다. 예를 들어, 우리는 카페에서 커피를 마실 때 커피 잔의 따뜻함(촉각), 커피 향(후각), 주변 사람들의 대화 소리(청각), 카페 내부의 풍경(시각) 등 다양한 정보를 동시에 받아들이고, 이를 통해 “카페에 있다”는 하나의 총체적인 경험을 형성합니다.</p>
<p>하지만 초기 인공지능 모델은 이러한 멀티모달 정보를 처리하는 데 어려움을 겪었습니다. 1950년대부터 시작된 인공지능 연구는 주로 단일 모달리티(텍스트, 이미지, 음성) 처리에 집중했습니다. 각 분야에서 번역, 음성 인식등 괄목할 만한 성과가 있었지만, 이들을 통합하여 인간처럼 이해하는 것은 또 다른 차원의 문제였습니다.</p>
<p>이 장에서는 멀티모달 딥러닝의 핵심 이론과 살아남은 아키텍처들을 심도 있게 탐구합니다. 각 아키텍처가 어떤 방식으로 딥러닝의 DNA를 확장하고 진화시켰는지, 그리고 이들이 어떻게 현실 세계의 복잡한 문제를 해결하는 데 기여하고 있는지 살펴볼 것입니다.</p>
<section id="멀티모달과-딥러닝" class="level2">
<h2 class="anchored" data-anchor-id="멀티모달과-딥러닝">10.1 멀티모달과 딥러닝</h2>
<blockquote class="blockquote">
<p><strong>도전 과제:</strong> 텍스트, 이미지, 오디오 등 서로 다른 형태의 데이터를 어떻게 하나의 모델에서 통합하여 처리할 것인가? 이들 데이터는 표현 방식, 차원, 통계적 특성이 모두 다르다. 어떻게 이질적인 정보를 융합하여 의미 있는 표현을 학습할 것인가?</p>
<p><strong>연구자의 고뇌:</strong> 연구자들은 각 모달리티의 고유한 특성을 유지하면서도, 이들 간의 상호작용을 효과적으로 모델링할 수 있는 새로운 방법, 즉 딥러닝의 새로운 DNA를 찾아야 했습니다. 단순한 결합(concatenation)을 넘어, 각 모달리티가 서로의 맥락을 이해하고 상호 보완적인 정보를 제공하는 진정한 의미의 융합이 필요했습니다.</p>
</blockquote>
<section id="멀티모달-데이터와-딥러닝의-만남" class="level3">
<h3 class="anchored" data-anchor-id="멀티모달-데이터와-딥러닝의-만남">10.1.1 멀티모달 데이터와 딥러닝의 만남</h3>
<p>멀티모달 데이터는 텍스트, 이미지, 오디오, 비디오 등 두 가지 이상의 서로 다른 형태의 데이터가 결합된 것을 의미합니다. 예를 들어, 뉴스 기사는 텍스트와 이미지로, 영화는 비디오와 오디오로 구성됩니다. 인간은 이러한 멀티모달 정보를 자연스럽게 통합하여 세상을 이해합니다. 단어를 읽으면서 동시에 그림을 보고, 소리를 들으면서 상황을 파악하는 것은 인간에게는 지극히 당연한 일입니다.</p>
<p><strong>왜 멀티모달 딥러닝은 어려운 문제였을까?</strong></p>
<ol type="1">
<li><p><strong>이질적인 데이터 표현:</strong> 텍스트, 이미지, 오디오는 표현 방식, 차원, 통계적 특성이 모두 다릅니다. 이러한 이질적인 데이터를 어떻게 하나의 모델에서 효과적으로 표현하고 처리할 것인가는 어려운 문제였습니다.</p></li>
<li><p><strong>정보 융합의 복잡성:</strong> 각 모달리티의 정보를 단순히 결합하는 것(concatenation)은 진정한 의미의 융합이라고 할 수 없습니다. 각 모달리티가 서로의 맥락을 이해하고, 상호 보완적인 정보를 제공하며, 때로는 상충되는 정보를 조율하는 복잡한 상호작용을 모델링해야 합니다.</p></li>
<li><p><strong>데이터 부족과 불균형:</strong> 멀티모달 데이터는 단일 모달리티 데이터에 비해 상대적으로 양이 적고, 각 모달리티 간의 데이터 불균형 문제도 존재합니다. 예를 들어, 이미지와 텍스트가 쌍으로 이루어진 데이터는 많지만, 이미지, 텍스트, 오디오가 모두 함께 존재하는 데이터는 훨씬 적습니다.</p></li>
</ol>
<p>이러한 난제에도 불구하고, 딥러닝은 이러한 멀티모달 데이터 처리에 새로운 차원의 가능성을 제시했습니다.</p>
<p>2010년대 이후 딥러닝 기술의 발전, 특히 트랜스포머(Transformer) 아키텍처의 등장은 멀티모달 딥러닝 발전에 결정적인 역할을 했습니다. 이는 딥러닝 DNA의 중요한 변곡점이었습니다. 트랜스포머의 셀프 어텐션(self-attention) 메커니즘은 각 모달리티 내의 요소 간 관계뿐만 아니라, 서로 다른 모달리티 간의 복잡한 상호작용까지 효과적으로 모델링할 수 있게 했습니다. 이전까지는 CNN이 이미지, RNN이 시퀀스 데이터 처리에 특화되어 있었다면, 트랜스포머는 범용적인(universal) 아키텍처로 다양한 모달리티에 적용될 수 있는 유연성을 제공했습니다.</p>
</section>
<section id="멀티모달-딥러닝의-중요성과-응용-분야" class="level3">
<h3 class="anchored" data-anchor-id="멀티모달-딥러닝의-중요성과-응용-분야">10.1.2 멀티모달 딥러닝의 중요성과 응용 분야</h3>
<p>멀티모달 딥러닝은 인공지능이 인간처럼 세상을 이해하고 상호작용하는 데 필수적인 기술입니다. 이는 단순히 여러 형태의 데이터를 처리하는 것을 넘어, 각 데이터가 담고 있는 의미를 유기적으로 연결하여 더 풍부하고 정확한 추론을 가능하게 합니다. 마치 뇌의 여러 영역이 협력하여 복잡한 인지 기능을 수행하는 것처럼, 멀티모달 딥러닝은 인공지능의 지능을 한 단계 끌어올리는 핵심 동력입니다.</p>
<p><strong>주요 응용 분야</strong></p>
<ul>
<li><p><strong>시각 질의응답 (Visual Question Answering, VQA):</strong> 이미지와 질문(텍스트)을 입력받아 질문에 대한 답변을 생성합니다. 단순히 이미지 속 객체를 인식하는 것을 넘어, 이미지와 질문의 의미를 종합적으로 이해해야 합니다. 예를 들어, “그림 속 남자는 어떤 색깔의 모자를 쓰고 있는가?”라는 질문에 답하기 위해서는 남자를 찾고, 모자를 인식하고, 색깔을 판별하는 복합적인 과정이 필요합니다.</p></li>
<li><p><strong>이미지 캡셔닝 (Image Captioning):</strong> 이미지를 설명하는 텍스트를 자동으로 생성합니다. 이미지의 내용을 정확하게 파악하고, 이를 자연스러운 문장으로 표현해야 합니다.</p></li>
<li><p><strong>멀티모달 감정 분석 (Multimodal Sentiment Analysis):</strong> 텍스트, 음성, 표정 등 여러 정보를 종합하여 사용자의 감정을 파악합니다. 텍스트만으로는 파악하기 어려운 비꼬는 말투나 미묘한 감정 변화를 음성 톤이나 표정 변화를 통해 감지할 수 있습니다.</p></li>
<li><p><strong>자율 주행:</strong> 카메라(이미지), LiDAR(3D 센서), GPS(위치 정보), 레이더 등 다양한 센서 데이터를 통합하여 주변 환경을 인식하고 주행 결정을 내립니다. 각 센서는 서로 다른 정보를 제공하며, 이들을 융합해야만 안전하고 정확한 주행이 가능합니다.</p></li>
<li><p><strong>로봇 공학:</strong> 로봇이 시각, 촉각, 청각 등 다양한 센서 정보를 융합하여 복잡한 작업을 수행합니다. 예를 들어, 로봇이 물건을 잡기 위해서는 물체의 위치와 형태를 시각적으로 파악하고, 물건을 잡았을 때의 촉각 정보를 통해 적절한 힘을 조절해야 합니다.</p></li>
<li><p><strong>의료 진단:</strong> X-ray, MRI(이미지), 환자 기록(텍스트), 생체 신호(시계열 데이터), 유전체 정보 등을 종합하여 질병을 진단하고 예측합니다. 각 데이터는 질병에 대한 서로 다른 단서를 제공하며, 이들을 통합적으로 분석해야 정확한 진단이 가능합니다.</p></li>
</ul>
</section>
<section id="멀티모달-딥러닝의-역사와-발전-과정" class="level3">
<h3 class="anchored" data-anchor-id="멀티모달-딥러닝의-역사와-발전-과정">10.1.3 멀티모달 딥러닝의 역사와 발전 과정</h3>
<p>멀티모달 딥러닝 연구는 딥러닝 DNA의 진화를 보여주는 흥미로운 여정입니다. 이 여정은 크게 다음과 같은 주요 단계로 나누어 살펴볼 수 있습니다.</p>
<section id="초기-단계-2010년대-초반" class="level4">
<h4 class="anchored" data-anchor-id="초기-단계-2010년대-초반">초기 단계 (2010년대 초반)</h4>
<p>2010년대 초반, 멀티모달 딥러닝의 초기 연구는 주로 이미지 캡셔닝(image captioning)과 VQA(Visual Question Answering)에 집중되었습니다. 이 시기에는 CNN(Convolutional Neural Network)을 사용하여 이미지에서 특징을 추출하고, RNN(Recurrent Neural Network)을 사용하여 텍스트를 처리하는 CNN-RNN 기반 모델이 주를 이루었습니다. CNN은 이미지의 공간적인 특징을 효과적으로 포착하고, RNN은 텍스트의 순차적인 정보를 처리하는 데 강점을 보였습니다.</p>
<p>하지만 초기 모델들은 각 모달리티를 독립적으로 처리한 후 마지막 단계에서 결과를 결합하는 <em>late fusion</em> 방식을 주로 사용했습니다. 이 방식은 각 모달리티의 고유한 특성을 보존할 수 있다는 장점이 있었지만, 모달리티 간의 초기 단계에서의 상호작용을 충분히 반영하지 못한다는 한계가 있었습니다.</p>
<p>이 시기의 대표적인 모델로는 이미지와 단어 임베딩을 같은 공간에 투영하여 이미지-텍스트 간 유사도를 계산하는 <strong>DeViSE (Frome et al., 2013)</strong>, 이미지 캡셔닝을 위해 CNN과 RNN을 결합하고 멀티모달 정보를 융합하는 계층(multimodal layer)을 추가한 <strong>m-RNN (Mao et al., 2014)</strong> 등이 있습니다.</p>
</section>
<section id="어텐션-메커니즘-도입-2010년대-중반" class="level4">
<h4 class="anchored" data-anchor-id="어텐션-메커니즘-도입-2010년대-중반">어텐션 메커니즘 도입 (2010년대 중반)</h4>
<p>2010년대 중반, 어텐션 메커니즘(attention mechanism)의 등장은 멀티모달 딥러닝 연구에 큰 전환점을 가져왔습니다. 어텐션 메커니즘은 이미지와 텍스트 간의 관련성을 더욱 정교하게 모델링할 수 있도록 해주었습니다. 예를 들어, 이미지 캡셔닝에서 어텐션은 특정 단어를 생성할 때 이미지의 어떤 영역에 “주목”해야 하는지를 학습할 수 있게 하였고, VQA에서는 질문에 답하기 위해 이미지의 어떤 부분을 봐야 하는지를 결정하는 데 도움을 주었습니다.</p>
<p>어텐션 메커니즘의 도입은 이미지 캡셔닝과 VQA 모델의 성능을 크게 향상시켰습니다. 대표적인 모델로는 이미지 캡셔닝에 어텐션을 도입하여 생성되는 단어와 관련된 이미지 영역에 집중하도록 한 <strong>Show, Attend and Tell (Xu et al., 2015)</strong>, VQA에서 질문에 대한 답변을 생성하기 위해 이미지에 여러 번 어텐션을 적용하는 <strong>Stacked Attention Networks (Yang et al., 2016)</strong> 등이 있습니다.</p>
</section>
<section id="트랜스포머-등장과-멀티모달-혁신-2017년-이후" class="level4">
<h4 class="anchored" data-anchor-id="트랜스포머-등장과-멀티모달-혁신-2017년-이후">트랜스포머 등장과 멀티모달 혁신 (2017년 이후)</h4>
<p>2017년, “Attention is All You Need” 논문에서 트랜스포머(Transformer) 아키텍처가 소개되면서 멀티모달 딥러닝은 새로운 국면을 맞이했습니다. 트랜스포머는 셀프 어텐션(self-attention) 메커니즘을 기반으로 하여 입력 시퀀스 내의 모든 요소 간의 관계를 직접적으로 모델링할 수 있다는 장점을 가졌습니다.</p>
<ul>
<li><p><strong>ViT (Vision Transformer, 2020):</strong> 이미지를 패치(patch)로 나누어 트랜스포머에 입력하는 ViT는 이미지 처리 분야에서 CNN의 강력한 대안으로 떠올랐습니다. ViT는 이미지 내의 장거리 의존성(long-range dependency)을 효과적으로 모델링하여 이미지 분류 등 다양한 태스크에서 뛰어난 성능을 보였습니다.</p></li>
<li><p><strong>CLIP (Contrastive Language-Image Pre-training, 2021):</strong> CLIP은 대규모 이미지-텍스트 쌍 데이터를 사용하여 이미지와 텍스트를 같은 공간에 임베딩하는 방법을 학습했습니다. 이를 통해 별도의 fine-tuning 없이도 다양한 downstream task(이미지 분류, 객체 검출 등)에서 zero-shot(별도의 학습 없이 바로 적용)으로 뛰어난 성능을 보이는 획기적인 결과를 보여주었습니다.</p></li>
<li><p><strong>DALL-E (2021), Imagen (2022), Stable Diffusion (2022):</strong> 텍스트 설명을 기반으로 고품질 이미지를 생성하는 모델들은 트랜스포머 기반 생성 모델의 놀라운 능력을 보여주었습니다. 이들은 텍스트와 이미지 간의 복잡한 관계를 학습하여, 이전에 상상하기 어려웠던 수준의 이미지 생성 결과를 보여주었습니다.</p></li>
<li><p><strong>GPT-4V (2023), Gemini (2023):</strong> 텍스트와 이미지를 동시에 이해하고 처리하는 대규모 멀티모달 모델(LMM, Large Multimodal Model)의 등장은 멀티모달 딥러닝의 새로운 가능성을 열었습니다. 수십억 개의 파라미터를 가진 이 거대 모델들은 다양한 멀티모달 task에서 인간 수준의 성능을 달성하며, 인공지능 연구의 최전선에 서 있습니다.</p></li>
</ul>
</section>
<section id="최근-동향-지능의-확장과-융합" class="level4">
<h4 class="anchored" data-anchor-id="최근-동향-지능의-확장과-융합">최근 동향: 지능의 확장과 융합</h4>
<p>최근 멀티모달 딥러닝 연구는 단순한 정보 융합을 넘어, 각 모달리티의 정보를 바탕으로 새로운 지식을 생성하고 추론하는 능력을 향상시키는 방향으로 발전하고 있습니다.</p>
<ul>
<li><p><strong>LMM (Large Multimodal Model)의 발전:</strong> 더 많은 모달리티(오디오, 비디오, 3D 센서 데이터 등)를 통합하고, 더 복잡한 추론 능력을 갖춘 LMM들이 계속해서 등장하고 있습니다.</p></li>
<li><p><strong>효율적인 융합 기법 연구:</strong> 한편으로는, 제한된 컴퓨팅 자원에서도 멀티모달 모델을 효과적으로 활용하기 위해 계산 비용을 줄이면서도 정보 융합의 효과를 극대화하는 효율적인 융합 기법에 대한 연구도 활발히 진행되고 있습니다.</p></li>
<li><p><strong>설명 가능성(XAI) 및 윤리적 문제:</strong> 멀티모달 모델의 복잡성이 증가함에 따라, 모델의 의사 결정 과정을 이해하고, 편향성 등 윤리적 문제를 해결하기 위한 연구의 중요성도 커지고 있습니다.</p></li>
</ul>
<p>다음 절에서는 멀티모달 딥러닝의 초기 접근법들과, 그 과정에서 “살아남은” 주요 아키텍처를 좀 더 자세히 살펴보겠습니다.</p>
</section>
</section>
</section>
<section id="초기-멀티모달-접근법" class="level2">
<h2 class="anchored" data-anchor-id="초기-멀티모달-접근법">10.2 초기 멀티모달 접근법</h2>
<p>10.1.3절에서 살펴본 것처럼, 트랜스포머와 CLIP은 멀티모달 딥러닝의 혁신을 가져왔습니다. 하지만 이러한 발전은 갑자기 이루어진 것이 아닙니다. 그 이전에도 이미지와 텍스트, 나아가 다양한 모달리티를 결합하려는 수많은 시도가 있었고, 이러한 초기 연구들이 현대 멀티모달 딥러닝의 탄탄한 기반을 다졌습니다. 이 절에서는 2010년대 초중반, 딥러닝 기반 멀티모달 연구의 초창기를 이끌었던 주요 접근법과 그 의의를 살펴보겠습니다.</p>
<section id="이미지-캡셔닝-멀티모달-융합의-첫걸음" class="level3">
<h3 class="anchored" data-anchor-id="이미지-캡셔닝-멀티모달-융합의-첫걸음">10.2.1 이미지 캡셔닝: 멀티모달 융합의 첫걸음</h3>
<p>이미지 캡셔닝(Image Captioning)은 주어진 이미지를 설명하는 자연어 문장(캡션)을 자동으로 생성하는 task입니다. 이는 이미지(시각 정보)를 텍스트(언어 정보)로 변환하는 대표적인 멀티모달 문제로, 딥러닝 기반 멀티모달 연구의 초기 주된 연구 대상이었습니다. 이미지 캡셔닝은 마치 어린아이가 그림책을 보면서 “여기에는 강아지가 있고, 저기에는 공이 있네!”라고 말하는 것과 유사합니다.</p>
<section id="초기-cnn-rnn-구조-2014년-이전" class="level4">
<h4 class="anchored" data-anchor-id="초기-cnn-rnn-구조-2014년-이전">초기 CNN-RNN 구조 (2014년 이전)</h4>
<p>이미지 캡셔닝 연구 초기에는 CNN과 RNN을 결합한 모델이 주를 이루었습니다. 흡사 딥러닝이라는 뇌에 시각을 담당하는 CNN과 언어를 담당하는 RNN이라는 두 개의 반구를 연결하는 것과 같았습니다. CNN은 이미지 인코더로서 VGGNet, AlexNet 등을 사용하여 이미지의 특징 벡터를 추출했고, RNN은 텍스트 디코더로서 LSTM과 같은 모델을 사용하여 이미지 특징 벡터를 바탕으로 캡션 문장을 생성했습니다.</p>
<p>대표적인 모델로는 Show and Tell (Vinyals et al., 2015)이 있으며, 이 모델은 CNN으로 추출한 이미지 특징을 LSTM의 초기 hidden state로 입력하여 캡션을 생성하는 end-to-end 방식을 제안했습니다. 그러나 이러한 CNN-RNN 구조는 이미지의 전반적인 내용은 잘 파악했지만, 이미지의 세부적인 영역과 텍스트의 특정 단어 간의 대응 관계를 명확하게 모델링하지 못하는 한계가 있었습니다.</p>
</section>
<section id="어텐션-메커니즘-도입-2015년-이후" class="level4">
<h4 class="anchored" data-anchor-id="어텐션-메커니즘-도입-2015년-이후">어텐션 메커니즘 도입 (2015년 이후)</h4>
<p>이미지의 특정 영역에 “주목”하는 어텐션 메커니즘은 이미지 캡셔닝 모델의 성능을 크게 향상시켰습니다. 어텐션은 마치 그림을 감상할 때 우리의 시선이 자연스럽게 중요한 부분으로 향하는 것과 같은 원리입니다.</p>
<p>어텐션 메커니즘에는 Soft Attention과 Hard Attention이 있습니다. Soft Attention은 이미지의 모든 영역에 대한 가중치를 계산하고 가중 평균된 특징 벡터를 사용하는 반면, Hard Attention은 이미지의 특정 영역 하나만을 선택하여 캡션을 생성합니다.</p>
<p>Show, Attend and Tell (Xu et al., 2015)은 Soft Attention 메커니즘을 이미지 캡셔닝에 처음으로 도입한 모델로, 캡션의 각 단어를 생성할 때마다 이미지의 어떤 영역에 주목해야 하는지를 학습하여 더 정확하고 상세한 캡션을 생성할 수 있게 되었습니다.</p>
</section>
<section id="bottom-up-and-top-down-attention-2017년-이후" class="level4">
<h4 class="anchored" data-anchor-id="bottom-up-and-top-down-attention-2017년-이후">Bottom-Up and Top-Down Attention (2017년 이후)</h4>
<p>2017년 이후에는 이미지의 전체적인 맥락(top-down)과 개별 객체(bottom-up) 정보를 모두 활용하는 Bottom-Up and Top-Down Attention 방식이 등장했습니다. Bottom-up 접근법은 Faster R-CNN과 같은 객체 탐지 모델을 사용하여 이미지 내의 주요 객체들을 식별하고, Top-down 접근법은 캡션 생성 과정에서 이러한 객체 특징에 대한 어텐션 가중치를 계산합니다.</p>
<p>Bottom-Up and Top-Down Attention (Anderson et al., 2018) 모델은 이 두 접근법을 결합하여 이미지 캡셔닝 성능을 크게 향상시켰습니다. 이는 마치 전체적인 이야기의 흐름을 고려하면서, 각 장면에 등장하는 객체들을 상세히 묘사하는 것과 같습니다.</p>
</section>
<section id="딥러닝-dna-관점에서-본-이미지-캡셔닝의-진화" class="level4">
<h4 class="anchored" data-anchor-id="딥러닝-dna-관점에서-본-이미지-캡셔닝의-진화">딥러닝 DNA 관점에서 본 이미지 캡셔닝의 진화</h4>
<p>이미지 캡셔닝 연구는 딥러닝 DNA에 중요한 요소들을 추가했습니다. CNN-RNN 결합은 서로 다른 모달리티를 효과적으로 결합하는 기본적인 틀을 제시했고, 어텐션 메커니즘은 멀티모달 딥러닝에서 핵심적인 기술로 자리 잡았습니다. 또한 Bottom-Up and Top-Down Attention은 딥러닝 모델의 이미지 이해 능력을 한 단계 끌어올렸습니다.</p>
<p>이러한 발전은 이미지 캡셔닝을 넘어, 이후 VQA, 멀티모달 기계 번역 등 다양한 멀티모달 task로 확장되는 기반이 되었습니다. 최근에는 BLIP과 같은 트랜스포머 기반 모델이 등장하여, 이미지 캡셔닝뿐만 아니라 다양한 멀티모달 task에서 좋은 성능을 보이고 있습니다.</p>
</section>
<section id="이미지-캡셔닝-모델-blip-예제" class="level4">
<h4 class="anchored" data-anchor-id="이미지-캡셔닝-모델-blip-예제">이미지 캡셔닝 모델 (BLIP) 예제</h4>
<p>BLIP(Bootstrapping Language-Image Pre-training)은 이미지 캡셔닝을 위한 트랜스포머 기반 모델입니다. BLIP은 이미지와 텍스트를 함께 사전 학습하여, 이미지 캡셔닝뿐만 아니라 VQA, 이미지-텍스트 검색 등 다양한 멀티모달 task에서 좋은 성능을 보입니다.</p>
<p>다음은 Hugging Face Transformers 라이브러리를 사용하여 BLIP 모델로 이미지 캡션을 생성하는 예제 코드입니다.</p>
<div id="cell-3" class="cell" data-execution_count="4">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># !pip install dldna[colab] # in Colab</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co"># !pip install dldna[all] # in your local</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>load_ext autoreload</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>autoreload <span class="dv">2</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="cell-4" class="cell" data-execution_count="5">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> transformers <span class="im">import</span> BlipProcessor, BlipForConditionalGeneration</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> PIL <span class="im">import</span> Image</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> requests</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Load the model and processor</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>processor <span class="op">=</span> BlipProcessor.from_pretrained(<span class="st">"Salesforce/blip-image-captioning-base"</span>)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> BlipForConditionalGeneration.from_pretrained(<span class="st">"Salesforce/blip-image-captioning-base"</span>)</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Download the image</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>url <span class="op">=</span> <span class="st">"http://images.cocodataset.org/val2017/000000000632.jpg"</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>image <span class="op">=</span> Image.<span class="bu">open</span>(requests.get(url, stream<span class="op">=</span><span class="va">True</span>).raw)</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Display the image</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>plt.imshow(image)</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>plt.axis(<span class="st">'off'</span>)</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Preprocess the input</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>inputs <span class="op">=</span> processor(image, return_tensors<span class="op">=</span><span class="st">"pt"</span>)</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate the caption</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>outputs <span class="op">=</span> model.generate(<span class="op">**</span>inputs)</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a><span class="co"># Decode and print the caption</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>caption <span class="op">=</span> processor.decode(outputs[<span class="dv">0</span>], skip_special_tokens<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Generated caption:"</span>, caption)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="10_멀티모달 딥러닝: 다중 감각 융합의 시작_files/figure-html/cell-3-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Generated caption: a bedroom with a bed and a window</code></pre>
</div>
</div>
</section>
</section>
<section id="시각-질의응답vqa-이미지-이해와-추론" class="level3">
<h3 class="anchored" data-anchor-id="시각-질의응답vqa-이미지-이해와-추론">10.2.2 시각 질의응답(VQA): 이미지 이해와 추론</h3>
<p>시각 질의응답(Visual Question Answering, VQA)은 이미지와 자연어 질문이 주어졌을 때, 이미지 내용을 바탕으로 질문에 대한 답변을 생성하는 task입니다. 이미지 캡셔닝이 이미지의 내용을 “묘사”하는 것이라면, VQA는 이미지에 대해 “질의응답”을 하는 것입니다. 예를 들어 “고양이는 뭘 먹고 있지?”라는 질문에 답을 하는 것입니다. VQA는 이미지 캡셔닝보다 더 복잡하고 고차원적인 이미지 이해 능력, 특히 이미지와 질문(텍스트) 간의 관계를 파악하고 추론하는 능력을 요구합니다.</p>
<section id="초기-vqa-모델-cnn-rnn-2015년-이전" class="level4">
<h4 class="anchored" data-anchor-id="초기-vqa-모델-cnn-rnn-2015년-이전"><strong>초기 VQA 모델 (CNN + RNN) (2015년 이전)</strong></h4>
<p>이미지 캡셔닝과 마찬가지로, 초기 VQA 모델은 CNN과 RNN을 결합한 구조를 사용했습니다. CNN으로 이미지 특징을 추출하고, RNN으로 질문을 인코딩한 후, 이 두 특징을 결합하여 답변을 생성했습니다. 하지만 단순히 이미지 특징과 질문 특징을 결합하는 것만으로는 복잡한 질문에 답하기 어려웠습니다.</p>
</section>
<section id="멀티모달-어텐션-메커니즘-2016년-이후" class="level4">
<h4 class="anchored" data-anchor-id="멀티모달-어텐션-메커니즘-2016년-이후"><strong>멀티모달 어텐션 메커니즘 (2016년 이후)</strong></h4>
<p>이미지 캡셔닝에서 어텐션 메커니즘이 성공을 거두면서, VQA에도 어텐션 메커니즘이 도입되었습니다. Co-Attention은 이미지와 질문 양쪽에 어텐션을 적용하여, 질문의 각 단어와 이미지의 각 영역 간의 관련성을 계산합니다. 이를 통해 질문에 관련된 이미지 영역을 더 정확하게 찾을 수 있습니다.</p>
<p>Stacked Attention은 어텐션을 여러 번 반복하여, 이미지와 질문 간의 복잡한 관계를 단계적으로 파악합니다. 이는 마치 탐정이 사진을 여러 번 훑어보면서 질문과의 관련성을 점차 깊이 이해하는 것과 같습니다.</p>
<p>대표적인 모델로는 Stacked Attention Networks (SAN) (Yang et al., 2016)와 Dual Attention Networks (DAN) (Nam et al., 2017)이 있습니다. SAN은 질문에 대한 답변을 생성하기 위해 이미지에 여러 번 어텐션을 적용하는 모델이고, DAN은 이미지와 질문 각각에 대한 어텐션을 별도로 계산하고, 이들을 결합하여 답변을 생성하는 모델입니다.</p>
</section>
<section id="외부-지식-통합-2018년-이후" class="level4">
<h4 class="anchored" data-anchor-id="외부-지식-통합-2018년-이후">외부 지식 통합 (2018년 이후)</h4>
<p>이미지 캡셔닝과 VQA의 가장 큰 차이는 외부지식 통합입니다. VQA 모델의 추론 능력을 더욱 향상시키기 위해 외부 지식(상식, 백과사전 지식 등)을 활용하는 연구가 진행되었습니다. Knowledge Base (KB)는 Wikipedia, ConceptNet 등 구조화된 지식 베이스를 활용하여, 질문에 대한 답변을 찾는 데 필요한 정보를 제공합니다.</p>
<p>Memory Networks는 외부 지식을 메모리 형태로 저장하고, 질문에 따라 메모리에서 관련 정보를 검색하여 답변 생성에 활용합니다. 그러나 외부 지식을 효과적으로 활용하는 것은 여전히 어려운 과제입니다. 지식 베이스의 불완전성, 질문과의 관련성 판단, 추론 과정의 복잡성 등 해결해야 할 문제가 많습니다.</p>
</section>
<section id="딥러닝-dna-관점에서-본-vqa의-진화" class="level4">
<h4 class="anchored" data-anchor-id="딥러닝-dna-관점에서-본-vqa의-진화">딥러닝 DNA 관점에서 본 VQA의 진화</h4>
<p>VQA 연구는 딥러닝 DNA에 중요한 유전자를 추가했습니다. CNN-RNN 결합은 이미지와 텍스트를 결합하는 기본적인 틀을 이미지 캡셔닝과 공유합니다. 멀티모달 어텐션은 이미지와 질문 간의 복잡한 관계를 모델링하는 능력을 딥러닝 모델에 부여했습니다. 이는 딥러닝 모델이 단순히 정보를 결합하는 것을 넘어, 정보 간의 상호작용을 이해하고 추론하는 능력을 갖추게 했음을 의미합니다.</p>
<p>외부 지식 통합은 딥러닝 모델이 외부 지식을 활용하여 더 높은 수준의 추론을 수행할 수 있는 가능성을 열었습니다. 이는 딥러닝 모델이 단순히 데이터에만 의존하는 것이 아니라, 인간의 지식과 경험을 활용할 수 있음을 보여줍니다.</p>
<p>10.2.1절과 10.2.2절에서 살펴본 이미지 캡셔닝과 VQA는 초기 멀티모달 딥러닝 연구의 중요한 두 축이었습니다. 이들 연구는 CNN, RNN, 어텐션 메커니즘 등 딥러닝의 핵심 기술을 멀티모달 문제에 적용하고 발전시키는 데 크게 기여했으며, 이후 트랜스포머 기반의 더욱 강력한 멀티모달 모델(CLIP, DALL-E, GPT-4V, Gemini 등)이 등장하는 데 중요한 발판이 되었습니다.</p>
<p>최근에는 ViLT(Vision-and-Language Transformer)와 같은 트랜스포머 기반 VQA 모델이 등장하여 좋은 성능을 보이고 있습니다. ViLT는 이미지 패치와 텍스트 토큰을 동일한 트랜스포머 모델에 입력하여, 이미지와 텍스트 간의 복잡한 상호작용을 효과적으로 모델링합니다.</p>
</section>
<section id="vqa-모델-vilt-예제" class="level4">
<h4 class="anchored" data-anchor-id="vqa-모델-vilt-예제">VQA 모델 (ViLT) 예제</h4>
<p>ViLT(Vision-and-Language Transformer)는 대표적인 트랜스포머 기반 VQA 모델 중 하나입니다. ViLT는 이미지 패치와 텍스트 토큰을 동일한 트랜스포머 모델에 입력하여, 이미지와 텍스트 간의 복잡한 상호작용을 효과적으로 모델링합니다.</p>
<p>다음은 Hugging Face Transformers 라이브러리를 사용하여 ViLT 모델로 VQA를 수행하는 예제 코드입니다.</p>
<div id="cell-6" class="cell" data-execution_count="6">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> transformers <span class="im">import</span> ViltProcessor, ViltForQuestionAnswering</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> PIL <span class="im">import</span> Image</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> requests</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="co"># 모델과 프로세서 로드</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>processor <span class="op">=</span> ViltProcessor.from_pretrained(<span class="st">"dandelin/vilt-b32-finetuned-vqa"</span>)</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> ViltForQuestionAnswering.from_pretrained(<span class="st">"dandelin/vilt-b32-finetuned-vqa"</span>)</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="co"># 이미지 다운로드</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>url <span class="op">=</span> <span class="st">"http://images.cocodataset.org/val2017/000000039769.jpg"</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>image <span class="op">=</span> Image.<span class="bu">open</span>(requests.get(url, stream<span class="op">=</span><span class="va">True</span>).raw)</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a><span class="co"># 이미지 출력</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>plt.imshow(image)</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>plt.axis(<span class="st">'off'</span>)  <span class="co"># 축 제거</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a><span class="co"># 질문 설정</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>question <span class="op">=</span> <span class="st">"How many cats are in the image?"</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Question:"</span>, question)</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a><span class="co"># 입력 전처리</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>encoding <span class="op">=</span> processor(image, question, return_tensors<span class="op">=</span><span class="st">"pt"</span>)</span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a><span class="co"># 추론</span></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>outputs <span class="op">=</span> model(<span class="op">**</span>encoding)</span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>logits <span class="op">=</span> outputs.logits</span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>idx <span class="op">=</span> logits.argmax(<span class="op">-</span><span class="dv">1</span>).item()</span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Predicted answer:"</span>, model.config.id2label[idx])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="10_멀티모달 딥러닝: 다중 감각 융합의 시작_files/figure-html/cell-4-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Question: How many cats are in the image?
Predicted answer: 2</code></pre>
</div>
</div>
</section>
</section>
</section>
<section id="멀티모달-융합fusion-이론-cmu-강의-기반-분류" class="level2">
<h2 class="anchored" data-anchor-id="멀티모달-융합fusion-이론-cmu-강의-기반-분류">10.3 멀티모달 융합(Fusion) 이론 : CMU 강의 기반 분류</h2>
<p>이미지와 텍스트 두가지 정보가 있다고 합시다. 이 두가지 정보를 어떻게 결합할까요? 가장 간단한 방법은 이미지 벡터 뒤에 텍스트 벡터를 연이어서 덧붙여 새로운 벡터를 만드는 것입니다. 이질적인 데이터 소스로부터 정보를 연결하는 것을 융합(Fusion)이라 합니다. 이질적인 두 데이터 특성으로부터 효율적으로 정보를 융합하는 것은 멀티모달의 핵심입니다. 멀티모달 딥러닝을 시작하기 어려운 이유 중 하나는 매우 <strong>빠르게 발전하는 분야라 체계적인 정리가 부족</strong>하기 때문입니다.</p>
<p>이 절에서는 카네기 멜론 대학교(CMU) Multimodal Machine Learning 강의에서 제시하는 방식을 기반으로 멀티모달 융합을 세 가지 주요 범주로 나누어 설명하겠습니다. 이러한 분류는 현재 멀티모달 연구의 표준적인 분류는 아니지만, 다양한 융합 기법을 체계적으로 이해하는 데 매우 유용합니다.</p>
<section id="joint-representations" class="level3">
<h3 class="anchored" data-anchor-id="joint-representations">10.3.1 Joint Representations</h3>
<p>Joint Representations는 여러 모달리티의 데이터를 하나의 공통된 벡터 공간(vector space)에 표현하는 방식입니다. 마치 텍스트와 이미지를 하나의 캔버스에 함께 그려 넣는 것과 같습니다.</p>
<p>각 모달리티의 데이터를 별도로 처리하는 대신, 하나의 통합된 특징 벡터(feature vector)로 융합합니다. 이 벡터는 모달리티의 정보를 포함해 담게 됩니다. 이를 통해 모델은 각 모달리티 간의 깊은 상관관계를 학습할 수 있습니다. 하나의 모델로 여러 모달리티를 처리할 수 있습니다. 또한 여러 모달리티의 정보를 하나의 벡터에 압축하여 표현하므로 모델 구조가 비교적 간단하고 효율적입니다. 그러나 각 모달리티의 고유한 특징이 융합 과정에서 희석되거나 손실될 수 있습니다. 특정 모달리티가 다른 모달리티보다 훨씬 더 많은 정보를 가진 경우, 정보 불균형 문제가 발생할 수 있습니다. 그리고 서로 다른 모달리티의 데이터를 하나의 의미 있는 벡터로 융합하는 것은 매우 어려운 문제입니다.</p>
<p>가장 단순한 방법으로 각 모달리티의 특징 벡터를 단순히 이어 붙이는(concatenate) 방식이 있습니다. 이 외에도 Multi-modal Factorization Model(MFM)은 여러 양상 데이터를 행렬 분해를 통해 결합하여 공통의 표현 공간을 생성합니다. Multi-modal Discriminative Binary Embedding(MDBE)는 이미지와 텍스트 같은 멀티모달 데이터를 이진 코드로 표현해 내는 방법입니다.</p>
<p>최근 연구에서는 COSA(Concatenated Sample)와 같은 방법이 제안되었는데, 이는 여러 이미지-텍스트 쌍을 순차적으로 연결하고 트랜스포머 기반 모델을 적용하여 시각적 콘텐츠와 시간적 단서를 공동으로 학습합니다. 또한 Attentional Concatenation은 텍스트에서 고해상도 이미지를 생성하기 위한 방법으로, 다중 레벨 계단식 구조를 사용하고 이전 레이어의 결과와 단어 벡터를 다음 레이어의 입력으로 활용합니다.</p>
<p><strong>구조 예시</strong></p>
<p>다음은 3가지 방식(Concatenation, MFM, MDBF)의 융합을 도식화 한 것입니다.</p>
<p><img src="../../../assets/images/10_01.png" width="800"></p>
<p><strong>예제</strong></p>
<div id="cell-8" class="cell" data-execution_count="7">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> transformers <span class="im">import</span> AutoModel, AutoProcessor, AutoTokenizer</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> PIL <span class="im">import</span> Image</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> requests</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Load pre-trained models and processor/tokenizer for image and text</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>image_model_name <span class="op">=</span> <span class="st">"google/vit-base-patch16-224-in21k"</span>  <span class="co"># ViT (Vision Transformer)</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>text_model_name <span class="op">=</span> <span class="st">"bert-base-uncased"</span>  <span class="co"># BERT</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>image_processor <span class="op">=</span> AutoProcessor.from_pretrained(image_model_name)</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>image_model <span class="op">=</span> AutoModel.from_pretrained(image_model_name)</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>tokenizer <span class="op">=</span> AutoTokenizer.from_pretrained(text_model_name)</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>text_model <span class="op">=</span> AutoModel.from_pretrained(text_model_name)</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Example image and text</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>url <span class="op">=</span> <span class="st">"http://images.cocodataset.org/val2017/000000039769.jpg"</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>image <span class="op">=</span> Image.<span class="bu">open</span>(requests.get(url, stream<span class="op">=</span><span class="va">True</span>).raw)</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>text <span class="op">=</span> <span class="st">"Two cats sleeping on a couch."</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Display the image</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>plt.imshow(image)</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>plt.axis(<span class="st">'off'</span>)  <span class="co"># Remove axes</span></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a><span class="co"># Preprocess image and text</span></span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>image_inputs <span class="op">=</span> image_processor(images<span class="op">=</span>image, return_tensors<span class="op">=</span><span class="st">"pt"</span>)</span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>text_inputs <span class="op">=</span> tokenizer(text, return_tensors<span class="op">=</span><span class="st">"pt"</span>)</span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a><span class="co"># Feature extraction (embeddings) for each modality</span></span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> torch.no_grad():  <span class="co"># Disable gradient calculation (inference mode)</span></span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a>    image_features <span class="op">=</span> image_model(<span class="op">**</span>image_inputs).last_hidden_state[:, <span class="dv">0</span>, :]  <span class="co"># [CLS] token embedding</span></span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a>    text_features <span class="op">=</span> text_model(<span class="op">**</span>text_inputs).last_hidden_state[:, <span class="dv">0</span>, :]   <span class="co"># [CLS] token embedding</span></span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a><span class="co"># Create Joint Representation (Concatenation)</span></span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true" tabindex="-1"></a>joint_representation <span class="op">=</span> torch.cat((image_features, text_features), dim<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Image Features Shape:"</span>, image_features.shape)  <span class="co"># Image feature vector size</span></span>
<span id="cb6-41"><a href="#cb6-41" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Text Features Shape:"</span>, text_features.shape)     <span class="co"># Text feature vector size</span></span>
<span id="cb6-42"><a href="#cb6-42" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Joint Representation Shape:"</span>, joint_representation.shape) <span class="co"># Combined feature vector size (image + text)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>Fast image processor class &lt;class 'transformers.models.vit.image_processing_vit_fast.ViTImageProcessorFast'&gt; is available for this model. Using slow image processor class. To use the fast image processor class set `use_fast=True`.</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="10_멀티모달 딥러닝: 다중 감각 융합의 시작_files/figure-html/cell-5-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Image Features Shape: torch.Size([1, 768])
Text Features Shape: torch.Size([1, 768])
Joint Representation Shape: torch.Size([1, 1536])</code></pre>
</div>
</div>
</section>
<section id="coordinated-representations" class="level3">
<h3 class="anchored" data-anchor-id="coordinated-representations">10.3.2 Coordinated Representations</h3>
<p>Coordinated Representations는 각 모달리티를 별도의 공간에 표현하되, 이들 간의 관계를 명시적으로 학습하는 방식입니다. 여러 개의 캔버스 그림을 각 캔버스가 서로 조화를 이루도록 하는 것과 같습니다.</p>
<p>각 모달리티를 별도의 특징 벡터로 표현하지만, 이 벡터들이 서로 “협력(coordinate)”하도록 학습합니다. 즉, 각 모달리티의 특징 공간은 독립적이지만, 이들 간의 유사성, 순서 관계 등을 학습하여 서로 의미 있는 관계를 맺도록 합니다. 이 방식의 장점은 각 모달리티의 고유한 특징을 최대한 보존하면서도, 다른 모달리티와의 관련성을 고려할 수 있다는 점입니다. 또한 다양한 형태의 모달리티 간 관계를 학습할 수 있어, 다양한 멀티모달 문제에 적용 가능합니다.</p>
<p>그러나 각 모달리티를 별도로 처리해야 하므로, 모델 구조가 Joint Representations보다 복잡해질 수 있습니다. 이는 모델 설계 및 훈련을 더 어렵게 만들 수 있습니다. 또한 각 모달리티 간의 관계를 명시적으로 학습하는 것은 쉽지 않은 문제입니다.</p>
<p>대표적인 예로 CLIP(Contrastive Language-Image Pre-training)이 있습니다. CLIP은 이미지와 텍스트를 각각 별도의 인코더로 처리하여 특징 벡터를 얻고, 이들 간의 유사도를 학습합니다. CLIP은 이미지와 텍스트가 서로 “짝”을 이루도록 학습하여, 이미지와 텍스트 간의 의미 있는 관계를 파악합니다.</p>
<p>CLIP의 성공은 zero-shot 학습 능력에서 특히 두드러집니다. 사전 학습된 CLIP 모델은 특정 태스크에 대한 추가 학습 없이도 새로운 이미지를 분류하거나 검색할 수 있습니다. 이는 텍스트와 이미지 간의 의미적 연결을 효과적으로 학습했기 때문에 가능한 것입니다.</p>
<p><strong>구조 예시</strong></p>
<p>다음은 CLIP의 융합을 도식화 한 것입니다.</p>
<p><img src="../../../assets/images/10_02.png" width="800"></p>
<ul>
<li>이미지 인코더: ViT (Vision Transformer) or ResNet</li>
<li>텍스트 인코더: Transformer</li>
</ul>
<p><strong>예제</strong></p>
<div id="cell-10" class="cell" data-execution_count="8">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> transformers <span class="im">import</span> CLIPProcessor, CLIPModel</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> PIL <span class="im">import</span> Image</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> requests</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Load CLIP model and processor</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> CLIPModel.from_pretrained(<span class="st">"openai/clip-vit-base-patch32"</span>)</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>processor <span class="op">=</span> CLIPProcessor.from_pretrained(<span class="st">"openai/clip-vit-base-patch32"</span>)</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Example image and text</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>url <span class="op">=</span> <span class="st">"http://images.cocodataset.org/val2017/000000039769.jpg"</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>image <span class="op">=</span> Image.<span class="bu">open</span>(requests.get(url, stream<span class="op">=</span><span class="va">True</span>).raw)</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>text <span class="op">=</span> <span class="st">"Two cats sleeping on a couch."</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Display image</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>plt.imshow(image)</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>plt.axis(<span class="st">'off'</span>)  <span class="co"># Remove axes</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Preprocess image and text</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>inputs <span class="op">=</span> processor(text<span class="op">=</span>[text], images<span class="op">=</span>image, return_tensors<span class="op">=</span><span class="st">"pt"</span>, padding<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a><span class="co"># Extract image and text features (embeddings)</span></span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> torch.no_grad():</span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>    outputs <span class="op">=</span> model(<span class="op">**</span>inputs)</span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a>    image_features <span class="op">=</span> outputs.image_embeds</span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>    text_features <span class="op">=</span> outputs.text_embeds</span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a><span class="co"># Coordinated Representation: Keep features of each modality separate</span></span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Image Features Shape:"</span>, image_features.shape)</span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Text Features Shape:"</span>, text_features.shape)</span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate similarity between image and text (dot product)</span></span>
<span id="cb9-35"><a href="#cb9-35" aria-hidden="true" tabindex="-1"></a>similarity <span class="op">=</span> torch.matmul(image_features, text_features.T)  <span class="co"># Or text_features @ image_features.T</span></span>
<span id="cb9-36"><a href="#cb9-36" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Image-Text Similarity:"</span>, similarity.item())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="10_멀티모달 딥러닝: 다중 감각 융합의 시작_files/figure-html/cell-6-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Image Features Shape: torch.Size([1, 512])
Text Features Shape: torch.Size([1, 512])
Image-Text Similarity: 0.29803216457366943</code></pre>
</div>
</div>
<p>위 방식을 응용하면 다음과 같이 간단한 제로샷 테스트가 가능합니다.</p>
<div id="cell-12" class="cell" data-execution_count="9">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Zero-shot 이미지 분류</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="co">#   - 여러 텍스트 후보군을 만들고, 각 텍스트와 이미지 간의 유사도를 계산하여 가장 높은 유사도를 갖는 텍스트를 선택</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>candidate_texts <span class="op">=</span> [<span class="st">"a photo of a cat"</span>, <span class="st">"a photo of a dog"</span>, <span class="st">"a photo of a bird"</span>]</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>inputs <span class="op">=</span> processor(text<span class="op">=</span>candidate_texts, images<span class="op">=</span>image, return_tensors<span class="op">=</span><span class="st">"pt"</span>, padding<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> torch.no_grad():</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    outputs <span class="op">=</span> model(<span class="op">**</span>inputs)</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    image_features <span class="op">=</span> outputs.image_embeds</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>    text_features <span class="op">=</span> outputs.text_embeds</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    logits_per_image <span class="op">=</span> outputs.logits_per_image <span class="co"># 유사도 점수</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>probs <span class="op">=</span> logits_per_image.softmax(dim<span class="op">=</span><span class="dv">1</span>)  <span class="co">#  확률</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>predicted_class_idx <span class="op">=</span> probs.argmax().item()</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>predicted_class <span class="op">=</span> candidate_texts[predicted_class_idx]</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Predicted Class:"</span>, predicted_class)</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Probabilities:"</span>, probs)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Predicted Class: a photo of a cat
Probabilities: tensor([[9.9403e-01, 5.1377e-03, 8.3070e-04]])</code></pre>
</div>
</div>
</section>
<section id="encoder-decoder" class="level3">
<h3 class="anchored">10.3.3 Encoder-Decoder</h3>
<p>Encoder-Decoder는 한 모달리티의 데이터를 다른 모달리티의 데이터로 변환하는 방식입니다. 통상 언어 번역에서 흔히 사용하는 기법입니다.</p>
<p>이 구조에서 인코더(Encoder)는 입력 모달리티(예: 이미지)의 데이터를 특징 벡터로 변환합니다. 이 특징 벡터는 입력 데이터의 핵심 정보를 압축적으로 표현합니다. 디코더(Decoder)는 인코더가 생성한 특징 벡터를 바탕으로 다른 모달리티의 데이터(예: 텍스트)를 생성합니다. 디코더는 인코더의 출력을 “해석”하여 새로운 형태의 데이터를 만들어냅니다. 또한 어텐션 메커니즘을 통해 디코더가 출력 데이터를 생성할 때, 인코더의 특징 벡터 중 어떤 부분에 “주목”해야 하는지를 학습합니다.</p>
<p>이 방식의 장점은 이미지 캡셔닝, VQA, 기계 번역 등 서로 다른 형태의 데이터를 연결하는 다양한 task에 적용할 수 있다는 점입니다. 또한 입력과 출력 모달리티가 달라도 적용 가능하며, 텍스트-이미지, 이미지-텍스트, 오디오-텍스트 등 다양한 조합이 가능합니다.</p>
<p>대표적인 예로는 이미지 캡셔닝과 VQA(Visual Question Answering)가 있습니다. 이미지 캡셔닝은 이미지를 인코더로 처리하여 특징 벡터를 얻고, 디코더를 사용하여 캡션(텍스트)을 생성합니다. VQA는 이미지와 질문(텍스트)을 각각 인코더로 처리하고, 어텐션 메커니즘을 사용하여 이미지와 질문 간의 관련성을 파악한 후, 디코더를 사용하여 답변(텍스트)을 생성합니다.</p>
<p>그러나 입력 또는 출력 데이터가 길어질 경우, 정보 손실이 발생하거나 계산량이 증가할 수 있습니다. 특히 RNN 기반 모델의 경우, 기울기 소실 문제(gradient vanishing problem)로 인해 장거리 의존성 학습이 어려울 수 있습니다. 또한 인코더와 디코더를 동시에 학습해야 하므로, 학습이 불안정하거나 어려울 수 있습니다.</p>
<p><strong>구조 예시</strong></p>
<p>다음은 인코더-디코더 융합을 도식화 한 것입니다.</p>
<p><img src="../../../assets/images/10_03.png" width="800"></p>
<ul>
<li>Image Input, Text Input: 각각 이미지와 텍스트 입력 (질문 또는 다른 텍스트 정보)을 나타냅니다.</li>
<li>Image Encoder, Text Encoder: 각 모달리티에 대한 인코더입니다. 이미지 인코더로는 주로 CNN 또는 ViT(Vision Transformer)가 사용되고, 텍스트 인코더로는 RNN 또는 Transformer가 사용됩니다.</li>
<li>Attention: 디코더가 텍스트를 생성할 때, 이미지 특징(Image Encoder의 Features)의 어떤 부분에 “주목”해야 할지를 결정하는 메커니즘입니다. Text Encoder의 Features도 Attention에 사용될 수 있습니다 (Cross-Modal Attention).</li>
</ul>
<p><strong>예제</strong></p>
<div id="cell-14" class="cell" data-execution_count="10">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> transformers <span class="im">import</span> BlipProcessor, BlipForConditionalGeneration</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> PIL <span class="im">import</span> Image</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> requests</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Load model and processor</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>processor <span class="op">=</span> BlipProcessor.from_pretrained(<span class="st">"Salesforce/blip-image-captioning-base"</span>)</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> BlipForConditionalGeneration.from_pretrained(<span class="st">"Salesforce/blip-image-captioning-base"</span>)</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Download image</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>url <span class="op">=</span> <span class="st">"http://images.cocodataset.org/val2017/000000000139.jpg"</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>image <span class="op">=</span> Image.<span class="bu">open</span>(requests.get(url, stream<span class="op">=</span><span class="va">True</span>).raw)</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Display image</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>plt.imshow(image)</span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>plt.axis(<span class="st">'off'</span>)</span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Input text (optional - Conditional Generation)</span></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a><span class="co"># text = "describe this image:"  # Prompt (guide image description)</span></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a>text <span class="op">=</span> <span class="st">"a photo of"</span></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Preprocess image and text (optional)</span></span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a><span class="co"># If text is provided, it uses the text as a prompt to generate the caption.</span></span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a>inputs <span class="op">=</span> processor(image, text<span class="op">=</span>text, return_tensors<span class="op">=</span><span class="st">"pt"</span>)</span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate caption</span></span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true" tabindex="-1"></a>outputs <span class="op">=</span> model.generate(<span class="op">**</span>inputs)</span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-30"><a href="#cb13-30" aria-hidden="true" tabindex="-1"></a><span class="co"># Decode and print caption</span></span>
<span id="cb13-31"><a href="#cb13-31" aria-hidden="true" tabindex="-1"></a>caption <span class="op">=</span> processor.decode(outputs[<span class="dv">0</span>], skip_special_tokens<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb13-32"><a href="#cb13-32" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Generated caption:"</span>, caption)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="10_멀티모달 딥러닝: 다중 감각 융합의 시작_files/figure-html/cell-8-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Generated caption: a photo of a living room with a television and a fireplace</code></pre>
</div>
</div>
<p>이 예제는 Encoder-Decoder 구조의 대표적인 예시인 이미지 캡셔닝을 보여줍니다. 인코더는 이미지(BLIP의 visual encoder)를 입력받아 특징 벡터를 추출합니다. 디코더는 텍스트(BLIP의 text decoder)를 생성합니다. 어텐션 메커니즘을 통해 이미지 특징 벡터의 어느 부분에 주목할지 결정하면서 캡션을 생성합니다. text로 생성되는 캡션에 영향을 주는 prompt를 지정할 수 있습니다. BLIP은 이미지와 텍스트를 모두 입력으로 사용가능하지만 여기서는 이미지만 입력으로 사용하고 텍스트는 디코더에서 생성합니다.</p>
<p>10.3.1, 10.3.2, 10.3.3절에서는 멀티모달 융합의 세 가지 핵심 이론인 Joint Representations, Coordinated Representations, Encoder-Decoder를 살펴보았습니다. 각 방식은 고유의 특징과 장단점을 가지고 있으므로 응용 분야에 따라 적절한 방식을 선택하는 것이 중요합니다.</p>
<div class="callout callout-style-default callout-note callout-titled" title="클릭하여 내용 보기 (딥다이브: 멀티모달 융합과 최신 연구 동향)">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-1-contents" aria-controls="callout-1" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
클릭하여 내용 보기 (딥다이브: 멀티모달 융합과 최신 연구 동향)
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-1" class="callout-1-contents callout-collapse collapse">
<section id="멀티모달-융합fusion과-최신-연구-동향" class="level2 callout-body-container callout-body">
<h2 class="anchored" data-anchor-id="멀티모달-융합fusion과-최신-연구-동향">멀티모달 융합(Fusion)과 최신 연구 동향</h2>
<p>멀티모달 딥러닝에서 “융합(Fusion)”은 서로 다른 모달리티의 정보를 결합하여 더 풍부하고 강력한 표현을 만드는 핵심 과정입니다. 10.3절에서 CMU 강의 기반의 융합 이론을 간략히 살펴보았지만, 실제 멀티모달 융합 연구는 훨씬 더 다양하고 역동적으로 발전해 왔습니다. 이 딥다이브에서는 융합의 다양한 분류 체계와 최신 연구 동향을 심층적으로 분석하고, 2025년 현재 어떤 기술들이 주목받고 있는지 살펴보겠습니다.</p>
<section id="멀티모달-융합의-다양한-분류" class="level3">
<h3 class="anchored" data-anchor-id="멀티모달-융합의-다양한-분류">1. 멀티모달 융합의 다양한 분류</h3>
<p>멀티모달 융합은 하나의 기준으로만 분류하기 어렵습니다. 연구자들은 다양한 관점에서 융합 방식을 분류하고 있으며, 각 분류는 서로 배타적이지 않고 상호 보완적입니다.</p>
<section id="융합-시점에-따른-분류-early-late-hybrid-fusion" class="level4">
<h4 class="anchored" data-anchor-id="융합-시점에-따른-분류-early-late-hybrid-fusion">1.1 융합 시점에 따른 분류 (Early, Late, Hybrid Fusion)</h4>
<p>이 분류는 멀티모달 딥러닝 모델의 “어느 단계”에서 융합이 일어나는지에 초점을 맞춥니다. (본문 10.3.4절 참조)</p>
<ul>
<li><p><strong>Early Fusion (초기 융합):</strong> 각 모달리티의 “raw” 데이터(또는 매우 초기에 처리된 특징)를 모델의 입력 단계에서 결합합니다.</p>
<ul>
<li><strong>최신 연구:</strong> LUMA 데이터셋(2024년 6월 발표)은 오디오, 이미지, 텍스트 데이터를 포함한 50개 클래스의 멀티모달 벤치마크로, 불확실하고 다양한 모달리티 데이터에서 early fusion의 효과를 검증할 수 있는 환경을 제공합니다. 이 데이터셋은 CIFAR 10/100을 확장하여 세 가지 오디오 코퍼스에서 추출한 오디오 샘플과 Gemma-7B LLM으로 생성한 텍스트 데이터를 포함하며, 다양한 유형과 정도의 불확실성을 제어된 방식으로 주입할 수 있습니다</li>
</ul></li>
<li><p><strong>Late Fusion (후기 융합):</strong> 각 모달리티를 별도의 모델로 처리하고, 마지막 단계에서 각 모델의 출력(예: 예측 결과)을 결합합니다.</p>
<ul>
<li><strong>최신 연구:</strong> 2024년 1월 발표된 연구에 따르면, 의료 진단 분야에서 late fusion(또는 model fusion이라고도 함)은 다양한 모달리티에서 얻은 결정을 결합하는 접근 방식으로, 특히 피부 질환 진단에서 효과적으로 활용되고 있습니다4. 이 방식은 각 모달리티에 특화된 모델을 사용할 수 있어 개별 모달리티의 강점을 최대한 활용할 수 있습니다.</li>
</ul></li>
<li><p><strong>Hybrid Fusion (혼합 융합):</strong> Early Fusion과 Late Fusion을 결합한 방식입니다. 모델의 여러 단계에서 융합을 수행하여, 다양한 수준의 정보를 활용합니다.</p>
<ul>
<li><strong>최신 연구</strong>: CAST(Cross Attention based multimodal fusion of Structure and Text)는 2025년 2월 6일에 발표된 연구로, 재료 과학 분야에서 구조와 텍스트 데이터를 효과적으로 융합하기 위한 하이브리드 접근 방식을 제안했습니다. 이 모델은 노드 레벨과 토큰 레벨의 특성을 결합하여 서로 긴밀하게 상호작용할 수 있도록 설계되었으며, 특히 링크된 쿼리 키-값 기반의 교차 주의 메커니즘을 사용하여 노드와 텍스트의 관계를 적절하게 포착합니다</li>
</ul></li>
</ul>
</section>
<section id="모델-구조에-따른-분류" class="level4">
<h4 class="anchored" data-anchor-id="모델-구조에-따른-분류">1.2 모델 구조에 따른 분류</h4>
<ul>
<li><p><strong>Model-Agnostic Fusion:</strong> 특정 모델에 의존하지 않는 일반적인 융합 기법 (Early, Late, Hybrid Fusion 등).</p></li>
<li><p><strong>Model-Specific Fusion:</strong> 특정 모델 구조에 특화된 융합 기법.</p>
<ul>
<li><p><strong>트랜스포머의 Cross-Modal Attention:</strong> (10.4.2절에서 상세히 설명)</p></li>
<li><p><strong>최신 연구:</strong> 2025년 6월 11일-12일에 개최 예정인 CVPR 워크샵(MULA 2025)에서는 자율주행 분야에서 다양한 센서 데이터(카메라, LiDAR, 레이더 등)를 효과적으로 융합하기 위한 모델 구조에 대한 연구가 논의될 예정입니다. 이 워크샵은 컴퓨터 비전, 멀티미디어, 원격 감지, 로봇공학 커뮤니티 간의 학제 간 상호작용과 협력을 장려하는 것을 목표로 하며, 특히 자율주행 분야에서의 멀티모달 접근 방식에 큰 관심이 집중되고 있습니다.</p></li>
</ul></li>
</ul>
</section>
<section id="기타-분류" class="level4">
<h4 class="anchored" data-anchor-id="기타-분류">1.3 기타 분류</h4>
<ul>
<li><p><strong>대칭적(Symmetric) vs.&nbsp;비대칭적(Asymmetric) 융합:</strong></p>
<ul>
<li><p><strong>대칭적:</strong> 모든 모달리티를 동등하게 취급합니다.</p></li>
<li><p><strong>비대칭적:</strong> 특정 모달리티에 더 큰 비중을 두거나, 다른 역할을 부여합니다.</p></li>
<li><p><strong>최신 연구:</strong> “Learning Deep Multimodal Feature Representation with Asymmetric Multi-layer Fusion”은 단일 네트워크 내에서 다중 레이어에서 멀티모달 특징을 융합하는 효과적인 프레임워크를 제안했습니다. 이 연구는 채널 셔플과 픽셀 시프트라는 두 가지 비대칭 융합 연산을 도입하여 다양한 융합 방향에 따라 서로 다른 특징을 학습합니다. 또한 2025년 1월 발표된 “Multimodal sentiment analysis based on multi-layer feature fusion”은 모달 불균형과 암묵적 표현 조건에서 정확한 감정 분석을 위한 새로운 접근법을 제시했습니다.</p></li>
</ul></li>
<li><p><strong>명시적(Explicit) vs.&nbsp;암시적(Implicit) 융합:</strong></p>
<ul>
<li><p><strong>명시적:</strong> 모달리티 간의 관계를 명시적으로 정의하거나 모델링합니다. (예: 어텐션 메커니즘)</p></li>
<li><p><strong>암시적:</strong> 모달리티 간의 관계를 직접 정의하지 않고, 모델이 학습을 통해 스스로 관계를 파악하도록 합니다. (예: 단순 결합)</p></li>
<li><p><strong>최신 연구:</strong> HCI International 2025 컨퍼런스(25년 6월)에서는 명시적 융합과 암시적 융합의 장단점을 비교하는 연구가 발표될 예정입니다.</p></li>
</ul></li>
</ul>
</section>
</section>
<section id="최신-트렌드-어텐션-기반-융합과-자기지도-학습" class="level3">
<h3 class="anchored" data-anchor-id="최신-트렌드-어텐션-기반-융합과-자기지도-학습">2. 최신 트렌드: 어텐션 기반 융합과 자기지도 학습</h3>
<p>2024-2025년 연구에서 가장 주목받는 융합 방식은 <strong>어텐션 기반 메커니즘</strong>입니다.</p>
<section id="cross-modal-attention" class="level4">
<h4 class="anchored" data-anchor-id="cross-modal-attention">2.1 Cross-Modal Attention</h4>
<ul>
<li><p><strong>개념:</strong> 한 모달리티의 특징을 쿼리(query)로 사용하여 다른 모달리티의 특징(key-value)에 어텐션을 적용합니다. (10.4.2절 참조) 이를 통해, 모델은 한 모달리티의 특정 요소가 다른 모달리티의 어떤 요소와 관련이 있는지 세밀하게 파악할 수 있습니다.</p></li>
<li><p><strong>장점:</strong> 모달리티 간의 세밀하고 유연한 관계를 포착할 수 있습니다. 예를 들어, 이미지 캡셔닝에서 “뛰고 있는”이라는 단어를 생성할 때 이미지 속 개의 “뛰는” 동작에 해당하는 영역에 집중할 수 있습니다.</p></li>
<li><p><strong>최신 연구</strong></p>
<ul>
<li><p>2025년 1월 발표된 “Bi-Att3DDet” 연구에서는 자율주행을 위한 3D 객체 탐지에 양방향 어텐션 기반 융합 방식을 도입했습니다. 이 연구는 LiDAR와 카메라 데이터 간의 상호보완적 정보를 최대한 활용하기 위해 양방향 상호작용 방식을 제안했습니다.</p></li>
<li><p>2024년 3월에 발표되고 2025년 2월에 개정된 “LANMSFF” 연구에서는 다중 시점 얼굴 표정 인식을 위해 경량 어텐션 기반 네트워크와 다중 스케일 특징 융합을 결합했습니다. 이 접근법은 채널 및 공간 어텐션 맵을 동시에 생성하여 중요한 특징을 강조하고 관련 없는 특징을 억제합니다.</p></li>
<li><p>최근 신경과학 연구(2025년)에서는 교차 모달 일치성(cross-modal congruency)이 감각 정보의 처리와 축적에 미치는 영향을 조사했습니다. 이 연구는 청각 및 시각적 자극 간의 일치성이 감각 처리의 초기 단계에서 중요한 역할을 한다는 것을 보여주었습니다.</p></li>
</ul></li>
</ul>
</section>
<section id="multi-head-attention" class="level4">
<h4 class="anchored" data-anchor-id="multi-head-attention">2.2 Multi-head Attention</h4>
<ul>
<li><p><strong>개념:</strong> 여러 개의 어텐션 헤드(head)를 사용하여 다양한 관점에서 모달리티 간 관계를 포착합니다. 각 헤드는 서로 다른 가중치 행렬(W_Q, W_K, W_V)을 사용하여 입력 데이터를 변환하고 어텐션을 계산하므로, 각 헤드는 입력 데이터의 서로 다른 측면(예: 의미, 문법 구조, 스타일)에 집중할 수 있습니다.</p></li>
<li><p><strong>장점:</strong> 다양한 유형의 관계를 동시에 모델링할 수 있어, 더 풍부하고 복잡한 표현을 학습할 수 있습니다. 예를 들어, 이미지와 텍스트를 융합할 때, 어떤 헤드는 이미지 속 객체와 텍스트 속 단어 간의 관계에, 다른 헤드는 이미지의 전반적인 분위기와 텍스트의 어조 간의 관계에 집중할 수 있습니다.</p></li>
<li><p><strong>최신 연구:</strong> 최근 대규모 멀티모달 모델(LMM)들은 이 기법을 더욱 확장하고 정교화하여, 이미지, 텍스트, 오디오, 비디오 등 다양한 모달리티 간의 복잡한 상호작용을 효과적으로 모델링하고 있습니다.</p></li>
</ul>
</section>
<section id="자기지도-학습과-멀티모달-융합" class="level4">
<h4 class="anchored" data-anchor-id="자기지도-학습과-멀티모달-융합">2.3 자기지도 학습과 멀티모달 융합</h4>
<ul>
<li><p><strong>대조 학습(Contrastive Learning):</strong></p>
<ul>
<li><p><strong>개념:</strong> 관련된 모달리티 쌍(예: 이미지와 해당 캡션)은 임베딩 공간에서 가깝게, 관련 없는 쌍은 멀리 위치하도록 학습합니다.</p></li>
<li><p><strong>장점:</strong> 레이블이 없는 대규모 데이터셋에서도 효과적으로 학습할 수 있어, 데이터 부족 문제를 해결하는 데 도움이 됩니다.</p></li>
<li><p><strong>최신 연구:</strong> “Dual-Level Cross-Modal Contrastive Clustering”(2024)은 시각적 표현과 텍스트 의미 간의 간극을 메우기 위한 새로운 대조 학습 방법 제안합니다.</p></li>
</ul></li>
<li><p><strong>마스킹 기반 학습(Masking-based Learning):</strong></p>
<ul>
<li><p><strong>개념:</strong> 입력의 일부를 마스킹하고 이를 다른 모달리티의 정보를 활용하여 복원하도록 학습합니다.</p></li>
<li><p><strong>장점:</strong> 모달리티 간의 상호 보완적 관계를 학습할 수 있습니다. 예를 들어, 이미지의 일부를 가리고 텍스트 설명을 통해 가려진 부분을 예측하거나, 텍스트의 일부 단어를 가리고 이미지를 통해 가려진 단어를 예측하는 방식으로 학습할 수 있습니다.</p></li>
<li><p><strong>최신 연구:</strong> CAST(2025)는 Masked Node Prediction(MNP) 사전 학습 전략을 통해 그래프 구조 노드와 텍스트 토큰 간의 정렬을 개선했습니다.</p></li>
</ul></li>
</ul>
</section>
</section>
<section id="토큰-레벨-vs-인스턴스-레벨-융합-2025년-연구" class="level3">
<h3 class="anchored" data-anchor-id="토큰-레벨-vs-인스턴스-레벨-융합-2025년-연구">3. 토큰 레벨 vs 인스턴스 레벨 융합 (2025년 연구)</h3>
<ul>
<li><p><strong>토큰 레벨 융합(Token-level Fusion):</strong> 각 모달리티의 개별 토큰(이미지 패치, 텍스트 토큰 등) 간의 세밀한 상호작용을 모델링합니다.</p>
<ul>
<li><p><strong>장점:</strong> 더 정교한 모달리티 간 관계 포착이 가능합니다. 예를 들어, 이미지 속 특정 객체와 텍스트 속 특정 단어 간의 직접적인 대응 관계를 학습할 수 있습니다.</p></li>
<li><p><strong>최신 연구:</strong> CAST(2025)는 재료 과학 분야에서 그래프 노드와 텍스트 토큰 간의 토큰 레벨 융합이 인스턴스 레벨 융합보다 우수한 성능을 보인다는 것을 입증했습니다.</p></li>
</ul></li>
<li><p><strong>인스턴스 레벨 융합(Instance-level Fusion):</strong> 각 모달리티의 전체 인스턴스(이미지 전체, 텍스트 전체 등)를 하나의 단위로 취급하여 융합합니다.</p>
<ul>
<li><p><strong>장점:</strong> 계산 효율성이 높고 구현이 간단합니다.</p></li>
<li><p><strong>단점:</strong> 모달리티 내부의 세부적인 관계를 포착하지 못할 수 있습니다.</p></li>
</ul></li>
</ul>
</section>
<section id="결론" class="level3">
<h3 class="anchored" data-anchor-id="결론">4. 결론</h3>
<p>멀티모달 융합은 다양한 방식으로 분류될 수 있으며, 각 분류 방식은 서로 다른 관점을 제공합니다. 실제 연구에서는 이러한 분류들을 조합하여 사용하는 경우가 많습니다.</p>
<p>2025년 현재, 멀티모달 융합 연구는 토큰 레벨의 세밀한 상호작용, 크로스 어텐션 메커니즘, 자기지도 학습 방법을 활용한 효율적인 융합 기법 개발에 초점을 맞추고 있습니다. 특히 CVPR 2025 워크샵(25년 6월, 내슈빌)과 같은 주요 학술 행사에서는 자율주행, 의료 진단, 재료 과학 등 다양한 응용 분야에서의 멀티모달 융합 기술 발전이 활발히 논의될 예정입니다.</p>
<p>이 딥다이브를 통해 멀티모달 융합의 다양한 분류 체계를 이해하고, 각 방식의 특징을 파악함으로써, 앞으로 소개될 다양한 멀티모달 모델들을 더 깊이 있게 분석할 수 있을 것입니다.</p>
</section>
</section>
</div>
</div>
</section>
<section id="모달리티-통합-전략" class="level3">
<h3 class="anchored" data-anchor-id="모달리티-통합-전략">10.3.4 모달리티 통합 전략</h3>
<p>10.3.1절부터 10.3.3절까지 우리는 멀티모달 데이터를 융합하는 방법을 살펴보았습니다. 이것은 이론저인 분류입니다. 실제 멀티모달 모델을 설계할 때는 주어진 문제와 데이터의 특성에 맞춰 <em>어떤 융합 방식을</em>, <em>어느 시점에</em>, <em>어떻게 적용할지</em>를 전략적으로 결정해야 합니다. 이 절에서는 최신 멀티모달 모델들이 채택하고 있는 정교한 모달리티 통합 전략들을 살펴보겠습니다.</p>
<section id="초기-융합early-fusion" class="level4">
<h4 class="anchored" data-anchor-id="초기-융합early-fusion">10.3.4.1 초기 융합(Early Fusion)</h4>
<p>초기 융합은 여러 모달리티의 입력을 모델의 초기 단계에서 결합합니다. 가장 단순한 형태는 각 모달리티의 특징 벡터를 이어 붙이는(concatenate) 방식입니다. 초기 융합의 장점은 모달리티 간의 저수준(low-level) 상호작용을 포착하기 용이하다는 점입니다. 예를 들어, 이미지의 색상과 텍스트의 특정 단어가 강하게 연관되어 있다면, 초기 융합을 통해 이러한 관계를 쉽게 학습할 수 있습니다. 그러나 각 모달리티의 특성을 충분히 활용하지 못할 수 있다는 단점이 있습니다. 특히, 각 모달리티에 특화된 처리가 필요한 경우(예: 이미지에는 CNN, 텍스트에는 RNN), 초기 융합은 비효율적일 수 있습니다.</p>
<p>최근 연구에서는 단순 결합 외에도, 불확실성이 높은 멀티모달 데이터(noisy data) 환경에서 초기 융합의 효과를 검증하는 벤치마크가 제시되었습니다.</p>
<p>초기 융합의 간단한 예를 살펴보겠습니다. Joint Representation 중 concatenation을 사용해서 초기 융합하는 에입니다. 동일한 코드가 사용됩니다. 마지막에 간단한 선형 분류기로 고양이가 있는지 없는지를 판단합니다.</p>
<div id="cell-19" class="cell" data-execution_count="11">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> transformers <span class="im">import</span> AutoModel, AutoProcessor, AutoTokenizer</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> PIL <span class="im">import</span> Image</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> requests</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="co"># 이미지와 텍스트를 위한 사전 학습된 모델 및 프로세서/토크나이저 로드</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>image_model_name <span class="op">=</span> <span class="st">"google/vit-base-patch16-224-in21k"</span>  <span class="co">#  ViT (Vision Transformer)</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>text_model_name <span class="op">=</span> <span class="st">"bert-base-uncased"</span>  <span class="co"># BERT</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>image_processor <span class="op">=</span> AutoProcessor.from_pretrained(image_model_name)</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>image_model <span class="op">=</span> AutoModel.from_pretrained(image_model_name)</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>tokenizer <span class="op">=</span> AutoTokenizer.from_pretrained(text_model_name)</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>text_model <span class="op">=</span> AutoModel.from_pretrained(text_model_name)</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a><span class="co"># 예제 이미지 및 텍스트</span></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>url <span class="op">=</span> <span class="st">"http://images.cocodataset.org/val2017/000000039769.jpg"</span></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>image <span class="op">=</span> Image.<span class="bu">open</span>(requests.get(url, stream<span class="op">=</span><span class="va">True</span>).raw)</span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>text <span class="op">=</span> <span class="st">"Two cats sleeping on a couch."</span></span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a><span class="co"># 이미지 출력</span></span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a>plt.imshow(image)</span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a>plt.axis(<span class="st">'off'</span>)  <span class="co"># 축 제거</span></span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true" tabindex="-1"></a><span class="co"># 이미지와 텍스트 전처리</span></span>
<span id="cb15-29"><a href="#cb15-29" aria-hidden="true" tabindex="-1"></a>image_inputs <span class="op">=</span> image_processor(images<span class="op">=</span>image, return_tensors<span class="op">=</span><span class="st">"pt"</span>)</span>
<span id="cb15-30"><a href="#cb15-30" aria-hidden="true" tabindex="-1"></a>text_inputs <span class="op">=</span> tokenizer(text, return_tensors<span class="op">=</span><span class="st">"pt"</span>)</span>
<span id="cb15-31"><a href="#cb15-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-32"><a href="#cb15-32" aria-hidden="true" tabindex="-1"></a><span class="co"># 각 모달리티에 대한 특징 추출 (임베딩)</span></span>
<span id="cb15-33"><a href="#cb15-33" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> torch.no_grad():  <span class="co"># 기울기 계산 비활성화 (추론 모드)</span></span>
<span id="cb15-34"><a href="#cb15-34" aria-hidden="true" tabindex="-1"></a>    image_features <span class="op">=</span> image_model(<span class="op">**</span>image_inputs).last_hidden_state[:, <span class="dv">0</span>, :]  <span class="co"># [CLS] 토큰 임베딩</span></span>
<span id="cb15-35"><a href="#cb15-35" aria-hidden="true" tabindex="-1"></a>    text_features <span class="op">=</span> text_model(<span class="op">**</span>text_inputs).last_hidden_state[:, <span class="dv">0</span>, :]   <span class="co"># [CLS] 토큰 임베딩</span></span>
<span id="cb15-36"><a href="#cb15-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-37"><a href="#cb15-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-38"><a href="#cb15-38" aria-hidden="true" tabindex="-1"></a><span class="co"># Joint Representation 생성 (Concatenation)</span></span>
<span id="cb15-39"><a href="#cb15-39" aria-hidden="true" tabindex="-1"></a>joint_representation <span class="op">=</span> torch.cat((image_features, text_features), dim<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb15-40"><a href="#cb15-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-41"><a href="#cb15-41" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Image Features Shape:"</span>, image_features.shape)  <span class="co"># 이미지 특징 벡터 크기</span></span>
<span id="cb15-42"><a href="#cb15-42" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Text Features Shape:"</span>, text_features.shape)     <span class="co"># 텍스트 특징 벡터 크기</span></span>
<span id="cb15-43"><a href="#cb15-43" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Joint Representation Shape:"</span>, joint_representation.shape) <span class="co"># 결합된 특징 벡터 크기 (image + text)</span></span>
<span id="cb15-44"><a href="#cb15-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-45"><a href="#cb15-45" aria-hidden="true" tabindex="-1"></a><span class="co">#  Joint Representation을 활용한 추가 작업 (예: 분류)</span></span>
<span id="cb15-46"><a href="#cb15-46" aria-hidden="true" tabindex="-1"></a>num_labels <span class="op">=</span> <span class="dv">2</span>  <span class="co">#  예: "고양이 없음(0)" "고양이 있음(1)", 두 가지 클래스로 분류</span></span>
<span id="cb15-47"><a href="#cb15-47" aria-hidden="true" tabindex="-1"></a>classifier <span class="op">=</span> torch.nn.Linear(joint_representation.size(<span class="dv">1</span>), num_labels) <span class="co"># 간단한 선형 분류기</span></span>
<span id="cb15-48"><a href="#cb15-48" aria-hidden="true" tabindex="-1"></a>outputs <span class="op">=</span> classifier(joint_representation)</span>
<span id="cb15-49"><a href="#cb15-49" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Classification Outputs:"</span>, outputs)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>Fast image processor class &lt;class 'transformers.models.vit.image_processing_vit_fast.ViTImageProcessorFast'&gt; is available for this model. Using slow image processor class. To use the fast image processor class set `use_fast=True`.</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="10_멀티모달 딥러닝: 다중 감각 융합의 시작_files/figure-html/cell-9-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Image Features Shape: torch.Size([1, 768])
Text Features Shape: torch.Size([1, 768])
Joint Representation Shape: torch.Size([1, 1536])
Classification Outputs: tensor([[0.1817, 0.0355]], grad_fn=&lt;AddmmBackward0&gt;)</code></pre>
</div>
</div>
<p>위 예에서 이미지와 텍스트가 각각 ViT와 BERT라는 별도의 모델의 출력을 바로 결합합니다. 이미지 특성과 텍스트 특성을 결합하기 전 이 두 벡터에 대해 추가적인 처리(어텐션, 복잡한 변환 등)를 하지 않습니다. 따라서 이는 초기 융합에 해당합니다.</p>
</section>
<section id="후기-융합late-fusion" class="level4">
<h4 class="anchored" data-anchor-id="후기-융합late-fusion">10.3.4.2 후기 융합(Late Fusion)</h4>
<p>후기 융합은 각 모달리티를 별도의 모델로 처리하고, 마지막 단계에서 각 모델의 출력(예: 예측 결과)을 결합합니다. 이 방식의 장점은 각 모달리티에 특화된 모델을 사용할 수 있다는 점입니다. 예를 들어, 이미지에는 사전 학습된(pre-trained) CNN을, 텍스트에는 사전 학습된 Transformer를 사용하여 각 모달리티의 복잡한 특징을 효과적으로 추출할 수 있습니다. 그러나 모달리티 간의 고수준(high-level) 상호작용만 고려하며, 중간 단계에서의 정보 교환이 어렵다는 단점이 있습니다.</p>
<p>후기 융합은 앙상블(ensemble) 기법과 유사하게, 서로 다른 모달리티별 모델의 출력을 결합하여 성능을 향상시키는 연구가 활발합니다.</p>
</section>
<section id="혼합-융합hybrid-fusion" class="level4">
<h4 class="anchored" data-anchor-id="혼합-융합hybrid-fusion">10.3.4.3 혼합 융합(Hybrid Fusion)</h4>
<p>혼합 융합은 Early Fusion과 Late Fusion을 결합한 방식입니다. 모델의 여러 단계에서 융합을 수행하여, 다양한 수준의 정보를 활용합니다. 이 방식의 장점은 Early Fusion과 Late Fusion의 장점을 모두 취할 수 있다는 점입니다. 즉, 모달리티 간의 저수준 상호작용과 고수준 상호작용을 모두 고려할 수 있습니다. 그러나 모델 구조가 복잡해지고, 튜닝해야 할 하이퍼파라미터가 많아진다는 단점이 있습니다.</p>
<p>혼합 융합의 대표적인 예로 Cross-Modal Attention이 있습니다. 이는 한 모달리티의 특징을 쿼리(query)로 사용하여 다른 모달리티의 특징(key-value)에 어텐션을 적용하는 방식입니다. 이는 중간 단계에서 융합을 수행하는 대표적인 방법입니다.</p>
<p>최근 연구에서는 attention 외에도, gated mechanism, bilinear pooling 등 다양한 방식으로 중간 단계 융합을 시도하고 있습니다.</p>
</section>
<section id="최신-모델의-정교한-통합-전략-2023년-이후" class="level4">
<h4 class="anchored" data-anchor-id="최신-모델의-정교한-통합-전략-2023년-이후">10.3.4.4 최신 모델의 정교한 통합 전략 (2023년 이후)</h4>
<p>2023년 이후, Gemini, GPT-4V와 같은 최신 대규모 멀티모달 모델(LMM)들은 더욱 정교한 모달리티 통합 전략을 도입하여 성능을 크게 향상시켰습니다.</p>
<p><strong>선택적 퓨전 메커니즘 (Selective Fusion Mechanism)</strong> 은 각 모달리티의 중요도를 동적으로 판단하여 선택적으로 정보를 통합합니다. 예를 들어, 이미지에 텍스트가 포함된 경우, 텍스트 영역의 시각적 특징과 텍스트 내용을 더 강하게 연관시킵니다. 이는 사람이 상황에 따라 시각 정보와 텍스트 정보의 중요도를 조절하며 이해하는 것과 유사합니다.</p>
<p><strong>동적 가중치 할당 (Dynamic Weighting)</strong> 은 태스크와 입력의 특성에 따라 각 모달리티의 기여도를 자동으로 조절합니다. 예를 들어, 시각적 질의응답(VQA) 태스크에서 질문의 성격에 따라 이미지와 텍스트 정보의 가중치를 다르게 할당합니다. “이미지의 색상은 무엇인가요?”라는 질문에는 시각 정보에, “이미지가 의미하는 바는 무엇인가요?”라는 질문에는 텍스트 정보에 더 높은 가중치를 부여합니다.</p>
<p><strong>태스크 특화 통합 방식 (Task-Specific Fusion)</strong> 은 특정 태스크의 요구사항에 맞춰 모달리티 통합 방식을 최적화합니다. 이미지 캡셔닝에서는 시각 정보에서 텍스트로의 단방향 변환(one-way transfer)에 중점을 두고, 시각 질의응답에서는 양방향 정보 교환(two-way interaction)을 강화합니다.</p>
<p>이러한 정교한 통합 전략들은 멀티모달 모델의 성능을 크게 향상시켰습니다. 특히, 단순한 정보 결합을 넘어, 각 모달리티의 역할과 중요도를 동적으로 조절하고, 태스크의 특성에 맞춰 융합 방식을 최적화함으로써, 복잡한 추론이 필요한 태스크에서 뛰어난 성과를 보여주고 있습니다.</p>
<p>이러한 통합 전략들은 대규모 데이터셋과 계산 자원을 필요로 하므로, 학습용 예제를 통해 직접 구현하고 실험하기는 어렵습니다. 대신, 각 모델의 논문과 기술 문서를 통해 개념적 이해를 하는 것이 바람직합니다.</p>
</section>
</section>
</section>
<section id="멀티모달-표현-학습-기법" class="level2">
<h2 class="anchored" data-anchor-id="멀티모달-표현-학습-기법">10.4 멀티모달 표현 학습 기법</h2>
<p>10.3절에서는 멀티모달 데이터를 융합하는 다양한 이론적 방법과 전략을 살펴보았습니다. 이를 바탕으로 실제 멀티모달 모델이 어떻게 각 모달리티의 정보를 효과적으로 표현하고, 서로 다른 모달리티 간의 관계를 학습하는지 구체적인 기법들을 살펴보겠습니다. 전체 구현은 <code>chapter_10/multimodal_embeding.py</code> 입니다.</p>
<section id="모달리티-간-표현-학습" class="level3">
<h3 class="anchored" data-anchor-id="모달리티-간-표현-학습">10.4.1 모달리티 간 표현 학습</h3>
<p>멀티모달 학습의 핵심 과제 중 하나는 서로 다른 특성을 가진 모달리티들을 어떻게 의미 있는 <em>공통 공간</em>에 표현할 것인가 하는 문제입니다. 이미지는 픽셀 값의 2D 배열, 텍스트는 토큰의 1D 시퀀스, 오디오는 시간에 따른 진폭 값 등 각 모달리티는 고유한 표현 방식을 가집니다. 이러한 이질적인 데이터를 효과적으로 처리하기 위해서는 각 모달리티의 본질적인 특성은 유지하면서도, 서로 간의 의미적 관계를 포착할 수 있는 표현 학습 기법이 필요합니다.</p>
<p><strong>초기 접근 방식: 개별 인코더 + 투영(Projection)</strong></p>
<p>초기 멀티모달 모델들은 각 모달리티에 특화된 인코더(예: 이미지에는 CNN, 텍스트에는 RNN)를 사용하여 특징 벡터를 추출한 후, 선형 변환(linear transformation) 또는 얕은 MLP(Multi-Layer Perceptron)를 통해 이들을 공통 차원의 벡터 공간으로 투영(project)하는 방식을 사용했습니다. (10.3.1절의 Joint Representation, Concatenation 방식 참고)</p>
<p><strong>최근 접근 방식: 의미적 정렬 (Semantic Alignment)</strong></p>
<p>최근에는 단순한 차원 맞추기를 넘어, 각 모달리티의 특징 벡터들이 의미적으로 서로 “정렬(align)”되도록 학습하는 방식이 주를 이룹니다. 즉, 관련된 이미지와 텍스트는 임베딩 공간에서 가깝게, 관련 없는 이미지와 텍스트는 멀리 위치하도록 학습하는 것이죠.</p>
<ul>
<li><p><strong>Contrastive Learning:</strong> (10.3.2절의 Coordinated Representation, CLIP 예시 참고) 이미지-텍스트 쌍을 “positive” 샘플로, 무작위로 섞은 이미지-텍스트 쌍을 “negative” 샘플로 간주하고, positive 샘플 간의 유사도는 높이고, negative 샘플 간의 유사도는 낮추는 방식으로 학습합니다.</p></li>
<li><p><strong>Triplet Loss:</strong> 이미지 앵커(anchor), positive 텍스트(해당 이미지의 캡션), negative 텍스트(다른 이미지의 캡션)의 세 요소를 사용하여, 앵커 이미지와 positive 텍스트 간 거리는 가깝게, 앵커 이미지와 negative 텍스트 간 거리는 멀게 학습합니다.</p></li>
</ul>
<p><strong>구현 예(Contrastive Learning)</strong></p>
<div id="cell-22" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> MultimodalEmbedding(nn.Module):</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, embedding_dim<span class="op">=</span><span class="dv">512</span>):</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.image_encoder <span class="op">=</span> models.resnet18(pretrained<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.image_encoder.fc <span class="op">=</span> nn.Sequential(</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>            nn.Linear(<span class="dv">512</span>, embedding_dim),</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>            nn.LayerNorm(embedding_dim)</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.text_encoder <span class="op">=</span> BertModel.from_pretrained(<span class="st">'bert-base-uncased'</span>)</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.text_projection <span class="op">=</span> nn.Sequential(</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>            nn.Linear(<span class="dv">768</span>, embedding_dim),  <span class="co"># BERT output dimension is 768</span></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>            nn.LayerNorm(embedding_dim)</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.logit_scale <span class="op">=</span> nn.Parameter(torch.ones([]) <span class="op">*</span> np.log(<span class="dv">1</span> <span class="op">/</span> <span class="fl">0.07</span>))</span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> encode_image(<span class="va">self</span>, image):</span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.image_encoder(image)</span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> encode_text(<span class="va">self</span>, input_ids, attention_mask):</span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a>        text_features <span class="op">=</span> <span class="va">self</span>.text_encoder(input_ids, attention_mask)[<span class="dv">0</span>][:, <span class="dv">0</span>, :]  <span class="co"># [CLS] token, keep batch dim</span></span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.text_projection(text_features)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<ul>
<li><strong><code>MultimodalEmbedding</code> 클래스:</strong>
<ul>
<li><code>image_encoder</code>: ResNet18을 사용하여 이미지를 <code>embedding_dim</code> 크기의 특징 벡터로 변환합니다.</li>
<li><code>text_encoder</code>: BERT 모델을 사용하여 텍스트를 특징 벡터로 변환하고, <code>text_projection</code> 레이어를 통해 <code>embedding_dim</code> 크기로 맞춰줍니다.</li>
<li><code>logit_scale</code>: CLIP에서 사용된 학습 가능한 temperature 파라미터입니다.</li>
</ul></li>
</ul>
<p><strong>의미적 정렬 메커니즘</strong></p>
<p>의미적 정렬은 크게 다음 두 가지 부분에서 구현됩니다. MultimodalEmbedding 클래스의 forward 메서드와 constrasive_loss()입니다.</p>
<div id="cell-24" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> forward(<span class="va">self</span>, image, input_ids, attention_mask):</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    image_features <span class="op">=</span> <span class="va">self</span>.encode_image(image)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    text_features <span class="op">=</span> <span class="va">self</span>.encode_text(input_ids, attention_mask)</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    image_features <span class="op">=</span> image_features <span class="op">/</span> image_features.norm(dim<span class="op">=-</span><span class="dv">1</span>, keepdim<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>    text_features <span class="op">=</span> text_features <span class="op">/</span> text_features.norm(dim<span class="op">=-</span><span class="dv">1</span>, keepdim<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>    logit_scale <span class="op">=</span> <span class="va">self</span>.logit_scale.exp()</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>    logits <span class="op">=</span> logit_scale <span class="op">*</span> image_features <span class="op">@</span> text_features.transpose(<span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">2</span>)</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># print("logits:", logits.shape)</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> logits   <span class="co"># Return a single value</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<ul>
<li><strong><code>forward</code> 메서드:</strong>
<ol type="1">
<li><p><code>encode_image</code>와 <code>encode_text</code>를 사용하여 이미지와 텍스트를 각각 인코딩합니다.</p></li>
<li><p><strong>특징 정규화 (Feature Normalization):</strong> L2 정규화(L2 normalization)를 통해 <code>image_features</code>와 <code>text_features</code> 벡터의 크기를 1로 만듭니다. 이는 벡터의 방향(direction)만을 고려하여 유사도를 계산하기 위함입니다.</p></li>
<li><p><strong>온도 스케일링 (Temperature Scaling):</strong> <code>logit_scale</code>을 사용하여 유사도 점수의 분포를 조절합니다. logit_scale을 지수 함수에 적용하여 스케일 값을 얻고, 이를 이미지 특징 행렬과 전치된 텍스트 특징 행렬의 행렬 곱셈에 곱합니다. 행렬 곱셈은 각 이미지 특징 벡터와 모든 텍스트 특징 벡터 간의 내적(dot product)을 계산하여 유사도 점수를 생성합니다.</p></li>
<li><p><code>logits</code>: 이미지 특징 벡터와 텍스트 특징 벡터 간의 유사도 (내적)를 계산합니다. <code>text_features.t()</code> 대신 <code>text_features.transpose(-1, -2)</code>를 사용하여 전치(transpose)를 수행합니다. 텍스트 특징 행렬의 마지막 두 차원을 바꿔 (배치, 텍스트 특징 차원)을 (배치, 특징 차원, 텍스트) 형태로 만들어, (배치, 이미지 특징 차원) 형태의 이미지 특징 행렬과 곱셈이 가능하도록 합니다.</p></li>
</ol></li>
</ul>
<div id="cell-26" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> contrastive_loss(logits): <span class="co"># removed enhanced_similarity</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    labels <span class="op">=</span> torch.arange(logits.size(<span class="dv">0</span>), device<span class="op">=</span>logits.device) <span class="co"># Use logits.size(0)</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Image-to-text and text-to-image contrastive loss</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    img_txt_loss <span class="op">=</span> nn.CrossEntropyLoss()(logits, labels)</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>    txt_img_loss <span class="op">=</span> nn.CrossEntropyLoss()(logits.T, labels)</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Average loss</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (img_txt_loss <span class="op">+</span> txt_img_loss) <span class="op">/</span> <span class="dv">2</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p><code>contrastive_loss</code> 함수에서는 <code>labels</code>를 <code>logits</code> 행렬의 크기에 맞춰 0부터 (배치 크기 - 1)까지의 정수로 생성합니다. <code>logits</code> 행렬에서 대각선 요소 (i, i)는 i번째 이미지와 i번째 텍스트 간의 유사도를 나타냅니다. 즉, 이미지와 텍스트가 서로 대응되는 쌍(positive pair)의 유사도를 나타내므로, 이 대각선 요소들이 정답이 되도록 labels를 설정합니다. 또한, img_txt_loss는 이미지에서 텍스트로의 유사도에 대한 손실(image-to-text loss)을, txt_img_loss는 텍스트에서 이미지로의 유사도에 대한 손실(text-to-image loss)을 계산합니다. 이 두 손실을 평균냄으로써 양방향(image-to-text, text-to-image)에서의 의미적 정렬을 모두 고려하게 됩니다.</p>
<p>의미적 정렬 메커니즘은 서로 다른 모달리티의 특징들을 의미적으로 일관된 공간에 매핑합니다. 먼저 L2 정규화를 통해 모든 특징 벡터를 단위 구면에 투영하여 모달리티 간의 스케일 차이를 제거합니다. 온도 스케일링 파라미터를 도입하여 유사도 값의 분포를 조절합니다. 높은 온도는 더 부드러운 분포를, 낮은 온도는 더 날카로운 분포를 생성해서 학습의 안정성을 높입니다. 또한 대조 학습을 통해 관련된 이미지-텍스트 쌍은 임베딩 공간에서 가깝게, 무관한 쌍은 멀게 위치하도록 학습됩니다. 특히 이미지에서 텍스트, 텍스트에서 이미지로의 매핑을 동시에 최적화하여 양방향 의미적 정렬을 달성합니다.</p>
<p>CLIP의 대조 학습처럼 관련된 콘텐츠는 가깝게, 무관한 콘텐츠는 멀게 위치하도록 학습합니다. 이러한 대조 학습 기반의 의미적 정렬 전략은 2021년 OpenAI의 CLIP을 시작으로, Google의 PaLM-E, Anthropic의 Claude, 그리고 DeepMind의 Gemini에 이르기까지 발전했습니다. 초기 CLIP이 이미지-텍스트 쌍의 단순 대조 학습에 집중했다면, 최신 모델들은 다중 모달리티 간의 상호 관계를 더욱 정교하게 포착합니다. 특히 Gemini는 이미지, 텍스트, 오디오, 비디오 등 다양한 모달리티 간의 의미적 정렬을 동시에 학습하며, 각 모달리티의 고유한 특성을 보존하면서 통합된 의미 공간을 구축합니다.</p>
<p><strong>예제 실행</strong></p>
<p>훈련에 사용하는 데이터는 flicker8k를 사용합니다. <code>train_multimodal_embedding</code> 함수를 사용하여 <code>EnhancedMultimodalEmbedding</code> (또는 <code>EnhancedMultimodalEmbedding_no_p</code>) 모델을 Flickr8k 데이터셋으로 훈련할 수 있습니다. <code>main</code> 함수에서 모델, 데이터 로더, optimizer 등을 설정하고, <code>train_multimodal_embedding</code> 함수를 호출하면 훈련이 시작됩니다.</p>
<div id="cell-28" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co"># download flickr8k.</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="op">!</span>mkdir data<span class="op">;</span>cd data<span class="op">;</span>wget <span class="st">"https://github.com/awsaf49/flickr-dataset/releases/download/v1.0/flickr8k.zip"</span><span class="op">;</span>unzip <span class="op">-</span>q flickr8k.<span class="bu">zip</span> <span class="op">-</span>d .<span class="op">/</span>flickr8k</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>mkdir: cannot create directory ‘data’: File exists
--2025-03-09 16:33:12--  https://github.com/awsaf49/flickr-dataset/releases/download/v1.0/flickr8k.zip
Resolving github.com (github.com)... 20.200.245.247
Connecting to github.com (github.com)|20.200.245.247|:443... connected.
HTTP request sent, awaiting response... 302 Found
Location: https://objects.githubusercontent.com/github-production-release-asset-2e65be/753516996/d7c62b13-1e50-40ea-8fae-f34a44b1695f?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=releaseassetproduction%2F20250309%2Fus-east-1%2Fs3%2Faws4_request&amp;X-Amz-Date=20250309T073156Z&amp;X-Amz-Expires=300&amp;X-Amz-Signature=ff62cf7df8ac3deba8bd6f4f775e164abf03c6d2d6d86d740e5407e52702c6a3&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=attachment%3B%20filename%3Dflickr8k.zip&amp;response-content-type=application%2Foctet-stream [following]
--2025-03-09 16:33:12--  https://objects.githubusercontent.com/github-production-release-asset-2e65be/753516996/d7c62b13-1e50-40ea-8fae-f34a44b1695f?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=releaseassetproduction%2F20250309%2Fus-east-1%2Fs3%2Faws4_request&amp;X-Amz-Date=20250309T073156Z&amp;X-Amz-Expires=300&amp;X-Amz-Signature=ff62cf7df8ac3deba8bd6f4f775e164abf03c6d2d6d86d740e5407e52702c6a3&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=attachment%3B%20filename%3Dflickr8k.zip&amp;response-content-type=application%2Foctet-stream
Resolving objects.githubusercontent.com (objects.githubusercontent.com)... 185.199.109.133, 185.199.111.133, 185.199.110.133, ...
Connecting to objects.githubusercontent.com (objects.githubusercontent.com)|185.199.109.133|:443... connected.
HTTP request sent, awaiting response... 200 OK
Length: 1112971163 (1.0G) [application/octet-stream]
Saving to: ‘flickr8k.zip’

flickr8k.zip        100%[===================&gt;]   1.04G  56.8MB/s    in 19s     

2025-03-09 16:33:32 (56.9 MB/s) - ‘flickr8k.zip’ saved [1112971163/1112971163]
</code></pre>
</div>
</div>
<div id="cell-29" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> torchvision <span class="im">import</span> models, transforms</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> torch.utils.data <span class="im">import</span> Dataset, DataLoader</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Assuming dldna.chapter_10.multimodal_embedding is in the same directory or Python path.</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Adjust if necessary (e.g., from multimodal_embedding import ...).</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_10.multimodal_embedding <span class="im">import</span> Flickr8kDataset, MultimodalEmbedding, train_multimodal_embedding, generate_example</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Data transformation setup</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>transform <span class="op">=</span> transforms.Compose([</span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>    transforms.Resize((<span class="dv">224</span>, <span class="dv">224</span>)),</span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>    transforms.ToTensor(),</span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>    transforms.Normalize(mean<span class="op">=</span>[<span class="fl">0.485</span>, <span class="fl">0.456</span>, <span class="fl">0.406</span>], std<span class="op">=</span>[<span class="fl">0.229</span>, <span class="fl">0.224</span>, <span class="fl">0.225</span>])</span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a>])</span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Dataset and DataLoader setup</span></span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a>image_dir <span class="op">=</span> <span class="st">'./data/flickr8k/Images'</span>  <span class="co"># Replace with the actual path to your image directory</span></span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a>caption_file <span class="op">=</span> <span class="st">'./data/flickr8k/captions.txt'</span>  <span class="co"># Replace with the actual path to your caption file</span></span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true" tabindex="-1"></a>dataset <span class="op">=</span> Flickr8kDataset(image_dir, caption_file, transform<span class="op">=</span>transform)</span>
<span id="cb23-19"><a href="#cb23-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-20"><a href="#cb23-20" aria-hidden="true" tabindex="-1"></a>train_size <span class="op">=</span> <span class="bu">int</span>(<span class="fl">0.8</span> <span class="op">*</span> <span class="bu">len</span>(dataset))</span>
<span id="cb23-21"><a href="#cb23-21" aria-hidden="true" tabindex="-1"></a>val_size <span class="op">=</span> <span class="bu">len</span>(dataset) <span class="op">-</span> train_size</span>
<span id="cb23-22"><a href="#cb23-22" aria-hidden="true" tabindex="-1"></a>train_dataset, val_dataset <span class="op">=</span> torch.utils.data.random_split(dataset, [train_size, val_size])</span>
<span id="cb23-23"><a href="#cb23-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-24"><a href="#cb23-24" aria-hidden="true" tabindex="-1"></a>train_loader <span class="op">=</span> DataLoader(train_dataset, batch_size<span class="op">=</span><span class="dv">32</span>, shuffle<span class="op">=</span><span class="va">True</span>, num_workers<span class="op">=</span><span class="dv">4</span>)</span>
<span id="cb23-25"><a href="#cb23-25" aria-hidden="true" tabindex="-1"></a>val_loader <span class="op">=</span> DataLoader(val_dataset, batch_size<span class="op">=</span><span class="dv">32</span>, shuffle<span class="op">=</span><span class="va">False</span>, num_workers<span class="op">=</span><span class="dv">4</span>)</span>
<span id="cb23-26"><a href="#cb23-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-27"><a href="#cb23-27" aria-hidden="true" tabindex="-1"></a><span class="co"># Model initialization</span></span>
<span id="cb23-28"><a href="#cb23-28" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> MultimodalEmbedding()</span>
<span id="cb23-29"><a href="#cb23-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-30"><a href="#cb23-30" aria-hidden="true" tabindex="-1"></a><span class="co"># Model training</span></span>
<span id="cb23-31"><a href="#cb23-31" aria-hidden="true" tabindex="-1"></a>train_multimodal_embedding(model, train_loader, val_loader, num_epochs<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb23-32"><a href="#cb23-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-33"><a href="#cb23-33" aria-hidden="true" tabindex="-1"></a><span class="co"># Model saving</span></span>
<span id="cb23-34"><a href="#cb23-34" aria-hidden="true" tabindex="-1"></a>torch.save(model.state_dict(), <span class="st">'multimodal_embedding_model.pth'</span>)</span>
<span id="cb23-35"><a href="#cb23-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-36"><a href="#cb23-36" aria-hidden="true" tabindex="-1"></a><span class="co"># Example generation</span></span>
<span id="cb23-37"><a href="#cb23-37" aria-hidden="true" tabindex="-1"></a>model_path <span class="op">=</span> <span class="st">'multimodal_embedding_model.pth'</span></span>
<span id="cb23-38"><a href="#cb23-38" aria-hidden="true" tabindex="-1"></a>generate_example(model_path, image_dir, caption_file)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>Epoch 1/3:  15%|█▍        | 147/1012 [00:16&lt;01:36,  8.96it/s]</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Image file not found: ./data/flickr8k/Images/image</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Epoch 1/3: 100%|██████████| 1012/1012 [01:53&lt;00:00,  8.90it/s]</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Epoch 1/3 - Train Loss: 0.9618</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code></code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Epoch 1/3 - Validation Loss: 0.5212
Epoch 1: Saved best model with Validation Loss = 0.5212</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Epoch 2/3:  52%|█████▏    | 525/1012 [00:59&lt;00:55,  8.84it/s]</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Image file not found: ./data/flickr8k/Images/image</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Epoch 2/3: 100%|██████████| 1012/1012 [01:54&lt;00:00,  8.83it/s]</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Epoch 2/3 - Train Loss: 0.3393</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code></code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Epoch 2/3 - Validation Loss: 0.4240
Epoch 2: Saved best model with Validation Loss = 0.4240</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Epoch 3/3:  34%|███▍      | 347/1012 [00:39&lt;01:15,  8.85it/s]</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Image file not found: ./data/flickr8k/Images/image</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Epoch 3/3: 100%|██████████| 1012/1012 [01:54&lt;00:00,  8.83it/s]</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Epoch 3/3 - Train Loss: 0.2313</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code></code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Epoch 3/3 - Validation Loss: 0.3891
Epoch 3: Saved best model with Validation Loss = 0.3891
Image 0:</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="10_멀티모달 딥러닝: 다중 감각 융합의 시작_files/figure-html/cell-14-output-19.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
Top 3 Captions (Image -&gt; Text):
  - football players in red congratulate each other as crowds in red cheer behind. (prob: 0.9970)
  - a man in black holds up an obama 08 sign. (prob: 0.0023)
  - a large group of bicycles racing on the street (prob: 0.0004)

Caption: football players in red congratulate each other as crowds in red cheer behind.

Top 3 Images (Text -&gt; Image):
 - Image 0 (prob: 0.9983)</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="10_멀티모달 딥러닝: 다중 감각 융합의 시작_files/figure-html/cell-14-output-21.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code> - Image 17 (prob: 0.0013)</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="10_멀티모달 딥러닝: 다중 감각 융합의 시작_files/figure-html/cell-14-output-23.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code> - Image 2 (prob: 0.0001)</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="10_멀티모달 딥러닝: 다중 감각 융합의 시작_files/figure-html/cell-14-output-25.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="크로스모달-어텐션-구조" class="level3">
<h3 class="anchored" data-anchor-id="크로스모달-어텐션-구조">10.4.2 크로스모달 어텐션 구조</h3>
<p>크로스모달 어텐션은 서로 다른 모달리티 간의 관계를 효과적으로 모델링하기 위한 사용됩니다. 이는 ViT의 셀프 어텐션을 확장하여 이미지와 텍스트 같은 이질적인 데이터 간의 상호작용이 가능하게 합니다.</p>
<p><strong>모달리티 간 어텐션 설계</strong></p>
<p>크로스모달 어텐션은 각 모달리티의 특성을 고려한 비대칭 구조를 가집니다.</p>
<div id="cell-31" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> CrossModalAttention(nn.Module):</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, config):</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.image_proj <span class="op">=</span> nn.Linear(config.image_dim, config.hidden_dim)</span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.text_proj <span class="op">=</span> nn.Linear(config.text_dim, config.hidden_dim)</span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.attention <span class="op">=</span> nn.MultiheadAttention(config.hidden_dim, config.num_heads)</span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, image_features, text_features):</span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a>        image_proj <span class="op">=</span> <span class="va">self</span>.image_proj(image_features)</span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a>        text_proj <span class="op">=</span> <span class="va">self</span>.text_proj(text_features)</span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true" tabindex="-1"></a>        attn_output, _ <span class="op">=</span> <span class="va">self</span>.attention(text_proj, image_proj, image_proj)</span>
<span id="cb45-12"><a href="#cb45-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> attn_output</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>이미지와 텍스트 특징을 공통의 잠재 공간으로 투영한 후, 멀티헤드 어텐션 메커니즘을 통해 두 모달리티 간의 관계를 학습합니다. 텍스트 특징이 쿼리로, 이미지 특징이 키와 값으로 사용되어 텍스트가 이미지의 관련 부분에 주의를 기울이도록 합니다.</p>
<p><strong>비대칭 어텐션 패턴</strong></p>
<p>각 모달리티의 고유한 특성을 보존하면서도 효과적인 정보 교환을 위해 비대칭 어텐션 패턴을 사용합니다.</p>
<div id="cell-33" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> HierarchicalCrossModalAttention(nn.Module):</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, config):</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.local_image_attention <span class="op">=</span> nn.MultiheadAttention(config.hidden_dim, config.num_heads)</span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.local_text_attention <span class="op">=</span> nn.MultiheadAttention(config.hidden_dim, config.num_heads)</span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.image_to_text_attention <span class="op">=</span> CrossModalAttention(config)</span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.text_to_image_attention <span class="op">=</span> CrossModalAttention(config)</span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.output_layer <span class="op">=</span> nn.Linear(config.hidden_dim <span class="op">*</span> <span class="dv">2</span>, config.hidden_dim)</span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, image_features, text_features):</span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a>        local_image <span class="op">=</span> <span class="va">self</span>.local_image_attention(image_features, image_features, image_features)[<span class="dv">0</span>]</span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true" tabindex="-1"></a>        local_text <span class="op">=</span> <span class="va">self</span>.local_text_attention(text_features, text_features, text_features)[<span class="dv">0</span>]</span>
<span id="cb46-13"><a href="#cb46-13" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb46-14"><a href="#cb46-14" aria-hidden="true" tabindex="-1"></a>        image_attended_text <span class="op">=</span> <span class="va">self</span>.image_to_text_attention(image_features, local_text)</span>
<span id="cb46-15"><a href="#cb46-15" aria-hidden="true" tabindex="-1"></a>        text_attended_image <span class="op">=</span> <span class="va">self</span>.text_to_image_attention(text_features, local_image)</span>
<span id="cb46-16"><a href="#cb46-16" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb46-17"><a href="#cb46-17" aria-hidden="true" tabindex="-1"></a>        combined_features <span class="op">=</span> torch.cat([image_attended_text, text_attended_image], dim<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb46-18"><a href="#cb46-18" aria-hidden="true" tabindex="-1"></a>        output <span class="op">=</span> <span class="va">self</span>.output_layer(combined_features)</span>
<span id="cb46-19"><a href="#cb46-19" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb46-20"><a href="#cb46-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> output</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>여기서는 이미지에서 텍스트, 텍스트에서 이미지로의 양방향 어텐션을 별도로 수행합니다. 이를 통해 각 모달리티가 상대 모달리티의 관련 정보에 선택적으로 집중할 수 있게 됩니다.</p>
<p><strong>계층적 어텐션 구조</strong></p>
<p>복잡한 멀티모달 관계를 포착하기 위해 여러 층의 어텐션을 계층적으로 구성합니다. 하위 층에서는 각 모달리티 내의 지역적 특징을 처리하고, 상위 층에서는 모달리티 간의 전역적 관계를 모델링합니다. 이러한 계층적 구조는 GPT-4V와 Gemini와 같은 모델에서 핵심적인 역할을 합니다.</p>
<div id="cell-35" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> EnhancedMultimodalEmbedding_no_p(MultimodalEmbedding):</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, image, input_ids, attention_mask):</span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>        image_features <span class="op">=</span> <span class="va">self</span>.encode_image(image)</span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>        text_features <span class="op">=</span> <span class="va">self</span>.encode_text(input_ids, attention_mask)</span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a>        image_features <span class="op">=</span> <span class="va">self</span>.image_preserve(image_features)</span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a>        text_features <span class="op">=</span> <span class="va">self</span>.text_preserve(text_features)</span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true" tabindex="-1"></a>        combined_features <span class="op">=</span> <span class="va">self</span>.cross_modal_attention(image_features, text_features)</span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb47-12"><a href="#cb47-12" aria-hidden="true" tabindex="-1"></a>        combined_features <span class="op">=</span> combined_features <span class="op">/</span> combined_features.norm(dim<span class="op">=-</span><span class="dv">1</span>, keepdim<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb47-13"><a href="#cb47-13" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb47-14"><a href="#cb47-14" aria-hidden="true" tabindex="-1"></a>        logit_scale <span class="op">=</span> <span class="va">self</span>.logit_scale.exp()</span>
<span id="cb47-15"><a href="#cb47-15" aria-hidden="true" tabindex="-1"></a>        logits <span class="op">=</span> logit_scale <span class="op">*</span> combined_features <span class="op">@</span> combined_features.t()</span>
<span id="cb47-16"><a href="#cb47-16" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb47-17"><a href="#cb47-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> logits</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="cell-36" class="cell" data-execution_count="2">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> torchvision <span class="im">import</span> models, transforms</span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> torch.utils.data <span class="im">import</span> Dataset, DataLoader</span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> namedtuple</span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_10.crossmodal_attention <span class="im">import</span> Flickr8kDataset, CrossModalEmbedding, train_crossmodal_embedding, generate_example</span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Configuration</span></span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a>config <span class="op">=</span> namedtuple(<span class="st">'Config'</span>, [<span class="st">'embedding_dim'</span>, <span class="st">'image_dim'</span>, <span class="st">'text_dim'</span>, <span class="st">'hidden_dim'</span>, <span class="st">'num_heads'</span>])(</span>
<span id="cb48-11"><a href="#cb48-11" aria-hidden="true" tabindex="-1"></a>                    embedding_dim<span class="op">=</span><span class="dv">512</span>, <span class="co"># Output embedding dimension</span></span>
<span id="cb48-12"><a href="#cb48-12" aria-hidden="true" tabindex="-1"></a>                    image_dim<span class="op">=</span><span class="dv">512</span>, <span class="co"># ResNet18 image encoder output dimension</span></span>
<span id="cb48-13"><a href="#cb48-13" aria-hidden="true" tabindex="-1"></a>                    text_dim<span class="op">=</span><span class="dv">512</span>, <span class="co"># Text feature (768 from BERT -&gt; 512 after projection)</span></span>
<span id="cb48-14"><a href="#cb48-14" aria-hidden="true" tabindex="-1"></a>                    hidden_dim<span class="op">=</span><span class="dv">512</span>, <span class="co"># Cross-modal attention internal hidden dimension</span></span>
<span id="cb48-15"><a href="#cb48-15" aria-hidden="true" tabindex="-1"></a>                    num_heads<span class="op">=</span><span class="dv">8</span> <span class="co"># Number of multi-head attention heads</span></span>
<span id="cb48-16"><a href="#cb48-16" aria-hidden="true" tabindex="-1"></a>                    )</span>
<span id="cb48-17"><a href="#cb48-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Data transformation setup</span></span>
<span id="cb48-18"><a href="#cb48-18" aria-hidden="true" tabindex="-1"></a>transform <span class="op">=</span> transforms.Compose([</span>
<span id="cb48-19"><a href="#cb48-19" aria-hidden="true" tabindex="-1"></a>    transforms.Resize((<span class="dv">224</span>, <span class="dv">224</span>)),</span>
<span id="cb48-20"><a href="#cb48-20" aria-hidden="true" tabindex="-1"></a>    transforms.ToTensor(),</span>
<span id="cb48-21"><a href="#cb48-21" aria-hidden="true" tabindex="-1"></a>    transforms.Normalize(mean<span class="op">=</span>[<span class="fl">0.485</span>, <span class="fl">0.456</span>, <span class="fl">0.406</span>], std<span class="op">=</span>[<span class="fl">0.229</span>, <span class="fl">0.224</span>, <span class="fl">0.225</span>])</span>
<span id="cb48-22"><a href="#cb48-22" aria-hidden="true" tabindex="-1"></a>])</span>
<span id="cb48-23"><a href="#cb48-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-24"><a href="#cb48-24" aria-hidden="true" tabindex="-1"></a><span class="co"># Dataset and DataLoader setup</span></span>
<span id="cb48-25"><a href="#cb48-25" aria-hidden="true" tabindex="-1"></a>image_dir <span class="op">=</span> <span class="st">'./data/flickr8k/Images'</span>  <span class="co"># Change to the actual path</span></span>
<span id="cb48-26"><a href="#cb48-26" aria-hidden="true" tabindex="-1"></a>caption_file <span class="op">=</span> <span class="st">'./data/flickr8k/captions.txt'</span>  <span class="co"># Change to the actual path</span></span>
<span id="cb48-27"><a href="#cb48-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-28"><a href="#cb48-28" aria-hidden="true" tabindex="-1"></a>dataset <span class="op">=</span> Flickr8kDataset(image_dir, caption_file, transform<span class="op">=</span>transform)</span>
<span id="cb48-29"><a href="#cb48-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-30"><a href="#cb48-30" aria-hidden="true" tabindex="-1"></a>train_size <span class="op">=</span> <span class="bu">int</span>(<span class="fl">0.8</span> <span class="op">*</span> <span class="bu">len</span>(dataset))</span>
<span id="cb48-31"><a href="#cb48-31" aria-hidden="true" tabindex="-1"></a>val_size <span class="op">=</span> <span class="bu">len</span>(dataset) <span class="op">-</span> train_size</span>
<span id="cb48-32"><a href="#cb48-32" aria-hidden="true" tabindex="-1"></a>train_dataset, val_dataset <span class="op">=</span> torch.utils.data.random_split(dataset, [train_size, val_size])</span>
<span id="cb48-33"><a href="#cb48-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-34"><a href="#cb48-34" aria-hidden="true" tabindex="-1"></a>train_loader <span class="op">=</span> DataLoader(train_dataset, batch_size<span class="op">=</span><span class="dv">32</span>, shuffle<span class="op">=</span><span class="va">True</span>, num_workers<span class="op">=</span><span class="dv">4</span>, pin_memory<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb48-35"><a href="#cb48-35" aria-hidden="true" tabindex="-1"></a>val_loader <span class="op">=</span> DataLoader(val_dataset, batch_size<span class="op">=</span><span class="dv">32</span>, shuffle<span class="op">=</span><span class="va">False</span>, num_workers<span class="op">=</span><span class="dv">4</span>, pin_memory<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb48-36"><a href="#cb48-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-37"><a href="#cb48-37" aria-hidden="true" tabindex="-1"></a><span class="co"># Model initialization</span></span>
<span id="cb48-38"><a href="#cb48-38" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> CrossModalEmbedding(config)</span>
<span id="cb48-39"><a href="#cb48-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-40"><a href="#cb48-40" aria-hidden="true" tabindex="-1"></a><span class="co"># Model training</span></span>
<span id="cb48-41"><a href="#cb48-41" aria-hidden="true" tabindex="-1"></a>train_crossmodal_embedding(model, train_loader, val_loader, num_epochs<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb48-42"><a href="#cb48-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-43"><a href="#cb48-43" aria-hidden="true" tabindex="-1"></a><span class="co"># Model saving</span></span>
<span id="cb48-44"><a href="#cb48-44" aria-hidden="true" tabindex="-1"></a>torch.save(model.state_dict(), <span class="st">'crossmodal_embedding_model.pth'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>Epoch 1/3:   4%|▍         | 40/1012 [00:04&lt;01:41,  9.53it/s]</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Image file not found: ./data/flickr8k/Images/image</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Epoch 1/3: 100%|██████████| 1012/1012 [01:47&lt;00:00,  9.41it/s]</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Epoch 1/3 - Train Loss: 0.9663</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code></code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Epoch 1/3 - Validation Loss: 0.5378</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Epoch 2/3:  58%|█████▊    | 582/1012 [01:02&lt;00:45,  9.36it/s]</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Image file not found: ./data/flickr8k/Images/image</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Epoch 2/3: 100%|██████████| 1012/1012 [01:48&lt;00:00,  9.31it/s]</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Epoch 2/3 - Train Loss: 0.3381</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code></code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Epoch 2/3 - Validation Loss: 0.4452</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Epoch 3/3:   0%|          | 4/1012 [00:00&lt;02:27,  6.82it/s]</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Image file not found: ./data/flickr8k/Images/image</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Epoch 3/3: 100%|██████████| 1012/1012 [01:48&lt;00:00,  9.35it/s]</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Epoch 3/3 - Train Loss: 0.2288</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code></code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Epoch 3/3 - Validation Loss: 0.3743</code></pre>
</div>
</div>
<div id="cell-37" class="cell" data-execution_count="3">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb67"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Example generation</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>model_path <span class="op">=</span> <span class="st">'crossmodal_embedding_model.pth'</span></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>generate_example(model_path, image_dir, caption_file)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Image 0:</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="10_멀티모달 딥러닝: 다중 감각 융합의 시작_files/figure-html/cell-19-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
Top 3 Captions (Image -&gt; Text):
  - two people walk out onto the desert sand. (prob: 0.9862)
  - a man takes a picture of him and his friend with his phone. (prob: 0.0092)
  - the little boy wearing the blue shirt is putting dirt in his mouth. (prob: 0.0013)

Caption: two people walk out onto the desert sand.

Top 3 Images (Text -&gt; Image):
 - Image 0 (prob: 0.9898)</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="10_멀티모달 딥러닝: 다중 감각 융합의 시작_files/figure-html/cell-19-output-4.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code> - Image 2 (prob: 0.0089)</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="10_멀티모달 딥러닝: 다중 감각 융합의 시작_files/figure-html/cell-19-output-6.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code> - Image 4 (prob: 0.0005)</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="10_멀티모달 딥러닝: 다중 감각 융합의 시작_files/figure-html/cell-19-output-8.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="perceiver-아키텍처" class="level3">
<h3 class="anchored" data-anchor-id="perceiver-아키텍처">10.4.3 Perceiver 아키텍처</h3>
<p>Perceiver는 2021년 DeepMind가 제안한 멀티모달 아키텍처입니다. 기존 트랜스포머의 이차 복잡도 문제(입력 시퀀스 길이에 따라 계산량이 제곱으로 증가)를 해결하면서도 다양한 모달리티(이미지, 텍스트, 오디오, 포인트 클라우드 등)를 효과적으로 처리할 수 있는 구조를 제시했습니다. Perceiver는 특히 입력 데이터의 크기가 매우 큰 경우(예: 고해상도 이미지, 긴 텍스트)에 유리합니다. 여기서는 전체적인 아키텍처 설명을 하고 예제는 생략하였습니다. 코드는 설명을 위한 예시 코드입니다.</p>
<p><strong>Perceiver의 핵심 아이디어</strong></p>
<p>Perceiver는 다음과 같은 아이디어를 기반으로 합니다.</p>
<ol type="1">
<li><strong>병목 구조 (Bottleneck Architecture):</strong></li>
</ol>
<p>Perceiver는 입력 시퀀스의 길이에 관계없이 고정된 크기의 잠재 벡터(latent array) 를 사용합니다. 이 잠재 벡터는 입력 데이터의 정보를 압축하여 표현하는 역할을 하며, 마치 병목처럼 많은 양의 입력 정보를 적은 수의 잠재 벡터로 요약합니다. 따라서 입력 데이터의 크기가 아무리 크더라도(예: 10,000개의 토큰) 잠재 벡터의 수는 고정(예: 256개)되기 때문에 계산 복잡도와 메모리 사용량을 크게 줄일 수 있습니다.</p>
<div id="cell-39" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb72"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Perceiver(nn.Module):</span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, ..., num_latents<span class="op">=</span><span class="dv">256</span>, latent_dim<span class="op">=</span><span class="dv">512</span>, ...):</span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Latent vector initialization (key!)</span></span>
<span id="cb72-5"><a href="#cb72-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.latents <span class="op">=</span> nn.Parameter(torch.randn(num_latents, latent_dim))</span>
<span id="cb72-6"><a href="#cb72-6" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ...</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>위 코드에서 <code>self.latents</code>가 바로 그 잠재 벡터를 나타냅니다. <code>nn.Parameter</code>로 정의되어 학습 가능한 파라미터입니다.</p>
<ol start="2" type="1">
<li><strong>모달리티 독립적 처리 (Modality-Agnostic Processing):</strong></li>
</ol>
<p>Perceiver는 입력 모달리티(이미지, 텍스트, 오디오 등)에 특화된 처리 방식(예: CNN, RNN)을 사용하지 않습니다. 대신, 각 모달리티는 간단한 전처리(예: 이미지 패치, 텍스트 토큰화)를 거쳐 공통된 형태(sequence of vectors)로 변환됩니다. 이후에는 모달리티 종류와 무관하게 동일한 트랜스포머 기반 아키텍처(Cross-Attention, Self-Attention)를 사용하여 처리합니다. 이를 통해 다양한 모달리티를 유연하게 처리할 수 있고, 새로운 모달리티를 추가하기도 쉽습니다.</p>
<ol start="3" type="1">
<li><strong>적응형 잠재 표현 (Adaptive Latent Representation):</strong></li>
</ol>
<p>Perceiver는 여러 층의 셀프 어텐션(self-attention) 을 사용하여 잠재 벡터들을 점진적으로 업데이트합니다. 각 층에서 잠재 벡터들은 서로 정보를 교환하며, 입력 데이터의 복잡한 패턴을 학습합니다. 초기에는 단순한 특징을 나타내던 잠재 벡터들이, 여러 층을 거치면서 점차 추상적이고 고수준의 의미를 표현하게 됩니다.</p>
<p><strong>Perceiver의 작동 방식 (간략화된 코드 예시)</strong></p>
<div id="cell-41" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb73"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.nn <span class="im">as</span> nn</span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Perceiver(nn.Module):</span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>,</span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true" tabindex="-1"></a>                 input_channels<span class="op">=</span><span class="dv">3</span>,  <span class="co"># Input channels (e.g., RGB image)</span></span>
<span id="cb73-7"><a href="#cb73-7" aria-hidden="true" tabindex="-1"></a>                 input_axis<span class="op">=</span><span class="dv">2</span>,      <span class="co"># Input dimension (image=2, video=3)</span></span>
<span id="cb73-8"><a href="#cb73-8" aria-hidden="true" tabindex="-1"></a>                 num_latents<span class="op">=</span><span class="dv">256</span>,  <span class="co"># Number of latent vectors</span></span>
<span id="cb73-9"><a href="#cb73-9" aria-hidden="true" tabindex="-1"></a>                 latent_dim<span class="op">=</span><span class="dv">512</span>,    <span class="co"># Latent vector dimension</span></span>
<span id="cb73-10"><a href="#cb73-10" aria-hidden="true" tabindex="-1"></a>                 num_heads<span class="op">=</span><span class="dv">8</span>,       <span class="co"># Number of attention heads</span></span>
<span id="cb73-11"><a href="#cb73-11" aria-hidden="true" tabindex="-1"></a>                 depth<span class="op">=</span><span class="dv">6</span>):          <span class="co"># Model depth (number of self-attention layers)</span></span>
<span id="cb73-12"><a href="#cb73-12" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb73-13"><a href="#cb73-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-14"><a href="#cb73-14" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 1. Latent vector initialization (key!)</span></span>
<span id="cb73-15"><a href="#cb73-15" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.latents <span class="op">=</span> nn.Parameter(torch.randn(num_latents, latent_dim))</span>
<span id="cb73-16"><a href="#cb73-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-17"><a href="#cb73-17" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 2. Input projection (matches input dimension to latent dimension)</span></span>
<span id="cb73-18"><a href="#cb73-18" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.input_proj <span class="op">=</span> nn.Linear(input_dim, latent_dim)</span>
<span id="cb73-19"><a href="#cb73-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-20"><a href="#cb73-20" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 3. Cross-Attention (learns relationships between input and latent vectors)</span></span>
<span id="cb73-21"><a href="#cb73-21" aria-hidden="true" tabindex="-1"></a>        <span class="co"># self.cross_attention = nn.MultiheadAttention(latent_dim, num_heads, batch_first=True)</span></span>
<span id="cb73-22"><a href="#cb73-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-23"><a href="#cb73-23" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 4. Self-Attention (learns relationships between latent vectors) - repeated multiple times</span></span>
<span id="cb73-24"><a href="#cb73-24" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.self_attention_layers <span class="op">=</span> nn.ModuleList([</span>
<span id="cb73-25"><a href="#cb73-25" aria-hidden="true" tabindex="-1"></a>            nn.MultiheadAttention(latent_dim, num_heads, batch_first<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb73-26"><a href="#cb73-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(depth)</span>
<span id="cb73-27"><a href="#cb73-27" aria-hidden="true" tabindex="-1"></a>        ])</span>
<span id="cb73-28"><a href="#cb73-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-29"><a href="#cb73-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-30"><a href="#cb73-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, x):  <span class="co"># x: Input data (image, text, ...)</span></span>
<span id="cb73-31"><a href="#cb73-31" aria-hidden="true" tabindex="-1"></a>        batch_size <span class="op">=</span> x.shape[<span class="dv">0</span>]</span>
<span id="cb73-32"><a href="#cb73-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-33"><a href="#cb73-33" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 1. Input projection</span></span>
<span id="cb73-34"><a href="#cb73-34" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> <span class="va">self</span>.input_proj(x)</span>
<span id="cb73-35"><a href="#cb73-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-36"><a href="#cb73-36" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 2. Latent vector replication (for each item in the batch)</span></span>
<span id="cb73-37"><a href="#cb73-37" aria-hidden="true" tabindex="-1"></a>        latents <span class="op">=</span> <span class="va">self</span>.latents.unsqueeze(<span class="dv">0</span>).expand(batch_size, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>)  <span class="co"># (B, num_latents, latent_dim)</span></span>
<span id="cb73-38"><a href="#cb73-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-39"><a href="#cb73-39" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 3. (Optional) Cross-attention (between input and latent vectors)</span></span>
<span id="cb73-40"><a href="#cb73-40" aria-hidden="true" tabindex="-1"></a>        <span class="co"># latents, _ = self.cross_attention(latents, x, x)  # query, key, value</span></span>
<span id="cb73-41"><a href="#cb73-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-42"><a href="#cb73-42" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 4. Self-attention (between latent vectors) - repeated multiple times</span></span>
<span id="cb73-43"><a href="#cb73-43" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> layer <span class="kw">in</span> <span class="va">self</span>.self_attention_layers:</span>
<span id="cb73-44"><a href="#cb73-44" aria-hidden="true" tabindex="-1"></a>            latents, _ <span class="op">=</span> layer(latents, latents, latents) <span class="co"># query, key, value</span></span>
<span id="cb73-45"><a href="#cb73-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-46"><a href="#cb73-46" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> latents  <span class="co"># Return the processed latent vectors</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p><strong>Perceiver의 장단점</strong></p>
<p>Perceiver는 입력 크기에 관계없이 계산 복잡도가 거의 일정하다는 효율성을 가지며, 다양한 모달리티를 동일한 방식으로 처리할 수 있는 유연성을 제공합니다. 또한, 새로운 모달리티를 쉽게 추가할 수 있는 확장성도 Perceiver의 장점입니다. 하지만 Perceiver는 여전히 트랜스포머를 기반으로 하기 때문에 구조가 복잡하며, 잠재 벡터의 차원과 층 수가 커지면 모델이 매우 커질 수 있다는 단점이 있습니다. 또한, 이미지 분류와 같이 특정 태스크에서는 CNN과 같이 해당 태스크에 특화된 모델보다 성능이 떨어질 수 있습니다.</p>
<p><strong>Perceiver IO</strong></p>
<p>Perceiver의 후속 연구인 Perceiver IO는 입력뿐만 아니라 출력도 잠재 벡터를 통해 처리하는 방식을 제안했습니다. 이를 통해 다양한 출력 형태(classification, regression, sequence generation 등)를 유연하게 다룰 수 있게 되었습니다. Perceiver IO는 Perceiver보다 더 일반적이고 강력한 모델로 평가받고 있습니다.</p>
</section>
<section id="크로스-어텐션-구현과-훈련-안정성" class="level3">
<h3 class="anchored" data-anchor-id="크로스-어텐션-구현과-훈련-안정성">10.4.4 크로스 어텐션 구현과 훈련 안정성</h3>
<p>여기서는 크로스 어텐션의 기본 구조부터 시작하여 점진적으로 매커니즘을 추가하면서 훈련 가능과 성능을 비교합니다. 이를 통해 멀티모달 학습에서 발생하는 문제들을 이해하고, 이를 해결하기 위한 실용적인 접근 방법을 살펴보겠습니다.</p>
<p>크로스 어텐션 메커니즘을 설계할 때 이 절의 내용과 같이 점진적으로 복잡도를 높여가며 실험하는 방식은 매우 일반적이고 권장되는 접근 방식입니다. <strong>제거 연구(Ablation study)</strong> 라고 불리는 이 방식은 각 구성 매커니즘의 중요성을 파악하고, 최종 모델의 성능에 기여하는 핵심 요소를 식별하는 데 효과적입니다. 새로운 아키텍처를 제안하는 많은 논문에서 이러한 접근 방식을 사용합니다. 또한, 단순히 최종 성능만이 아니라 훈련 과정에서의 안정성 문제를 함께 논의하는 것은 실용적인 관점에서 매우 중요합니다.</p>
<section id="훈련의-구조" class="level4">
<h4 class="anchored" data-anchor-id="훈련의-구조">10.4.4.1 훈련의 구조</h4>
<p><strong>비교 훈련 방식</strong></p>
<p>실험은 앞서 살펴본 flickr8k 데이터 셋으로 텍스트와 이미지 두개의 인풋을 가지고 상호 유사도를 훈련시킵니다. 훈련에서는 크로스 어텐션이 버전이 정해져 있으며 각 버전별로 복잡도가 증가합니다. 버전별로 크로스 어텐션의 매커니즘을 하나씩 추가하고, 그에 따라 훈련을 진행해서 비교를 합니다. 모든 훈련은 동일한 하이퍼파라미터를 사용합니다. 훈련 에포크는 5로 고정했습니다.</p>
<p><strong>예제의 구조</strong></p>
<p>예제는 다음과 같은 구조로 구성되어 있습니다.</p>
<pre><code>chatper_10/mm
├── cat_resized.png
├── cross_attention
│&nbsp;&nbsp; ├── v0.py
│&nbsp;&nbsp; ├── v1.py
│&nbsp;&nbsp; ├── v2.p
│&nbsp;&nbsp; ├── v3.py 
│&nbsp;&nbsp; .... (계속 존재)
├── train_multimodal.py
└── evaluate_models.py</code></pre>
<p>cross_attention 폴더 밑에 v1부터 v11까지 순차적으로 크로스어텐션의 복잡도를 증가시킵니다. <code>train_mulimodal.py</code>는 하나의 훈련이 끝나뎐 다음 버전의 모델을 동적으로 생성해서 훈련을 지속합니다. 훈련에서는 정확도, 대조 손실, 수행시간등의 메트릭을 저정해서 최종 비교 테이블을 생성합니다. 손실값과 정확도로 훈련 가능 여부를 판단하는 것은 바람직하지 않습니다. 대조학습의 특성상 올바르게 훈련이 진행되었는지 확인하는 가장 쉬운 방법은 기존에 없던 데이터로 평가 하는 방법입니다. 제로샷(zero-shot)으로 모델을 평가하는 파일은 <code>evalute_models.py</code>입니다.</p>
<p>평가하는 이미지는 다음입니다.</p>
<p><img src="../../../assets/images/cat_resized.png" class="img-fluid"></p>
<p>평가는 5개의 텍스트와 위 이미지의 유사도를 측정하는 방식으로 이루어집니다.</p>
<pre><code>test_captions = [
    "A dog playing in the park",
    "A cat sleeping on a couch",
    "Children playing soccer",
    "A sunset over the ocean",
    "A person cooking in the kitchen"
]</code></pre>
<p>모델 훈련이 제대로 이루어졌다면 5개 캡션 중 두번째 “A cat sleeping on a couch”이 가장 높은 유사도가 나와야 합니다. 위 이미지는 훈련데이터에 없던 것으로 전형적인 제로샷 테스트에 해당합니다.</p>
<p><strong>크로스어텐션 동적할당</strong></p>
<p>cross_attion의 버전을 바꾸는 것은 동적 할당을 통해서 이루어집니다.</p>
<div id="cell-47" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb76"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_10.mm.cross_attention.v0 <span class="im">import</span> CrossAttention <span class="im">as</span> v0</span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_10.mm.cross_attention.v1 <span class="im">import</span> CrossAttention <span class="im">as</span> v1</span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a><span class="co"># ... (import other versions) ...</span></span>
<span id="cb76-4"><a href="#cb76-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_10.mm.cross_attention.v11 <span class="im">import</span> CrossAttention <span class="im">as</span> v11</span>
<span id="cb76-5"><a href="#cb76-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-6"><a href="#cb76-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_cross_attention(version, config<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb76-7"><a href="#cb76-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> config <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb76-8"><a href="#cb76-8" aria-hidden="true" tabindex="-1"></a>        config <span class="op">=</span> {}</span>
<span id="cb76-9"><a href="#cb76-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-10"><a href="#cb76-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> version <span class="op">==</span> <span class="st">'v0'</span>:</span>
<span id="cb76-11"><a href="#cb76-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> v0(<span class="op">**</span>config)</span>
<span id="cb76-12"><a href="#cb76-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> version <span class="op">==</span> <span class="st">'v1'</span>:</span>
<span id="cb76-13"><a href="#cb76-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> v1(<span class="op">**</span>config)</span>
<span id="cb76-14"><a href="#cb76-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ... (other version conditions) ...</span></span>
<span id="cb76-15"><a href="#cb76-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> version <span class="op">==</span> <span class="st">'v11'</span>:</span>
<span id="cb76-16"><a href="#cb76-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> v11(<span class="op">**</span>config)</span>
<span id="cb76-17"><a href="#cb76-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb76-18"><a href="#cb76-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="ss">f"Invalid cross-attention version: </span><span class="sc">{</span>version<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb76-19"><a href="#cb76-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-20"><a href="#cb76-20" aria-hidden="true" tabindex="-1"></a><span class="co"># ...</span></span>
<span id="cb76-21"><a href="#cb76-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-22"><a href="#cb76-22" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ImageTextMatchingModel(nn.Module):</span>
<span id="cb76-23"><a href="#cb76-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, image_encoder_dim<span class="op">=</span><span class="dv">2048</span>, text_encoder_dim<span class="op">=</span><span class="dv">768</span>, projection_dim<span class="op">=</span><span class="dv">256</span>):</span>
<span id="cb76-24"><a href="#cb76-24" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb76-25"><a href="#cb76-25" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.image_encoder <span class="op">=</span> ImageEncoder(image_encoder_dim, projection_dim)</span>
<span id="cb76-26"><a href="#cb76-26" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.text_encoder <span class="op">=</span> TextEncoder(text_encoder_dim, projection_dim)</span>
<span id="cb76-27"><a href="#cb76-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-28"><a href="#cb76-28" aria-hidden="true" tabindex="-1"></a>        <span class="co"># The CrossAttention module is dynamically assigned in main().</span></span>
<span id="cb76-29"><a href="#cb76-29" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.cross_attention <span class="op">=</span> <span class="va">None</span>  <span class="co"># CrossAttention(projection_dim)</span></span>
<span id="cb76-30"><a href="#cb76-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-31"><a href="#cb76-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, image, input_ids, attention_mask):</span>
<span id="cb76-32"><a href="#cb76-32" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ...</span></span>
<span id="cb76-33"><a href="#cb76-33" aria-hidden="true" tabindex="-1"></a>        image_attended, text_attended <span class="op">=</span> <span class="va">self</span>.cross_attention(</span>
<span id="cb76-34"><a href="#cb76-34" aria-hidden="true" tabindex="-1"></a>            image_features.unsqueeze(<span class="dv">1</span>),</span>
<span id="cb76-35"><a href="#cb76-35" aria-hidden="true" tabindex="-1"></a>            text_features.unsqueeze(<span class="dv">1</span>)</span>
<span id="cb76-36"><a href="#cb76-36" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb76-37"><a href="#cb76-37" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ...</span></span>
<span id="cb76-38"><a href="#cb76-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-39"><a href="#cb76-39" aria-hidden="true" tabindex="-1"></a><span class="co"># ...</span></span>
<span id="cb76-40"><a href="#cb76-40" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> run_training(model_versions, ...):</span>
<span id="cb76-41"><a href="#cb76-41" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ...</span></span>
<span id="cb76-42"><a href="#cb76-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> model_version <span class="kw">in</span> model_versions:</span>
<span id="cb76-43"><a href="#cb76-43" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ...</span></span>
<span id="cb76-44"><a href="#cb76-44" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Model initialization</span></span>
<span id="cb76-45"><a href="#cb76-45" aria-hidden="true" tabindex="-1"></a>        model <span class="op">=</span> ImageTextMatchingModel()</span>
<span id="cb76-46"><a href="#cb76-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-47"><a href="#cb76-47" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Dynamically load the CrossAttention module</span></span>
<span id="cb76-48"><a href="#cb76-48" aria-hidden="true" tabindex="-1"></a>        model.cross_attention <span class="op">=</span> get_cross_attention(model_version, config<span class="op">=</span>config)</span>
<span id="cb76-49"><a href="#cb76-49" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ...</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>이 부분은 실험의 핵심인 다양한 버전의 <code>Cross-Attention</code> 모듈을 동적으로 로드하고 적용하는 로직을 구현합니다. <code>get_cross_attention</code> 함수는 문자열 형태의 버전(v0, v1, …, v11)을 입력받아 해당 버전에 맞는 <code>CrossAttention</code> 클래스의 인스턴스를 반환합니다. <code>run_training</code> 함수 내부에서는 <code>model_versions</code> 리스트에 지정된 각 버전에 대해 ImageTextMatchingModel을 초기화하고, <code>get_cross_attention</code> 함수를 호출하여 <code>model.cross_attention</code>에 해당 버전의 <code>Cross-Attention</code> 모듈을 할당합니다.</p>
<p>이러한 동적 할당 방식은 코드의 재사용성을 높이고, 실험 관리를 용이하게 합니다. 새로운 버전의 <code>Cross-Attention</code>을 추가할 때, <code>get_cross_attention</code> 함수에 해당 버전을 추가하기만 하면 되므로, 훈련 코드를 크게 수정할 필요가 없습니다. 또한 <code>run_training</code> 함수의 <code>model_versions</code> 리스트를 통해 어떤 버전들을 훈련할지 쉽게 제어할 수 있습니다.</p>
<p><strong>Contrastive Loss 계산 및 훈련 루프</strong></p>
<div id="cell-49" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb77"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> contrastive_loss(logits):</span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>    labels <span class="op">=</span> torch.arange(<span class="bu">len</span>(logits), device<span class="op">=</span>logits.device)</span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a>    loss_i <span class="op">=</span> nn.CrossEntropyLoss()(logits, labels)</span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a>    loss_t <span class="op">=</span> nn.CrossEntropyLoss()(logits.t(), labels)</span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (loss_i <span class="op">+</span> loss_t) <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb77-6"><a href="#cb77-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-7"><a href="#cb77-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> train(model, train_loader, val_loader, epochs<span class="op">=</span><span class="dv">10</span>, lr<span class="op">=</span><span class="fl">1e-4</span>, model_version<span class="op">=</span><span class="st">'v0'</span>):</span>
<span id="cb77-8"><a href="#cb77-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ...</span></span>
<span id="cb77-9"><a href="#cb77-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> epoch <span class="kw">in</span> <span class="bu">range</span>(epochs):</span>
<span id="cb77-10"><a href="#cb77-10" aria-hidden="true" tabindex="-1"></a>        model.train()</span>
<span id="cb77-11"><a href="#cb77-11" aria-hidden="true" tabindex="-1"></a>        total_loss <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb77-12"><a href="#cb77-12" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ...</span></span>
<span id="cb77-13"><a href="#cb77-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> batch <span class="kw">in</span> tqdm(train_loader, ...):</span>
<span id="cb77-14"><a href="#cb77-14" aria-hidden="true" tabindex="-1"></a>            images, input_ids, attention_mask <span class="op">=</span> [x.to(device) <span class="cf">for</span> x <span class="kw">in</span> batch]</span>
<span id="cb77-15"><a href="#cb77-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-16"><a href="#cb77-16" aria-hidden="true" tabindex="-1"></a>            optimizer.zero_grad()</span>
<span id="cb77-17"><a href="#cb77-17" aria-hidden="true" tabindex="-1"></a>            logits <span class="op">=</span> model(images, input_ids, attention_mask)</span>
<span id="cb77-18"><a href="#cb77-18" aria-hidden="true" tabindex="-1"></a>            loss <span class="op">=</span> contrastive_loss(logits)</span>
<span id="cb77-19"><a href="#cb77-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-20"><a href="#cb77-20" aria-hidden="true" tabindex="-1"></a>            loss.backward()</span>
<span id="cb77-21"><a href="#cb77-21" aria-hidden="true" tabindex="-1"></a>            optimizer.step()</span>
<span id="cb77-22"><a href="#cb77-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-23"><a href="#cb77-23" aria-hidden="true" tabindex="-1"></a>            total_loss <span class="op">+=</span> loss.item()</span>
<span id="cb77-24"><a href="#cb77-24" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ... (validation 및 지표 계산) ...</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>이 부분은 모델의 학습에 사용되는 Contrastive Loss 계산과 훈련 루프를 정의합니다. <code>contrastive_loss</code> 함수는 이미지-텍스트 쌍의 유사도 점수(logits)를 입력받아 Contrastive Loss를 계산합니다. 이때, 정답 레이블은 logits의 대각선 (즉, 동일 인덱스의 이미지-텍스트 쌍)에 해당하는 요소들이 1 (유사함)이고, 나머지는 0 (유사하지 않음)이 되도록 생성됩니다 (torch.arange 사용). 이미지 기준 Cross-Entropy Loss (loss_i)와 텍스트 기준 Cross-Entropy Loss (loss_t)를 모두 계산하고, 이 둘의 평균을 최종 loss로 사용합니다.</p>
<p><strong>훈련 방식 : 매커니즘의 추가</strong></p>
<p>가장 단순한 어텐션 구조에서 하나씩 기능을 추가하면서 테스트를 할 것입니다. 추가되는 기능을 “메커니즘”이라고 부르도록 하겠습니다. 각 메커니즘이 추가되면서 어떤 메커니즘이 멀티모달 어텐션 설계에 영향을 미치는지 살펴보겠습니다. 먼저 훈련 코드를 일부 살펴본 다음 바로 훈련 결과를 보도록 하겠습니다. 그 이후에 각 크로스모달 어텐션에서 어떤 매커니즘이 훈련의 성패를 좌우했는지도 살펴보겠습니다.</p>
<p>다음은 훈련 코드입니다. 훈련을 하면 각 모델이 <code>model_final_{버전}.pth</code> 으로 저장이됩니다. 이 저장된 모델을 이용해서 평가를 수행합니다.</p>
<div id="cell-51" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb78"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_10.mm.train_multimodal <span class="im">import</span> run_training</span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a><span class="co"># model_versions = ['v0', 'v1']  # List of model versions to train</span></span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true" tabindex="-1"></a>model_versions <span class="op">=</span> [<span class="st">'v0'</span>, <span class="st">'v1'</span>, <span class="st">'v2'</span>, <span class="st">'v3'</span>, <span class="st">'v4'</span>, <span class="st">'v5'</span>, <span class="st">'v6'</span>, <span class="st">'v7'</span>, <span class="st">'v8'</span>, <span class="st">'v9'</span>, <span class="st">'v10_1'</span>, <span class="st">'v10_2'</span>, <span class="st">'v10_3'</span>, <span class="st">'v10_4'</span>, <span class="st">'v10_5'</span>, <span class="st">'v10_6'</span>, <span class="st">'v11'</span>]</span>
<span id="cb78-5"><a href="#cb78-5" aria-hidden="true" tabindex="-1"></a>epochs <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb78-6"><a href="#cb78-6" aria-hidden="true" tabindex="-1"></a>lr <span class="op">=</span> <span class="fl">1e-4</span></span>
<span id="cb78-7"><a href="#cb78-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-8"><a href="#cb78-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Dataset </span></span>
<span id="cb78-9"><a href="#cb78-9" aria-hidden="true" tabindex="-1"></a>image_dir <span class="op">=</span> <span class="st">'./data/flickr8k/Images'</span>  <span class="co"># Change to the actual path</span></span>
<span id="cb78-10"><a href="#cb78-10" aria-hidden="true" tabindex="-1"></a>caption_file <span class="op">=</span> <span class="st">'./data/flickr8k/captions.txt'</span>  <span class="co"># Change to the actual path</span></span>
<span id="cb78-11"><a href="#cb78-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-12"><a href="#cb78-12" aria-hidden="true" tabindex="-1"></a>results_df <span class="op">=</span> run_training(model_versions, epochs<span class="op">=</span>epochs, lr<span class="op">=</span>lr, image_dir<span class="op">=</span>image_dir, caption_file<span class="op">=</span>caption_file) <span class="co"># Train multiple versions</span></span>
<span id="cb78-13"><a href="#cb78-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-14"><a href="#cb78-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Print results</span></span>
<span id="cb78-15"><a href="#cb78-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Training Results:"</span>)</span>
<span id="cb78-16"><a href="#cb78-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Print results in Markdown table format</span></span>
<span id="cb78-17"><a href="#cb78-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(results_df.to_markdown(index<span class="op">=</span><span class="va">False</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>모델로 평가를 수행합니다.</p>
<div id="cell-53" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb79"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_10.mm.evaluate_models <span class="im">import</span> evaluate_all_models</span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Test captions (fixed)</span></span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a>test_captions <span class="op">=</span> [</span>
<span id="cb79-5"><a href="#cb79-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">"A dog playing in the park"</span>,</span>
<span id="cb79-6"><a href="#cb79-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">"A cat sleeping on a couch"</span>,</span>
<span id="cb79-7"><a href="#cb79-7" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Children playing soccer"</span>,</span>
<span id="cb79-8"><a href="#cb79-8" aria-hidden="true" tabindex="-1"></a>    <span class="st">"A sunset over the ocean"</span>,</span>
<span id="cb79-9"><a href="#cb79-9" aria-hidden="true" tabindex="-1"></a>    <span class="st">"A person cooking in the kitchen"</span></span>
<span id="cb79-10"><a href="#cb79-10" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb79-11"><a href="#cb79-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-12"><a href="#cb79-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Run model evaluation</span></span>
<span id="cb79-13"><a href="#cb79-13" aria-hidden="true" tabindex="-1"></a>image_path <span class="op">=</span> <span class="st">'./cat_resized.png'</span></span>
<span id="cb79-14"><a href="#cb79-14" aria-hidden="true" tabindex="-1"></a>model_dir <span class="op">=</span> <span class="st">'.'</span></span>
<span id="cb79-15"><a href="#cb79-15" aria-hidden="true" tabindex="-1"></a>model_versions <span class="op">=</span> [<span class="st">'v0'</span>, <span class="st">'v1'</span>, <span class="st">'v2'</span>, <span class="st">'v3'</span>, <span class="st">'v4'</span>, <span class="st">'v5'</span>, <span class="st">'v6'</span>, <span class="st">'v7'</span>, <span class="st">'v8'</span>, <span class="st">'v9'</span>, <span class="st">'v10_1'</span>, <span class="st">'v10_2'</span>, <span class="st">'v10_3'</span>, <span class="st">'v10_4'</span>, <span class="st">'v10_5'</span>, <span class="st">'v10_6'</span>, <span class="st">'v11'</span>]</span>
<span id="cb79-16"><a href="#cb79-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-17"><a href="#cb79-17" aria-hidden="true" tabindex="-1"></a>results_df <span class="op">=</span> evaluate_all_models(model_dir, image_path, test_captions, model_versions)</span>
<span id="cb79-18"><a href="#cb79-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-19"><a href="#cb79-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Print results (Markdown table)</span></span>
<span id="cb79-20"><a href="#cb79-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(results_df.to_markdown(index<span class="op">=</span><span class="va">False</span>))</span>
<span id="cb79-21"><a href="#cb79-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-22"><a href="#cb79-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Print results (detailed)</span></span>
<span id="cb79-23"><a href="#cb79-23" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> _, row <span class="kw">in</span> results_df.iterrows():</span>
<span id="cb79-24"><a href="#cb79-24" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Model: </span><span class="sc">{</span>row[<span class="st">'model_version'</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb79-25"><a href="#cb79-25" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Best Caption: </span><span class="sc">{</span>row[<span class="st">'best_caption'</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb79-26"><a href="#cb79-26" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Trained Well: </span><span class="sc">{</span>row[<span class="st">'trained_well'</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb79-27"><a href="#cb79-27" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Similarity Ratio: </span><span class="sc">{</span>row[<span class="st">'similarity_ratio'</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb79-28"><a href="#cb79-28" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Similarity Gap: </span><span class="sc">{</span>row[<span class="st">'similarity_gap'</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb79-29"><a href="#cb79-29" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"  All Similarities:"</span>)</span>
<span id="cb79-30"><a href="#cb79-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> caption, sim <span class="kw">in</span> <span class="bu">zip</span>(test_captions, row[<span class="st">'all_similarities'</span>]):</span>
<span id="cb79-31"><a href="#cb79-31" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"    - </span><span class="sc">{</span>caption<span class="sc">:&lt;30}</span><span class="ss">: </span><span class="sc">{</span>sim<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="실험결과" class="level4">
<h4 class="anchored" data-anchor-id="실험결과">10.4.4.2 실험결과</h4>
</section>
<section id="실험-결과표" class="level4">
<h4 class="anchored" data-anchor-id="실험-결과표"><strong>실험 결과표</strong></h4>
<table class="caption-top table">
<colgroup>
<col style="width: 12%">
<col style="width: 23%">
<col style="width: 17%">
<col style="width: 17%">
<col style="width: 11%">
<col style="width: 4%">
<col style="width: 15%">
</colgroup>
<thead>
<tr class="header">
<th>model_version</th>
<th>best_caption</th>
<th>all_similarities</th>
<th>similarity_ratio</th>
<th>similarity_gap</th>
<th>trained_well</th>
<th>similarity_ratio_rank</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>v0</td>
<td>A cat sleeping on a couch</td>
<td>[‘5.322’, ‘15.477’, ‘-4.509’, ‘-6.609’, ‘2.107’]</td>
<td>2.908</td>
<td>10.155</td>
<td>True</td>
<td>1</td>
</tr>
<tr class="even">
<td>v1</td>
<td>A cat sleeping on a couch</td>
<td>[‘3.117’, ‘18.174’, ‘-6.475’, ‘-1.825’, ‘8.705’]</td>
<td>2.088</td>
<td>9.469</td>
<td>True</td>
<td>3</td>
</tr>
<tr class="odd">
<td>v2</td>
<td>A cat sleeping on a couch</td>
<td>[‘3.085’, ‘12.541’, ‘-4.252’, ‘0.924’, ‘6.849’]</td>
<td>1.831</td>
<td>5.692</td>
<td>True</td>
<td>5</td>
</tr>
<tr class="even">
<td>v3</td>
<td>Children playing soccer</td>
<td>[‘34.882’, ‘34.882’, ‘34.882’, ‘34.882’, ‘34.882’]</td>
<td>1</td>
<td>0</td>
<td>False</td>
<td>14</td>
</tr>
<tr class="odd">
<td>v4</td>
<td>A cat sleeping on a couch</td>
<td>[‘7.385’, ‘8.301’, ‘-1.038’, ‘-6.262’, ‘1.240’]</td>
<td>1.124</td>
<td>0.915</td>
<td>True</td>
<td>12</td>
</tr>
<tr class="even">
<td>v5</td>
<td>Children playing soccer</td>
<td>[‘27.357’, ‘27.357’, ‘27.357’, ‘27.357’, ‘27.357’]</td>
<td>1</td>
<td>0</td>
<td>False</td>
<td>14</td>
</tr>
<tr class="odd">
<td>v6</td>
<td>A cat sleeping on a couch</td>
<td>[‘5.022’, ‘14.861’, ‘-5.370’, ‘-8.630’, ‘9.063’]</td>
<td>1.64</td>
<td>5.798</td>
<td>True</td>
<td>7</td>
</tr>
<tr class="even">
<td>v7</td>
<td>A dog playing in the park</td>
<td>[‘16.300’, ‘16.300’, ‘16.300’, ‘16.300’, ‘16.300’]</td>
<td>1</td>
<td>0</td>
<td>False</td>
<td>14</td>
</tr>
<tr class="odd">
<td>v8</td>
<td>A cat sleeping on a couch</td>
<td>[‘9.841’, ‘15.442’, ‘-7.350’, ‘-1.249’, ‘11.023’]</td>
<td>1.401</td>
<td>4.419</td>
<td>True</td>
<td>10</td>
</tr>
<tr class="even">
<td>v9</td>
<td>A cat sleeping on a couch</td>
<td>[‘10.382’, ‘15.192’, ‘-5.582’, ‘-1.594’, ‘5.953’]</td>
<td>1.463</td>
<td>4.81</td>
<td>True</td>
<td>9</td>
</tr>
<tr class="odd">
<td>v10_1</td>
<td>A dog playing in the park</td>
<td>[‘0.940’, ‘0.472’, ‘-0.554’, ‘0.334’, ‘-0.111’]</td>
<td>1.991</td>
<td>0.468</td>
<td>False</td>
<td>4</td>
</tr>
<tr class="even">
<td>v10_2</td>
<td>A cat sleeping on a couch</td>
<td>[‘17.720’, ‘17.720’, ‘17.720’, ‘17.720’, ‘17.720’]</td>
<td>1</td>
<td>0</td>
<td>True</td>
<td>14</td>
</tr>
<tr class="odd">
<td>v10_3</td>
<td>A cat sleeping on a couch</td>
<td>[‘0.516’, ‘1.479’, ‘-0.941’, ‘-0.106’, ‘0.694’]</td>
<td>2.132</td>
<td>0.786</td>
<td>True</td>
<td>2</td>
</tr>
<tr class="even">
<td>v10_4</td>
<td>A cat sleeping on a couch</td>
<td>[‘5.913’, ‘10.334’, ‘-5.989’, ‘-1.024’, ‘5.151’]</td>
<td>1.748</td>
<td>4.421</td>
<td>True</td>
<td>6</td>
</tr>
<tr class="odd">
<td>v10_5</td>
<td>A cat sleeping on a couch</td>
<td>[‘6.601’, ‘9.990’, ‘-5.984’, ‘-2.988’, ‘-0.070’]</td>
<td>1.513</td>
<td>3.389</td>
<td>True</td>
<td>8</td>
</tr>
<tr class="even">
<td>v10_6</td>
<td>A dog playing in the park</td>
<td>[‘33.967’, ‘33.302’, ‘31.580’, ‘32.710’, ‘31.384’]</td>
<td>1.02</td>
<td>0.665</td>
<td>False</td>
<td>13</td>
</tr>
<tr class="odd">
<td>v11</td>
<td>A cat sleeping on a couch</td>
<td>[‘11.315’, ‘15.491’, ‘-10.428’, ‘-0.004’, ‘10.014’]</td>
<td>1.369</td>
<td>4.175</td>
<td>True</td>
<td>11</td>
</tr>
</tbody>
</table>
</section>
<section id="모델-구조와-훈련성패의-분석표" class="level4">
<h4 class="anchored" data-anchor-id="모델-구조와-훈련성패의-분석표"><strong>모델 구조와 훈련성패의 분석표</strong></h4>
<p>이 실험 결과들을 바탕으로, 각 크로스 어텐션 버전별 훈련 결과를 분석하고, 훈련 성공/실패 원인을 다음과 같이 정리할 수 있습니다.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
</colgroup>
<thead>
<tr class="header">
<th>버전</th>
<th>어텐션 구조</th>
<th>주요 특징</th>
<th>훈련 결과</th>
<th>상세 설명</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>v0</td>
<td>독립적 양방향 어텐션</td>
<td>스케일링된 내적 어텐션만 사용</td>
<td>훈련 성공</td>
<td>가장 기본적인 구조. 이미지와 텍스트 각각에 대해 독립적으로 어텐션을 계산. 스케일링 외 다른 정규화/변환 없음. 별도의 정규화 과정이 없어, 입력 feature의 scale 변화에 민감.</td>
</tr>
<tr class="even">
<td>v1</td>
<td>공유 어텐션</td>
<td>단일 어텐션 행렬과 전치행렬 사용</td>
<td>훈련 성공</td>
<td>이미지→텍스트, 텍스트→이미지 어텐션 계산에 동일한 어텐션 행렬을 공유. 양방향 정보 교환을 시도했지만, 정규화 부재로 인해 여전히 입력 스케일에 민감하고, 두 모달리티 간의 비대칭적인 관계를 제대로 반영하지 못함.</td>
</tr>
<tr class="odd">
<td>v2</td>
<td>공유 어텐션 + LN</td>
<td>입력에 LayerNorm 적용</td>
<td>훈련 성공</td>
<td>입력 특징에 LayerNorm을 적용하여 특징 스케일 안정화. v1의 문제점(입력 스케일 민감성)을 해결. 어텐션 행렬은 여전히 공유.</td>
</tr>
<tr class="even">
<td>v3</td>
<td>v2 + 잔차 연결</td>
<td>출력에 잔차 연결 추가</td>
<td>훈련 실패</td>
<td>어텐션 계산 후 원본 특징(image_features, text_features)을 직접 더하는 잔차 연결을 추가. 이는 원본 특징을 과도하게 보존하여, 두 모달리티 간의 상호 작용을 통해 새로운 특징을 생성하는 것을 방해. 특히, 얕은 네트워크 구조에서는 이러한 현상이 두드러짐.</td>
</tr>
<tr class="odd">
<td>v4</td>
<td>v2 + 프로젝션</td>
<td>모달리티별 선형 변환</td>
<td>훈련 성공</td>
<td>각 모달리티에 독립적인 선형 프로젝션(self.image_proj, self.text_proj) 적용. LayerNorm으로 정규화된 입력(image_norm, text_norm)에 대해 별도의 선형 변환을 적용함으로써, 각 모달리티의 특징 공간을 더 유연하게 조절하고, 어텐션 계산에 적합한 형태로 변환.</td>
</tr>
<tr class="even">
<td>v5</td>
<td>v2 + 혼합 비율</td>
<td>0.5 고정 혼합비율</td>
<td>훈련 실패</td>
<td>원본 특징(image_norm, text_norm)과 어텐션 출력(image_attended, text_attended)을 고정된 비율(0.5)로 혼합. 잔차 연결(v3)과 유사하게 원본 특징을 보존하지만, 고정된 혼합 비율 때문에 모델이 데이터에 따라 유연하게 가중치를 조절하는 능력을 제한.</td>
</tr>
<tr class="odd">
<td>v6</td>
<td>공유 어텐션 + Q/K/V</td>
<td>Q/K/V 변환과 단일 LayerNorm</td>
<td>훈련 성공</td>
<td>입력(image_norm, text_norm)에 대해 Query(Q), Key(K), Value(V)를 생성하는 별도의 선형 변환(self.to_q, self.to_k, self.to_v)을 추가. 이를 통해 어텐션 메커니즘이 더 풍부한 특징 표현을 학습. 여전히 공유 어텐션 행렬을 사용.</td>
</tr>
<tr class="even">
<td>v7</td>
<td>공유 멀티헤드</td>
<td>멀티헤드 + 출력 정규화</td>
<td>훈련 실패</td>
<td>공유 어텐션 행렬을 멀티헤드 어텐션으로 확장. 입력에 대한 LayerNorm은 유지(v2). 각 헤드가 서로 다른 특징을 학습할 수 있도록 했지만, 여전히 공유 어텐션을 사용하기 때문에 이미지→텍스트와 텍스트→이미지 간의 비대칭적인 관계를 제대로 모델링하지 못함. 출력에 LayerNorm을 적용했음에도, 훈련에는 실패.</td>
</tr>
<tr class="odd">
<td>v8</td>
<td>독립 멀티헤드</td>
<td>독립적 양방향 멀티헤드 + 이중 정규화</td>
<td>훈련 성공</td>
<td>이미지→텍스트와 텍스트→이미지 어텐션을 독립적인 멀티헤드 어텐션으로 분리. 입력뿐만 아니라 출력에도 LayerNorm 적용. 각 모달리티의 특성을 보존하면서 양방향 정보 교환을 효과적으로 수행.</td>
</tr>
<tr class="even">
<td>v9</td>
<td>v8 + Pre-LN + FFN</td>
<td>게이트된 FFN과 드롭아웃 추가</td>
<td>훈련 성공</td>
<td>v8의 구조에 Pre-LayerNorm, 게이트된 Feed-Forward Network (FFN), 드롭아웃 추가. Pre-LN은 어텐션과 FFN 전에 LayerNorm을 적용하여 훈련 안정성을 높임. 게이트된 FFN은 GELU 활성화 함수와 드롭아웃을 사용하여 비선형성을 강화하고 과적합을 방지. FFN 출력에만 잔차 연결을 적용하여 정보 흐름을 개선.</td>
</tr>
<tr class="odd">
<td>v10_1</td>
<td>v9 + 모달리티별 Q/K/V</td>
<td>각 모달리티에 특화된 변환</td>
<td>훈련 실패</td>
<td>v9를 기반으로, 각 모달리티에 대해 별도의 Q, K, V 프로젝션(self.image_to_q, self.image_to_k, …, self.text_to_v)을 사용. 이는 모델의 복잡도를 크게 증가시키지만, 각 모달리티의 특성을 지나치게 분리하여, 두 모달리티 간의 상호 작용을 학습하는 데 어려움을 겪음.</td>
</tr>
<tr class="even">
<td>v10_2</td>
<td>v9 + 교차 게이트</td>
<td>모달리티 간 정보 흐름 제어</td>
<td>훈련 실패</td>
<td>v9에 교차 게이트 메커니즘 추가. 어텐션 출력과 원본 feature를 concat한 후, gate layer(sigmoid)를 적용해서, modality간 정보 교환을 제어함. 그러나, gate layer에 대한 정규화가 없고, 초기 gate값이 매우 작아(self.gate_scale = 0.1) 정보 흐름을 효과적으로 제어하지 못하고, 학습을 방해.</td>
</tr>
<tr class="odd">
<td>v10_3</td>
<td>v9 + 컨텍스트 레이어</td>
<td>모달리티별 문맥 정보 처리</td>
<td>훈련 성공</td>
<td>v9에 각 모달리티별 컨텍스트 레이어(self.image_context, self.text_context) 추가. 이는 각 모달리티의 특징을 추가적으로 처리하여 어텐션 계산 전에 더 풍부한 문맥 정보를 제공.</td>
</tr>
<tr class="even">
<td>v10_4</td>
<td>v9 + 멀티쿼리</td>
<td>K,V 공유 방식의 어텐션</td>
<td>훈련 성공</td>
<td>v9에서 멀티쿼리 어텐션(Multi-Query Attention) 메커니즘을 도입. Query는 각 헤드별로 독립적으로 유지하되, Key와 Value는 모든 헤드가 공유(self.to_kv). 이는 파라미터 수를 줄이면서도, 각 헤드가 서로 다른 관점에서 쿼리를 생성하여 다양한 특징을 포착.</td>
</tr>
<tr class="odd">
<td>v10_5</td>
<td>v9 + 계층적 멀티헤드</td>
<td>3단계 레벨별 특징 처리, 가중치 기반 융합</td>
<td>훈련 성공</td>
<td>v9에 계층적 멀티헤드 어텐션 구조를 도입. 입력 특징을 3단계 레벨로 나누어 처리(self.level_projections, self.level_norms). 각 레벨에서 독립적인 멀티헤드 어텐션을 수행하고, 학습 가능한 가중치(self.level_weights)를 사용하여 각 레벨의 출력을 융합. 이는 모델이 다양한 수준의 추상화된 특징을 학습하고, 이들을 효과적으로 결합.</td>
</tr>
<tr class="even">
<td>v10_6</td>
<td>v9 + 대조학습 멀티헤드</td>
<td>대조학습 기반 유사도 제한, 특징 보강</td>
<td>훈련 실패</td>
<td>v9에 대조 학습(contrastive learning)을 위한 별도의 프로젝션 레이어(self.contrast_proj)를 추가. 정규화된 대조 학습 특징 간의 유사도를 계산하고, 이를 원본 특징에 직접 더하는 방식으로 어텐션 출력을 보강. 그러나 이는 원본 feature를 왜곡시켜 v3와 유사하게, 두 modality간 상호작용을 방해해서, 학습에 실패.</td>
</tr>
<tr class="odd">
<td>v11</td>
<td>v9 + 멀티쿼리 + 계층적 융합</td>
<td>K,V 공유와 3단계 레벨 특징 처리 결합</td>
<td>훈련 성공</td>
<td>v10_4 (멀티쿼리)와 v10_5 (계층적 멀티헤드)의 장점을 결합. 멀티쿼리 어텐션을 통해 파라미터 효율성을 높이고, 계층적 융합을 통해 다양한 수준의 특징을 통합. v9의 Pre-LN, 게이트 FFN, 드롭아웃 등의 안정화 기법도 유지.</td>
</tr>
</tbody>
</table>
</section>
<section id="어텐션-구조별-설명" class="level4">
<h4 class="anchored" data-anchor-id="어텐션-구조별-설명">10.4.4.3 어텐션 구조별 설명</h4>
<p><strong>1. v0:</strong> 독립적 양방향 어텐션 - 기본 구조</p>
<p>v0는 가장 기본적인 형태의 Cross-Modal Attention을 구현합니다. 이미지와 텍스트 각각에 대해 독립적인 어텐션을 계산하며, 스케일링된 내적(Scaled Dot-Product Attention) 외에 다른 정규화나 변환은 사용하지 않습니다.</p>
<div id="cell-55" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb80"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.nn <span class="im">as</span> nn</span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.nn.functional <span class="im">as</span> F</span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-5"><a href="#cb80-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-6"><a href="#cb80-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> CrossAttention(nn.Module):</span>
<span id="cb80-7"><a href="#cb80-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, dim):</span>
<span id="cb80-8"><a href="#cb80-8" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb80-9"><a href="#cb80-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.scale <span class="op">=</span> dim <span class="op">**</span> <span class="op">-</span><span class="fl">0.5</span></span>
<span id="cb80-10"><a href="#cb80-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-11"><a href="#cb80-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, image_features, text_features):</span>
<span id="cb80-12"><a href="#cb80-12" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Image -&gt; Text attention</span></span>
<span id="cb80-13"><a href="#cb80-13" aria-hidden="true" tabindex="-1"></a>        attn_i2t <span class="op">=</span> torch.matmul(image_features, text_features.transpose(<span class="op">-</span><span class="dv">2</span>, <span class="op">-</span><span class="dv">1</span>)) <span class="op">*</span> <span class="va">self</span>.scale</span>
<span id="cb80-14"><a href="#cb80-14" aria-hidden="true" tabindex="-1"></a>        attn_i2t <span class="op">=</span> attn_i2t.softmax(dim<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb80-15"><a href="#cb80-15" aria-hidden="true" tabindex="-1"></a>        image_attended <span class="op">=</span> torch.matmul(attn_i2t, text_features)</span>
<span id="cb80-16"><a href="#cb80-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-17"><a href="#cb80-17" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Text -&gt; Image attention</span></span>
<span id="cb80-18"><a href="#cb80-18" aria-hidden="true" tabindex="-1"></a>        attn_t2i <span class="op">=</span> torch.matmul(text_features, image_features.transpose(<span class="op">-</span><span class="dv">2</span>, <span class="op">-</span><span class="dv">1</span>)) <span class="op">*</span> <span class="va">self</span>.scale</span>
<span id="cb80-19"><a href="#cb80-19" aria-hidden="true" tabindex="-1"></a>        attn_t2i <span class="op">=</span> attn_t2i.softmax(dim<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb80-20"><a href="#cb80-20" aria-hidden="true" tabindex="-1"></a>        text_attended <span class="op">=</span> torch.matmul(attn_t2i, image_features)</span>
<span id="cb80-21"><a href="#cb80-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-22"><a href="#cb80-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> image_attended, text_attended</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>v0는 별도의 정규화 과정이 없기 때문에, 입력 특징의 스케일 변화에 민감하게 반응합니다. 입력 데이터의 스케일이 학습 과정에서 크게 변하면, 어텐션 가중치가 불안정해지고, 훈련이 제대로 이루어지지 않을 수 있습니다.</p>
<p><strong>2. v2:</strong> 공유 어텐션 + Layer Normalization</p>
<p>v2는 v1에서 입력 특징에 Layer Normalization(LN)을 적용하여 특징 스케일을 안정화시킨 버전입니다. v1은 이미지→텍스트, 텍스트→이미지 어텐션 계산에 동일한 어텐션 행렬(가중치 행렬)과 그 전치 행렬을 사용했지만, 입력 스케일에 민감하다는 단점이 있었습니다.</p>
<div id="cell-57" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb81"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.nn <span class="im">as</span> nn</span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.nn.functional <span class="im">as</span> F</span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Co-attention + added LN</span></span>
<span id="cb81-6"><a href="#cb81-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> CrossAttention(nn.Module):</span>
<span id="cb81-7"><a href="#cb81-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, dim):</span>
<span id="cb81-8"><a href="#cb81-8" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb81-9"><a href="#cb81-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.scale <span class="op">=</span> dim <span class="op">**</span> <span class="op">-</span><span class="fl">0.5</span></span>
<span id="cb81-10"><a href="#cb81-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.norm <span class="op">=</span> nn.LayerNorm(dim)  <span class="co"># Use a single LayerNorm</span></span>
<span id="cb81-11"><a href="#cb81-11" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb81-12"><a href="#cb81-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, image_features, text_features):</span>
<span id="cb81-13"><a href="#cb81-13" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Input normalization</span></span>
<span id="cb81-14"><a href="#cb81-14" aria-hidden="true" tabindex="-1"></a>        image_norm <span class="op">=</span> <span class="va">self</span>.norm(image_features)</span>
<span id="cb81-15"><a href="#cb81-15" aria-hidden="true" tabindex="-1"></a>        text_norm <span class="op">=</span> <span class="va">self</span>.norm(text_features)</span>
<span id="cb81-16"><a href="#cb81-16" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb81-17"><a href="#cb81-17" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Simple attention calculation</span></span>
<span id="cb81-18"><a href="#cb81-18" aria-hidden="true" tabindex="-1"></a>        attn <span class="op">=</span> torch.matmul(image_norm, text_norm.transpose(<span class="op">-</span><span class="dv">2</span>, <span class="op">-</span><span class="dv">1</span>)) <span class="op">*</span> <span class="va">self</span>.scale</span>
<span id="cb81-19"><a href="#cb81-19" aria-hidden="true" tabindex="-1"></a>        attn <span class="op">=</span> attn.softmax(dim<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb81-20"><a href="#cb81-20" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb81-21"><a href="#cb81-21" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Bidirectional feature fusion (without residual connection)</span></span>
<span id="cb81-22"><a href="#cb81-22" aria-hidden="true" tabindex="-1"></a>        image_out <span class="op">=</span> torch.matmul(attn, text_norm)</span>
<span id="cb81-23"><a href="#cb81-23" aria-hidden="true" tabindex="-1"></a>        text_out <span class="op">=</span> torch.matmul(attn.transpose(<span class="op">-</span><span class="dv">2</span>, <span class="op">-</span><span class="dv">1</span>), image_norm)</span>
<span id="cb81-24"><a href="#cb81-24" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb81-25"><a href="#cb81-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> image_out, text_out</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p><code>image_norm = self.norm(image_features)</code> 및 <code>text_norm = self.norm(text_features)</code>에서 입력 특징에 Layer Normalization을 적용합니다. Layer Normalization은 각 샘플(미니배치 내의 각 이미지 또는 텍스트)에 대해 독립적으로 정규화를 수행합니다. 즉, 각 샘플의 특징 벡터의 평균과 분산을 계산하여, 이를 0과 1로 만듭니다. 이를 통해 입력 특징의 스케일이 크게 변하더라도, 어텐션 가중치가 발산하는 것을 방지하여 학습을 안정화합니다.</p>
<p>그러나 여전히 한계는 있습니다. v2는 Layer Normalization을 통해 입력 스케일 문제를 해결했지만 이미지→텍스트와 텍스트→이미지 어텐션에 동일한 어텐션 행렬을 사용합니다. 이는 두 모달리티 간의 비대칭적인 관계를 충분히 반영하지 못할 수 있습니다. 이미지에서 텍스트를 생성하는 것과 텍스트에서 이미지를 생성하는 것은 서로 다른 복잡도를 가질 수 있습니다.이를 동일한 어텐션 메커니즘으로 처리하는 것은 비효율적일 수 있습니다.</p>
<p><strong>3. v3:</strong> v2 + 잔차 연결 (Residual Connection) - 실패 사례</p>
<p>ResNet 모델 아키텍처 이후, 전가의 보도 처럼 사용되었던 잔차 연결이 여기서는 실패의 원인이 됩니다. 잔차 연결은 일반적으로 네트워크가 깊어질수록 발생할 수 있는 기울기 소실(Gradient Vanishing) 문제를 완화하고, 더 깊은 네트워크를 효과적으로 학습하기 위해 널리 사용되는 기법입니다. 하지만, 이번 실험에서는 잔차 연결이 오히려 성능을 저하시키는 실패 사례 를 보여주었습니다.</p>
<p>이는 매우 중요한 관찰입니다.</p>
<div id="cell-59" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb82"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.nn <span class="im">as</span> nn</span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.nn.functional <span class="im">as</span> F</span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> CrossAttention(nn.Module):</span>
<span id="cb82-6"><a href="#cb82-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, dim):</span>
<span id="cb82-7"><a href="#cb82-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb82-8"><a href="#cb82-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.scale <span class="op">=</span> dim <span class="op">**</span> <span class="op">-</span><span class="fl">0.5</span></span>
<span id="cb82-9"><a href="#cb82-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.norm <span class="op">=</span> nn.LayerNorm(dim)  <span class="co"># Use a single LayerNorm</span></span>
<span id="cb82-10"><a href="#cb82-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-11"><a href="#cb82-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, image_features, text_features):</span>
<span id="cb82-12"><a href="#cb82-12" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Input normalization</span></span>
<span id="cb82-13"><a href="#cb82-13" aria-hidden="true" tabindex="-1"></a>        image_norm <span class="op">=</span> <span class="va">self</span>.norm(image_features)</span>
<span id="cb82-14"><a href="#cb82-14" aria-hidden="true" tabindex="-1"></a>        text_norm <span class="op">=</span> <span class="va">self</span>.norm(text_features)</span>
<span id="cb82-15"><a href="#cb82-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-16"><a href="#cb82-16" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Simple attention calculation</span></span>
<span id="cb82-17"><a href="#cb82-17" aria-hidden="true" tabindex="-1"></a>        attn <span class="op">=</span> torch.matmul(image_norm, text_norm.transpose(<span class="op">-</span><span class="dv">2</span>, <span class="op">-</span><span class="dv">1</span>)) <span class="op">*</span> <span class="va">self</span>.scale</span>
<span id="cb82-18"><a href="#cb82-18" aria-hidden="true" tabindex="-1"></a>        attn <span class="op">=</span> attn.softmax(dim<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb82-19"><a href="#cb82-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-20"><a href="#cb82-20" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Bidirectional feature fusion</span></span>
<span id="cb82-21"><a href="#cb82-21" aria-hidden="true" tabindex="-1"></a>        image_attended <span class="op">=</span> torch.matmul(attn, text_norm)</span>
<span id="cb82-22"><a href="#cb82-22" aria-hidden="true" tabindex="-1"></a>        text_attended <span class="op">=</span> torch.matmul(attn.transpose(<span class="op">-</span><span class="dv">2</span>, <span class="op">-</span><span class="dv">1</span>), image_norm)</span>
<span id="cb82-23"><a href="#cb82-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-24"><a href="#cb82-24" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Add residual connection</span></span>
<span id="cb82-25"><a href="#cb82-25" aria-hidden="true" tabindex="-1"></a>        image_out <span class="op">=</span> image_features <span class="op">+</span> image_attended</span>
<span id="cb82-26"><a href="#cb82-26" aria-hidden="true" tabindex="-1"></a>        text_out <span class="op">=</span> text_features <span class="op">+</span> text_attended</span>
<span id="cb82-27"><a href="#cb82-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-28"><a href="#cb82-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> image_out, text_out</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>일반적으로 잔차 연결은 네트워크가 깊어질수록 학습이 어려워지는 문제를 해결하는 데 효과적입니다. 하지만 v3에서는 다음과 같은 이유로 인해 오히려 성능이 저하되는 결과를 초래했습니다.</p>
<p><strong>상대적으로 얕은 네트워크:</strong> v3 모델은 깊이가 깊지 않은, 비교적 얕은 네트워크 구조를 가지고 있습니다. 잔차 연결은 깊은 네트워크에서 기울기 소실 문제를 완화하는 데 큰 도움을 주지만, 얕은 네트워크에서는 그 효과가 미미하며, 오히려 정보의 흐름을 방해할 수 있습니다.</p>
<p><strong>원본 특징의 과도한 보존:</strong> Cross-Modal Attention의 핵심은 이미지와 텍스트, 두 가지 다른 모달리티(Modality) 간의 상호 작용을 통해 새로운 특징을 생성하는 것입니다. 하지만 v3에서는 어텐션 연산 결과에 원본 특징 벡터를 그대로 더함으로써, 어텐션 메커니즘을 통해 얻은 중요한 정보를 희석시키고, 두 모달리티 간의 상호 작용을 통한 특징 생성을 방해하는 결과를 낳았습니다. 즉, 모델이 새로운 정보를 학습하기보다 기존 정보를 유지하는 데 집중하게 된 것입니다.</p>
<p>v3의 실험 결과는 잔차 연결이 항상 성능을 향상시키는 <strong>만능 해결책이 아니라는 중요한 교훈</strong>을 줍니다. 잔차 연결은 네트워크의 깊이, 적용 위치, 그리고 문제의 특성 등을 고려하여 신중하게 사용해야 합니다. v3는 잔차 연결을 부적절하게 사용하여 성능이 저하된 대표적인 실패 사례라고 할 수 있습니다.</p>
<p><strong>4. v8:</strong> 독립 멀티헤드 어텐션</p>
<p>v8에서는 이전 버전(v7)의 문제점을 해결하고, Cross-Modal Attention의 성능을 향상시키는 중요한 변화를 도입했습니다. 바로 이미지→텍스트 어텐션과 텍스트→이미지 어텐션을 독립적인 멀티헤드 어텐션(Multi-Head Attention)으로 분리한 것입니다. 또한, 입력뿐만 아니라 어텐션 연산의 출력에도 Layer Normalization을 적용하여 훈련의 안정성을 더욱 강화했습니다.</p>
<div id="cell-61" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb83"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.nn <span class="im">as</span> nn</span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.nn.functional <span class="im">as</span> F</span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-5"><a href="#cb83-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-6"><a href="#cb83-6" aria-hidden="true" tabindex="-1"></a><span class="co"># v8 - Independent multi-head</span></span>
<span id="cb83-7"><a href="#cb83-7" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> CrossAttention(nn.Module):</span>
<span id="cb83-8"><a href="#cb83-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, dim, num_heads<span class="op">=</span><span class="dv">8</span>):</span>
<span id="cb83-9"><a href="#cb83-9" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb83-10"><a href="#cb83-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.num_heads <span class="op">=</span> num_heads</span>
<span id="cb83-11"><a href="#cb83-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.head_dim <span class="op">=</span> dim <span class="op">//</span> num_heads</span>
<span id="cb83-12"><a href="#cb83-12" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.scale <span class="op">=</span> <span class="va">self</span>.head_dim <span class="op">**</span> <span class="op">-</span><span class="fl">0.5</span></span>
<span id="cb83-13"><a href="#cb83-13" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.norm <span class="op">=</span> nn.LayerNorm(dim)</span>
<span id="cb83-14"><a href="#cb83-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-15"><a href="#cb83-15" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Projections for multi-head attention</span></span>
<span id="cb83-16"><a href="#cb83-16" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.to_q <span class="op">=</span> nn.Linear(dim, dim)</span>
<span id="cb83-17"><a href="#cb83-17" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.to_k <span class="op">=</span> nn.Linear(dim, dim)</span>
<span id="cb83-18"><a href="#cb83-18" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.to_v <span class="op">=</span> nn.Linear(dim, dim)</span>
<span id="cb83-19"><a href="#cb83-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-20"><a href="#cb83-20" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Output projection</span></span>
<span id="cb83-21"><a href="#cb83-21" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.to_out <span class="op">=</span> nn.Linear(dim, dim)</span>
<span id="cb83-22"><a href="#cb83-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-23"><a href="#cb83-23" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Add output normalization</span></span>
<span id="cb83-24"><a href="#cb83-24" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.out_norm <span class="op">=</span> nn.LayerNorm(dim)</span>
<span id="cb83-25"><a href="#cb83-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-26"><a href="#cb83-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, image_features, text_features):</span>
<span id="cb83-27"><a href="#cb83-27" aria-hidden="true" tabindex="-1"></a>        B, N_i, _ <span class="op">=</span> image_features.shape</span>
<span id="cb83-28"><a href="#cb83-28" aria-hidden="true" tabindex="-1"></a>        _, N_t, _ <span class="op">=</span> text_features.shape</span>
<span id="cb83-29"><a href="#cb83-29" aria-hidden="true" tabindex="-1"></a>        H <span class="op">=</span> <span class="va">self</span>.num_heads</span>
<span id="cb83-30"><a href="#cb83-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-31"><a href="#cb83-31" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Input normalization</span></span>
<span id="cb83-32"><a href="#cb83-32" aria-hidden="true" tabindex="-1"></a>        image_norm <span class="op">=</span> <span class="va">self</span>.norm(image_features)</span>
<span id="cb83-33"><a href="#cb83-33" aria-hidden="true" tabindex="-1"></a>        text_norm <span class="op">=</span> <span class="va">self</span>.norm(text_features)</span>
<span id="cb83-34"><a href="#cb83-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-35"><a href="#cb83-35" aria-hidden="true" tabindex="-1"></a>        <span class="kw">def</span> split_heads(x):</span>
<span id="cb83-36"><a href="#cb83-36" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> x.reshape(B, <span class="op">-</span><span class="dv">1</span>, H, <span class="va">self</span>.head_dim).transpose(<span class="dv">1</span>, <span class="dv">2</span>)</span>
<span id="cb83-37"><a href="#cb83-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-38"><a href="#cb83-38" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Image -&gt; Text direction attention</span></span>
<span id="cb83-39"><a href="#cb83-39" aria-hidden="true" tabindex="-1"></a>        q_img <span class="op">=</span> split_heads(<span class="va">self</span>.to_q(image_norm))</span>
<span id="cb83-40"><a href="#cb83-40" aria-hidden="true" tabindex="-1"></a>        k_txt <span class="op">=</span> split_heads(<span class="va">self</span>.to_k(text_norm))</span>
<span id="cb83-41"><a href="#cb83-41" aria-hidden="true" tabindex="-1"></a>        v_txt <span class="op">=</span> split_heads(<span class="va">self</span>.to_v(text_norm))</span>
<span id="cb83-42"><a href="#cb83-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-43"><a href="#cb83-43" aria-hidden="true" tabindex="-1"></a>        attn_i2t <span class="op">=</span> torch.matmul(q_img, k_txt.transpose(<span class="op">-</span><span class="dv">2</span>, <span class="op">-</span><span class="dv">1</span>)) <span class="op">*</span> <span class="va">self</span>.scale</span>
<span id="cb83-44"><a href="#cb83-44" aria-hidden="true" tabindex="-1"></a>        attn_i2t <span class="op">=</span> attn_i2t.softmax(dim<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb83-45"><a href="#cb83-45" aria-hidden="true" tabindex="-1"></a>        image_attended <span class="op">=</span> torch.matmul(attn_i2t, v_txt)</span>
<span id="cb83-46"><a href="#cb83-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-47"><a href="#cb83-47" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Text -&gt; Image direction attention</span></span>
<span id="cb83-48"><a href="#cb83-48" aria-hidden="true" tabindex="-1"></a>        q_txt <span class="op">=</span> split_heads(<span class="va">self</span>.to_q(text_norm))</span>
<span id="cb83-49"><a href="#cb83-49" aria-hidden="true" tabindex="-1"></a>        k_img <span class="op">=</span> split_heads(<span class="va">self</span>.to_k(image_norm))</span>
<span id="cb83-50"><a href="#cb83-50" aria-hidden="true" tabindex="-1"></a>        v_img <span class="op">=</span> split_heads(<span class="va">self</span>.to_v(image_norm))</span>
<span id="cb83-51"><a href="#cb83-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-52"><a href="#cb83-52" aria-hidden="true" tabindex="-1"></a>        attn_t2i <span class="op">=</span> torch.matmul(q_txt, k_img.transpose(<span class="op">-</span><span class="dv">2</span>, <span class="op">-</span><span class="dv">1</span>)) <span class="op">*</span> <span class="va">self</span>.scale</span>
<span id="cb83-53"><a href="#cb83-53" aria-hidden="true" tabindex="-1"></a>        attn_t2i <span class="op">=</span> attn_t2i.softmax(dim<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb83-54"><a href="#cb83-54" aria-hidden="true" tabindex="-1"></a>        text_attended <span class="op">=</span> torch.matmul(attn_t2i, v_img)</span>
<span id="cb83-55"><a href="#cb83-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-56"><a href="#cb83-56" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Combine heads and output projection</span></span>
<span id="cb83-57"><a href="#cb83-57" aria-hidden="true" tabindex="-1"></a>        image_attended <span class="op">=</span> image_attended.transpose(<span class="dv">1</span>, <span class="dv">2</span>).reshape(B, N_i, <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb83-58"><a href="#cb83-58" aria-hidden="true" tabindex="-1"></a>        text_attended <span class="op">=</span> text_attended.transpose(<span class="dv">1</span>, <span class="dv">2</span>).reshape(B, N_t, <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb83-59"><a href="#cb83-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-60"><a href="#cb83-60" aria-hidden="true" tabindex="-1"></a>        image_out <span class="op">=</span> <span class="va">self</span>.out_norm(<span class="va">self</span>.to_out(image_attended))</span>
<span id="cb83-61"><a href="#cb83-61" aria-hidden="true" tabindex="-1"></a>        text_out <span class="op">=</span> <span class="va">self</span>.out_norm(<span class="va">self</span>.to_out(text_attended))</span>
<span id="cb83-62"><a href="#cb83-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-63"><a href="#cb83-63" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> image_out, text_out</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>v7에서도 멀티헤드 어텐션을 도입했지만, 여전히 이미지→텍스트와 텍스트→이미지 어텐션에 동일한 Q, K, V 변환을 사용했습니다. 즉, 모든 헤드가 같은 Q, K, V 행렬을 공유했기 때문에, 각 헤드가 서로 다른 특징을 학습하는 데 제약이 있었고, 이는 모델의 표현력을 제한하는 요인이 되었습니다. v8은 이러한 문제를 해결하기 위해 독립적인 Q, K, V 변환을 각 방향(이미지→텍스트, 텍스트→이미지)과 각 헤드에 적용함으로써, 모델이 훨씬 더 유연하고 풍부한 특징 표현을 학습할 수 있도록 했습니다.</p>
<p><strong>5. v9:</strong> v8 + Pre-LN + FFN (게이트 FFN + 드롭아웃)</p>
<p>v9는 v8의 구조를 기반으로, 훈련 안정성과 성능을 더욱 향상시키기 위한 세 가지 중요한 메커니즘을 추가했습니다. 바로 Pre-Layer Normalization, 게이트 Feed-Forward Network (FFN), 그리고 드롭아웃(Dropout)입니다.</p>
<div id="cell-63" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb84"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.nn <span class="im">as</span> nn</span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.nn.functional <span class="im">as</span> F</span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-5"><a href="#cb84-5" aria-hidden="true" tabindex="-1"></a><span class="co"># v9 - Dropout before gated FFN, pass through norm at the end -&gt; trainable</span></span>
<span id="cb84-6"><a href="#cb84-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> CrossAttention(nn.Module):</span>
<span id="cb84-7"><a href="#cb84-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, dim, num_heads<span class="op">=</span><span class="dv">8</span>, dropout<span class="op">=</span><span class="fl">0.1</span>, ff_dim<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb84-8"><a href="#cb84-8" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb84-9"><a href="#cb84-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.num_heads <span class="op">=</span> num_heads</span>
<span id="cb84-10"><a href="#cb84-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.head_dim <span class="op">=</span> dim <span class="op">//</span> num_heads</span>
<span id="cb84-11"><a href="#cb84-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.scale <span class="op">=</span> <span class="va">self</span>.head_dim <span class="op">**</span> <span class="op">-</span><span class="fl">0.5</span></span>
<span id="cb84-12"><a href="#cb84-12" aria-hidden="true" tabindex="-1"></a>        ff_dim <span class="op">=</span> ff_dim <span class="kw">or</span> dim <span class="op">*</span> <span class="dv">4</span></span>
<span id="cb84-13"><a href="#cb84-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-14"><a href="#cb84-14" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Normalization layers for Pre-LN</span></span>
<span id="cb84-15"><a href="#cb84-15" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.attn_norm <span class="op">=</span> nn.LayerNorm(dim)</span>
<span id="cb84-16"><a href="#cb84-16" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.ff_norm <span class="op">=</span> nn.LayerNorm(dim)</span>
<span id="cb84-17"><a href="#cb84-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-18"><a href="#cb84-18" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Projections for multi-head attention</span></span>
<span id="cb84-19"><a href="#cb84-19" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.to_q <span class="op">=</span> nn.Linear(dim, dim)</span>
<span id="cb84-20"><a href="#cb84-20" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.to_k <span class="op">=</span> nn.Linear(dim, dim)</span>
<span id="cb84-21"><a href="#cb84-21" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.to_v <span class="op">=</span> nn.Linear(dim, dim)</span>
<span id="cb84-22"><a href="#cb84-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-23"><a href="#cb84-23" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Output projection</span></span>
<span id="cb84-24"><a href="#cb84-24" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.to_out <span class="op">=</span> nn.Linear(dim, dim)</span>
<span id="cb84-25"><a href="#cb84-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-26"><a href="#cb84-26" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Dropout</span></span>
<span id="cb84-27"><a href="#cb84-27" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.dropout <span class="op">=</span> nn.Dropout(dropout)</span>
<span id="cb84-28"><a href="#cb84-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-29"><a href="#cb84-29" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Gated feedforward network</span></span>
<span id="cb84-30"><a href="#cb84-30" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.ff_gate <span class="op">=</span> nn.Sequential(</span>
<span id="cb84-31"><a href="#cb84-31" aria-hidden="true" tabindex="-1"></a>            nn.Linear(dim, ff_dim),</span>
<span id="cb84-32"><a href="#cb84-32" aria-hidden="true" tabindex="-1"></a>            nn.GELU(),</span>
<span id="cb84-33"><a href="#cb84-33" aria-hidden="true" tabindex="-1"></a>            nn.Dropout(dropout)</span>
<span id="cb84-34"><a href="#cb84-34" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb84-35"><a href="#cb84-35" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.ff_value <span class="op">=</span> nn.Sequential(</span>
<span id="cb84-36"><a href="#cb84-36" aria-hidden="true" tabindex="-1"></a>            nn.Linear(dim, ff_dim),</span>
<span id="cb84-37"><a href="#cb84-37" aria-hidden="true" tabindex="-1"></a>            nn.GELU(),</span>
<span id="cb84-38"><a href="#cb84-38" aria-hidden="true" tabindex="-1"></a>            nn.Dropout(dropout)</span>
<span id="cb84-39"><a href="#cb84-39" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb84-40"><a href="#cb84-40" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.ff_out <span class="op">=</span> nn.Linear(ff_dim, dim)</span>
<span id="cb84-41"><a href="#cb84-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-42"><a href="#cb84-42" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, image_features, text_features):</span>
<span id="cb84-43"><a href="#cb84-43" aria-hidden="true" tabindex="-1"></a>        B, N_i, _ <span class="op">=</span> image_features.shape</span>
<span id="cb84-44"><a href="#cb84-44" aria-hidden="true" tabindex="-1"></a>        _, N_t, _ <span class="op">=</span> text_features.shape</span>
<span id="cb84-45"><a href="#cb84-45" aria-hidden="true" tabindex="-1"></a>        H <span class="op">=</span> <span class="va">self</span>.num_heads</span>
<span id="cb84-46"><a href="#cb84-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-47"><a href="#cb84-47" aria-hidden="true" tabindex="-1"></a>        <span class="kw">def</span> split_heads(x):</span>
<span id="cb84-48"><a href="#cb84-48" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> x.reshape(B, <span class="op">-</span><span class="dv">1</span>, H, <span class="va">self</span>.head_dim).transpose(<span class="dv">1</span>, <span class="dv">2</span>)</span>
<span id="cb84-49"><a href="#cb84-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-50"><a href="#cb84-50" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Pre-LN: Normalize before attention</span></span>
<span id="cb84-51"><a href="#cb84-51" aria-hidden="true" tabindex="-1"></a>        image_norm <span class="op">=</span> <span class="va">self</span>.attn_norm(image_features)</span>
<span id="cb84-52"><a href="#cb84-52" aria-hidden="true" tabindex="-1"></a>        text_norm <span class="op">=</span> <span class="va">self</span>.attn_norm(text_features)</span>
<span id="cb84-53"><a href="#cb84-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-54"><a href="#cb84-54" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Image -&gt; Text direction attention</span></span>
<span id="cb84-55"><a href="#cb84-55" aria-hidden="true" tabindex="-1"></a>        q_img <span class="op">=</span> split_heads(<span class="va">self</span>.to_q(image_norm))</span>
<span id="cb84-56"><a href="#cb84-56" aria-hidden="true" tabindex="-1"></a>        k_txt <span class="op">=</span> split_heads(<span class="va">self</span>.to_k(text_norm))</span>
<span id="cb84-57"><a href="#cb84-57" aria-hidden="true" tabindex="-1"></a>        v_txt <span class="op">=</span> split_heads(<span class="va">self</span>.to_v(text_norm))</span>
<span id="cb84-58"><a href="#cb84-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-59"><a href="#cb84-59" aria-hidden="true" tabindex="-1"></a>        attn_i2t <span class="op">=</span> torch.matmul(q_img, k_txt.transpose(<span class="op">-</span><span class="dv">2</span>, <span class="op">-</span><span class="dv">1</span>)) <span class="op">*</span> <span class="va">self</span>.scale</span>
<span id="cb84-60"><a href="#cb84-60" aria-hidden="true" tabindex="-1"></a>        attn_i2t <span class="op">=</span> attn_i2t.softmax(dim<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb84-61"><a href="#cb84-61" aria-hidden="true" tabindex="-1"></a>        attn_i2t <span class="op">=</span> <span class="va">self</span>.dropout(attn_i2t)  <span class="co"># Apply dropout to attention weights</span></span>
<span id="cb84-62"><a href="#cb84-62" aria-hidden="true" tabindex="-1"></a>        image_attended <span class="op">=</span> torch.matmul(attn_i2t, v_txt)</span>
<span id="cb84-63"><a href="#cb84-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-64"><a href="#cb84-64" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Text -&gt; Image direction attention</span></span>
<span id="cb84-65"><a href="#cb84-65" aria-hidden="true" tabindex="-1"></a>        q_txt <span class="op">=</span> split_heads(<span class="va">self</span>.to_q(text_norm))</span>
<span id="cb84-66"><a href="#cb84-66" aria-hidden="true" tabindex="-1"></a>        k_img <span class="op">=</span> split_heads(<span class="va">self</span>.to_k(image_norm))</span>
<span id="cb84-67"><a href="#cb84-67" aria-hidden="true" tabindex="-1"></a>        v_img <span class="op">=</span> split_heads(<span class="va">self</span>.to_v(image_norm))</span>
<span id="cb84-68"><a href="#cb84-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-69"><a href="#cb84-69" aria-hidden="true" tabindex="-1"></a>        attn_t2i <span class="op">=</span> torch.matmul(q_txt, k_img.transpose(<span class="op">-</span><span class="dv">2</span>, <span class="op">-</span><span class="dv">1</span>)) <span class="op">*</span> <span class="va">self</span>.scale</span>
<span id="cb84-70"><a href="#cb84-70" aria-hidden="true" tabindex="-1"></a>        attn_t2i <span class="op">=</span> attn_t2i.softmax(dim<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb84-71"><a href="#cb84-71" aria-hidden="true" tabindex="-1"></a>        attn_t2i <span class="op">=</span> <span class="va">self</span>.dropout(attn_t2i)  <span class="co"># Apply dropout to attention weights</span></span>
<span id="cb84-72"><a href="#cb84-72" aria-hidden="true" tabindex="-1"></a>        text_attended <span class="op">=</span> torch.matmul(attn_t2i, v_img)</span>
<span id="cb84-73"><a href="#cb84-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-74"><a href="#cb84-74" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Combine heads and output projection</span></span>
<span id="cb84-75"><a href="#cb84-75" aria-hidden="true" tabindex="-1"></a>        image_attended <span class="op">=</span> image_attended.transpose(<span class="dv">1</span>, <span class="dv">2</span>).reshape(B, N_i, <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb84-76"><a href="#cb84-76" aria-hidden="true" tabindex="-1"></a>        text_attended <span class="op">=</span> text_attended.transpose(<span class="dv">1</span>, <span class="dv">2</span>).reshape(B, N_t, <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb84-77"><a href="#cb84-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-78"><a href="#cb84-78" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Output projection and dropout</span></span>
<span id="cb84-79"><a href="#cb84-79" aria-hidden="true" tabindex="-1"></a>        image_attended <span class="op">=</span> <span class="va">self</span>.dropout(<span class="va">self</span>.to_out(image_attended))</span>
<span id="cb84-80"><a href="#cb84-80" aria-hidden="true" tabindex="-1"></a>        text_attended <span class="op">=</span> <span class="va">self</span>.dropout(<span class="va">self</span>.to_out(text_attended))</span>
<span id="cb84-81"><a href="#cb84-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-82"><a href="#cb84-82" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Residual connection - connecting the original image features makes training impossible.</span></span>
<span id="cb84-83"><a href="#cb84-83" aria-hidden="true" tabindex="-1"></a>        <span class="co"># image_attended = image_attended + image_features</span></span>
<span id="cb84-84"><a href="#cb84-84" aria-hidden="true" tabindex="-1"></a>        <span class="co"># text_attended = text_attended + text_features</span></span>
<span id="cb84-85"><a href="#cb84-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-86"><a href="#cb84-86" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Pre-LN: Normalize before FFN</span></span>
<span id="cb84-87"><a href="#cb84-87" aria-hidden="true" tabindex="-1"></a>        image_ff <span class="op">=</span> <span class="va">self</span>.ff_norm(image_attended)</span>
<span id="cb84-88"><a href="#cb84-88" aria-hidden="true" tabindex="-1"></a>        text_ff <span class="op">=</span> <span class="va">self</span>.ff_norm(text_attended)</span>
<span id="cb84-89"><a href="#cb84-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-90"><a href="#cb84-90" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Gated feedforward processing</span></span>
<span id="cb84-91"><a href="#cb84-91" aria-hidden="true" tabindex="-1"></a>        <span class="kw">def</span> apply_ff(x):</span>
<span id="cb84-92"><a href="#cb84-92" aria-hidden="true" tabindex="-1"></a>            gate <span class="op">=</span> <span class="va">self</span>.ff_gate(x)</span>
<span id="cb84-93"><a href="#cb84-93" aria-hidden="true" tabindex="-1"></a>            value <span class="op">=</span> <span class="va">self</span>.ff_value(x)</span>
<span id="cb84-94"><a href="#cb84-94" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">self</span>.dropout(<span class="va">self</span>.ff_out(gate <span class="op">*</span> value))</span>
<span id="cb84-95"><a href="#cb84-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-96"><a href="#cb84-96" aria-hidden="true" tabindex="-1"></a>        <span class="co"># FFN output and residual connection - this type of residual connection is possible.</span></span>
<span id="cb84-97"><a href="#cb84-97" aria-hidden="true" tabindex="-1"></a>        image_out <span class="op">=</span> apply_ff(image_ff) <span class="op">+</span> image_attended</span>
<span id="cb84-98"><a href="#cb84-98" aria-hidden="true" tabindex="-1"></a>        text_out <span class="op">=</span> apply_ff(text_ff) <span class="op">+</span> text_attended</span>
<span id="cb84-99"><a href="#cb84-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-100"><a href="#cb84-100" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> image_out, text_out</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<ul>
<li><p><strong>Pre-Layer Normalization:</strong> v8에서는 어텐션 연산 <em>이후</em>에 Layer Normalization을 적용했지만(Post-LN), v9에서는 <em>이전</em>에 적용합니다(Pre-LN). <code>self.image_norm_q</code>, <code>self.image_norm_k</code>, …, <code>self.text_norm_v</code>가 여기에 해당합니다. Pre-LN은 Post-LN보다 훈련 안정성이 더 높고, 별도의 warmup이 필요 없다는 장점이 있어 최근 Transformer 기반 모델에서 널리 사용됩니다.</p></li>
<li><p><strong>게이트 Feed-Forward Network (FFN):</strong> v8의 어텐션 연산 이후에 FFN을 추가하여 비선형성을 강화하고, 모델의 표현력을 높입니다.</p>
<ul>
<li><code>self.image_ffn</code>과 <code>self.text_ffn</code>은 FFN을 정의합니다. FFN은 두 개의 선형 레이어(Linear Layer)와 그 사이에 GELU(Gaussian Error Linear Unit) 활성화 함수, 그리고 드롭아웃으로 구성됩니다.</li>
<li><strong>GELU 활성화 함수:</strong> ReLU보다 부드러운 비선형 함수로, 더 나은 성능을 보이는 경향이 있습니다.</li>
<li><strong>FFN 이후 잔차연결 &amp; LayerNorm:</strong> FFN의 출력에 <em>잔차 연결</em>을 적용하고, Layer Normalization(<code>self.image_ffn_norm</code>, <code>self.text_ffn_norm</code>)을 적용합니다. v3와 다르게, <em>FFN을 거친 후에</em> 잔차연결을 적용하여, 단순 원본 feature 보존이 아닌, 비선형 처리 이후 정보 결합이 이루어져, 정보 흐름을 개선하고, 성능 향상에 기여합니다.</li>
</ul></li>
<li><p><strong>드롭아웃 (Dropout):</strong> <code>self.dropout</code>은 어텐션 가중치와 FFN 내부에 적용되는 드롭아웃을 정의합니다. 드롭아웃은 학습 중에 무작위로 뉴런을 비활성화하여 모델의 과적합(Overfitting)을 방지하는 데 효과적인 정규화(Regularization) 기법입니다.</p></li>
</ul>
<p><strong>추가된 매커니즘들의 효과</strong></p>
<ul>
<li>v9는 v8의 독립 멀티헤드 어텐션 구조를 그대로 유지하면서, Pre-LN, 게이트 FFN, 드롭아웃을 추가하여 훈련 안정성과 성능을 더욱 향상시켰습니다.</li>
<li><strong>Pre-LN:</strong> 훈련 초기 단계를 더 안정적으로 만들고, 별도의 학습률 웜업(warmup) 없이도 모델을 효과적으로 학습할 수 있게 합니다.</li>
<li><strong>게이트 FFN:</strong> 어텐션 연산 이후에 비선형 변환을 추가하여 모델의 표현력을 높입니다. GELU 활성화 함수와 드롭아웃은 FFN의 성능을 더욱 향상시키는 역할을 합니다.</li>
<li><strong>드롭아웃:</strong> 모델의 과적합을 방지하고, 일반화 성능을 높입니다.</li>
</ul>
<p>v9는 이러한 기법들의 조합을 통해 Cross-Modal Attention의 성능을 크게 향상시켰으며, 이후 버전들의 기반이 되었습니다.</p>
</section>
<section id="주요-결과-분석" class="level4">
<h4 class="anchored" data-anchor-id="주요-결과-분석">10.4.4.4 주요 결과 분석</h4>
<ul>
<li><p><strong>v0, v1 (기본 구조):</strong> 정규화 없이 단순한 어텐션만 사용한 v0, v1은 훈련은 <em>성공</em> 했습니다. 하지만, v1의 경우 훈련은 되었으나, 훈련과 검증 데이터셋 모두에서 “고양이” 관련 캡션에 더 높은 유사도를 보였습니다. 이는 정규화의 중요성을 시사합니다.</p></li>
<li><p><strong>v2 (LayerNorm):</strong> 입력에 LayerNorm을 적용한 v2는 훈련에 성공했습니다. 이는 입력 특징의 스케일을 안정화하는 것이 중요함을 보여줍니다.</p></li>
<li><p><strong>v3 (잔차 연결):</strong> v2에 잔차 연결을 추가한 v3는 훈련에 실패했습니다. 이는 멀티모달 학습에서 잔차 연결이 <em>항상</em> 도움이 되는 것은 아님을 보여줍니다. 잔차 연결이 원본 특징을 과도하게 유지하여, 두 모달리티 간의 상호 작용을 학습하는 데 방해가 될 수 있습니다.</p></li>
<li><p><strong>v4 (프로젝션):</strong> 각 모달리티에 독립적인 선형 변환(projection)을 추가한 v4는 훈련에 성공했습니다. 이는 각 모달리티의 특징 공간을 적절히 변환하는 것이 중요함을 시사합니다.</p></li>
<li><p><strong>v7 (공유 멀티헤드):</strong> 공유 어텐션 행렬을 멀티헤드로 확장한 v7은 훈련에 실패했습니다. 이는 각 헤드가 서로 다른 모달리티의 특성을 제대로 반영하지 못했기 때문으로 해석됩니다.</p></li>
<li><p><strong>v8 (독립 멀티헤드):</strong> 각 방향(이미지→텍스트, 텍스트→이미지)에 대해 독립적인 멀티헤드 어텐션을 사용하고, 입력과 출력에 별도의 LayerNorm을 적용한 v8은 훈련에 성공했습니다. 이는 각 모달리티의 특성을 보존하면서 정보 교환을 하는것이 중요함을 보여줍니다.</p></li>
<li><p><strong>v10_1 (모달리티별 Q/K/V):</strong> v9를 기반으로 각 모달리티에 특화된 Q/K/V 변환을 도입한 v10_1은 훈련이 불안정했습니다. 이는 모델의 복잡도가 증가하고, 과적합의 위험이 커졌기 때문으로 풀이됩니다.</p></li>
<li><p><strong>v10_2 (Cross-Gate):</strong> v9에 cross-modal gating 메커니즘을 추가한 v10_2는 훈련에 실패했습니다. 이는 gating 메커니즘이 두 모달리티 간의 정보 흐름을 적절히 제어하지 못하고, 오히려 학습을 방해했기 때문으로 보입니다. 너무 이른 단계에서 정보 교환을 제한하는 것이 원인일 수 있습니다.</p></li>
<li><p><strong>v10_3 (컨텍스트 레이어):</strong> 각 모달리티에 별도의 컨텍스트 처리 레이어를 추가한 v10_3는 훈련에 성공했습니다. 이 레이어는 각 모달리티의 특징을 더 정제하고, 추가적인 문맥 정보를 제공하여 성능 향상에 기여했을 것으로 예상됩니다.</p></li>
<li><p><strong>v10_4 (멀티쿼리 어텐션):</strong> 쿼리(Q)는 독립적으로 유지하되, 키(K)와 값(V)는 공유하는 멀티쿼리 어텐션을 적용한 v10_4는 훈련에 성공했습니다. 이는 파라미터 수를 줄이면서도 효율적인 정보 교환을 가능하게 하여, 일반화 성능을 향상시킨 것으로 해석됩니다.</p></li>
<li><p><strong>v10_5 (계층적 멀티헤드):</strong> 3단계의 계층적 구조를 도입하고, 각 레벨에서 독립적인 멀티헤드 어텐션을 적용한 후, 가중치를 통해 융합하는 v10_5는 훈련에 성공했습니다. 이는 점진적으로 특징을 통합하고, 각 레벨의 정보를 효과적으로 활용하여 성능을 높인 것으로 분석됩니다.</p></li>
<li><p><strong>v10_6 (대조 학습 멀티헤드):</strong> 대조 학습을 위한 별도의 프로젝션 레이어를 추가하고, 원본 특징에 유사도 정보를 직접 더하는 방식으로 훈련한 v10_6은 훈련이 불안정했습니다. 이는 유사도 정보가 원본 특징을 왜곡시켜 학습을 방해했을 가능성이 있습니다.</p></li>
<li><p><strong>v11 (멀티쿼리 + 계층적 융합):</strong> 멀티쿼리 어텐션(v10_4)과 계층적 멀티헤드(v10_5)의 장점을 결합한 v11은 훈련에 성공했습니다. 이는 파라미터 효율성과 점진적 특징 통합이라는 두 가지 이점을 모두 활용하여 안정적인 학습을 달성했음을 의미합니다.</p></li>
</ul>
<p><strong>결론</strong></p>
<p>이 제거 실험을 통해 다음과 같은 결론을 얻을 수 있습니다.</p>
<ol type="1">
<li><strong>정규화의 중요성:</strong> 입력 특징에 LayerNorm을 적용하는 것은 훈련 안정성에 매우 중요합니다 (v2).</li>
<li><strong>잔차 연결의 양면성:</strong> 잔차 연결은 유용한 메커니즘이지만, 멀티모달 학습 초기 단계에서는 오히려 해로울 수 있습니다 (v3). 원본 특징을 과도하게 유지하는 것이 두 모달리티 간 상호작용 학습을 방해합니다.</li>
<li><strong>독립적인 특징 변환:</strong> 각 모달리티에 독립적인 선형 변환(projection)을 적용하면 성능을 향상시킬 수 있습니다 (v4).</li>
<li><strong>멀티헤드 어텐션:</strong> 멀티헤드 어텐션을 사용할 때는 각 헤드가 서로 다른 모달리티의 특성을 반영하도록 독립적으로 구성해야 합니다 (v7, v8).</li>
<li><strong>적절한 복잡도:</strong> 모델의 복잡도를 과도하게 높이는 것은 훈련을 불안정하게 만들 수 있습니다 (v10_1, v10_2, v10_6).</li>
<li><strong>효율적인 메커니즘:</strong> 멀티쿼리 어텐션(v10_4)과 계층적 융합(v10_5)은 각각 파라미터 효율성과 점진적 특징 통합이라는 장점을 제공합니다.</li>
<li><strong>최적 조합의 중요성:</strong> v11에서 볼 수 있듯이, 효과적인 메커니즘들을 적절히 조합하면 더욱 안정적이고 성능이 좋은 멀티모달 학습 모델을 구축할 수 있습니다.</li>
</ol>
<p>이러한 제거 실험은 멀티모달 학습에서 각 구성 요소의 역할과 중요성을 이해하는 데 매우 유용합니다. 더 나아가 새로운 모델을 설계할 때 중요한 지침을 제공합니다. 특정 메커니즘의 유무에 따른 성능 변화를 체계적으로 분석함으로써, 어떤 요소가 멀티모달 융합에 효과적인지, 그리고 어떤 조합이 최적의 결과를 가져오는지 파악할 수 있습니다.</p>
<p>보다 체계적인 실험 케이스와 프로젝트용 프레임워크를 설계하면 대규모 모델과 다양한 매커니즘에 대한 실험도 원활히 수행할 수 있습니다. 연구에 도움이 되길 바랍니다.</p>
</section>
</section>
</section>
<section id="비전-트랜스포머vit" class="level2">
<h2 class="anchored" data-anchor-id="비전-트랜스포머vit">10.5 비전 트랜스포머(ViT)</h2>
<p>이번 절에서는 이미지 처리 분야에 혁신을 가져온 비전 트랜스포머(Vision Transformer, ViT)와, ViT의 확장인 ViT-22B, MAE를 간단히 살펴보겠습니다.</p>
<section id="cnn에서-vit로의-패러다임-전환" class="level3">
<h3 class="anchored" data-anchor-id="cnn에서-vit로의-패러다임-전환">10.5.1 CNN에서 ViT로의 패러다임 전환</h3>
<p>2020년, 구글 리서치 팀은 “An Image is Worth 16x16 Words: Transformers for Image Recognition at Scale”이라는 논문을 통해 ViT를 세상에 소개했습니다. ViT는 오랫동안 이미지 처리 분야를 지배해 온 합성곱 신경망(Convolutional Neural Network, CNN)의 시대가 저물고, 트랜스포머(Transformer) 기반의 새로운 시대가 도래했음을 알리는 신호탄이었습니다.</p>
<p>ViT의 핵심 아이디어는 간단합니다. 이미지를 여러 개의 작은 조각(패치, Patch)으로 나누고, 각 패치를 마치 텍스트 문장의 단어(토큰)처럼 취급하는 것입니다. 이렇게 하면 이미지는 일련의 패치 시퀀스(sequence)로 변환되고, 트랜스포머는 이 시퀀스를 입력으로 받아 처리합니다.</p>
<p>ViT는 CNN과 비교하여 다음과 같은 중요한 차이점을 갖습니다.</p>
<ol type="1">
<li><p><strong>지역성(Locality) vs.&nbsp;전역성(Globality):</strong> CNN은 컨볼루션 필터를 사용하여 이미지의 <em>지역적인</em> 특징을 추출하는 데 중점을 둡니다. 반면, ViT는 어텐션 메커니즘(Attention Mechanism)을 통해 각 패치가 이미지 <em>전체</em>의 다른 모든 패치와의 관계를 직접적으로 고려할 수 있습니다. 즉, 이미지 전체의 맥락(context)을 파악하는 데 유리합니다.</p></li>
<li><p><strong>계층적 구조(Hierarchical Structure) vs.&nbsp;평탄한 구조(Flat Structure):</strong> CNN은 여러 계층의 컨볼루션(convolution)과 풀링(pooling) 연산을 통해 점진적으로 특징을 추상화하는 계층적인 구조를 가집니다. 반면, ViT는 이미지를 패치로 분할한 후, 모든 패치를 동일한 차원의 벡터로 변환하여 <em>단일 스케일</em>에서 처리합니다. 이러한 평탄한 구조는 모델의 구현과 최적화를 더 쉽게 만듭니다.</p></li>
<li><p><strong>데이터 의존성:</strong> CNN은 비교적 적은 양의 데이터로도 잘 동작하는 경향이 있습니다. 하지만 ViT는 트랜스포머 기반 모델의 특성상, 충분한 양의 데이터가 있어야 제 성능을 발휘합니다. 대규모 데이터셋으로 사전 학습(pre-training)된 ViT는 이미지 분류, 객체 탐지 등 다양한 비전 태스크에서 CNN을 능가하는 성능을 보여줍니다.</p></li>
</ol>
<p>ViT의 등장은 이미지 처리 분야의 연구 방향을 완전히 바꾸어 놓았습니다. ViT 이후, 이미지 패치 임베딩, 어텐션 메커니즘, 대규모 사전 학습 등의 아이디어를 기반으로 한 다양한 후속 연구들이 쏟아져 나왔습니다.</p>
</section>
<section id="이미지-패치-임베딩의-원리" class="level3">
<h3 class="anchored" data-anchor-id="이미지-패치-임베딩의-원리">10.5.2 이미지 패치 임베딩의 원리</h3>
<p>이미지 패치 임베딩은 ViT의 첫 번째 단계로, 2차원 이미지를 1차원의 시퀀스 형태로 변환하는 과정입니다. PyTorch에서는 <code>torchvision.models.vision_transformer.PatchEmbed</code> 클래스가 이 역할을 담당합니다.</p>
<div id="cell-67" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb85"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.nn <span class="im">as</span> nn</span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.nn.functional <span class="im">as</span> F</span>
<span id="cb85-4"><a href="#cb85-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-5"><a href="#cb85-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> PatchEmbed(nn.Module):</span>
<span id="cb85-6"><a href="#cb85-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb85-7"><a href="#cb85-7" aria-hidden="true" tabindex="-1"></a><span class="co">    Transforms a 2D image into a sequence of patch embeddings.</span></span>
<span id="cb85-8"><a href="#cb85-8" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb85-9"><a href="#cb85-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-10"><a href="#cb85-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(</span>
<span id="cb85-11"><a href="#cb85-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>,</span>
<span id="cb85-12"><a href="#cb85-12" aria-hidden="true" tabindex="-1"></a>        img_size: <span class="bu">int</span> <span class="op">=</span> <span class="dv">224</span>,</span>
<span id="cb85-13"><a href="#cb85-13" aria-hidden="true" tabindex="-1"></a>        patch_size: <span class="bu">int</span> <span class="op">=</span> <span class="dv">16</span>,</span>
<span id="cb85-14"><a href="#cb85-14" aria-hidden="true" tabindex="-1"></a>        in_chans: <span class="bu">int</span> <span class="op">=</span> <span class="dv">3</span>,</span>
<span id="cb85-15"><a href="#cb85-15" aria-hidden="true" tabindex="-1"></a>        embed_dim: <span class="bu">int</span> <span class="op">=</span> <span class="dv">768</span>,</span>
<span id="cb85-16"><a href="#cb85-16" aria-hidden="true" tabindex="-1"></a>    ) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb85-17"><a href="#cb85-17" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb85-18"><a href="#cb85-18" aria-hidden="true" tabindex="-1"></a><span class="co">        Args:</span></span>
<span id="cb85-19"><a href="#cb85-19" aria-hidden="true" tabindex="-1"></a><span class="co">            img_size: The size of the input image (assuming a square image)</span></span>
<span id="cb85-20"><a href="#cb85-20" aria-hidden="true" tabindex="-1"></a><span class="co">            patch_size: The patch size (assuming square patches)</span></span>
<span id="cb85-21"><a href="#cb85-21" aria-hidden="true" tabindex="-1"></a><span class="co">            in_chans: The number of input image channels (e.g., 3 for RGB images)</span></span>
<span id="cb85-22"><a href="#cb85-22" aria-hidden="true" tabindex="-1"></a><span class="co">            embed_dim: The dimension of the patch embedding vector</span></span>
<span id="cb85-23"><a href="#cb85-23" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb85-24"><a href="#cb85-24" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb85-25"><a href="#cb85-25" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.img_size <span class="op">=</span> img_size</span>
<span id="cb85-26"><a href="#cb85-26" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.patch_size <span class="op">=</span> patch_size</span>
<span id="cb85-27"><a href="#cb85-27" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.num_patches <span class="op">=</span> (img_size <span class="op">//</span> patch_size) <span class="op">*</span> (img_size <span class="op">//</span> patch_size)</span>
<span id="cb85-28"><a href="#cb85-28" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.projection <span class="op">=</span> nn.Conv2d(in_chans, embed_dim, kernel_size<span class="op">=</span>patch_size, stride<span class="op">=</span>patch_size)</span>
<span id="cb85-29"><a href="#cb85-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-30"><a href="#cb85-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, x: torch.Tensor) <span class="op">-&gt;</span> torch.Tensor:</span>
<span id="cb85-31"><a href="#cb85-31" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb85-32"><a href="#cb85-32" aria-hidden="true" tabindex="-1"></a><span class="co">        Transforms the input image into a sequence of patch embeddings.</span></span>
<span id="cb85-33"><a href="#cb85-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-34"><a href="#cb85-34" aria-hidden="true" tabindex="-1"></a><span class="co">        Args:</span></span>
<span id="cb85-35"><a href="#cb85-35" aria-hidden="true" tabindex="-1"></a><span class="co">            x: Input image (shape: [batch_size, in_chans, img_size, img_size])</span></span>
<span id="cb85-36"><a href="#cb85-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-37"><a href="#cb85-37" aria-hidden="true" tabindex="-1"></a><span class="co">        Returns:</span></span>
<span id="cb85-38"><a href="#cb85-38" aria-hidden="true" tabindex="-1"></a><span class="co">            Sequence of patch embeddings (shape: [batch_size, num_patches, embed_dim])</span></span>
<span id="cb85-39"><a href="#cb85-39" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb85-40"><a href="#cb85-40" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> <span class="va">self</span>.projection(x)  <span class="co"># [batch_size, embed_dim, num_patches_h, num_patches_w]</span></span>
<span id="cb85-41"><a href="#cb85-41" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> x.flatten(<span class="dv">2</span>)       <span class="co"># [batch_size, embed_dim, num_patches]</span></span>
<span id="cb85-42"><a href="#cb85-42" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> x.transpose(<span class="dv">1</span>, <span class="dv">2</span>)  <span class="co"># [batch_size, num_patches, embed_dim]</span></span>
<span id="cb85-43"><a href="#cb85-43" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<section id="이미지-패치-분할" class="level4">
<h4 class="anchored" data-anchor-id="이미지-패치-분할">10.5.2.1 이미지 패치 분할</h4>
<p><code>PatchEmbed</code> 클래스의 <code>__init__</code> 메서드에서 가장 중요한 부분은 <code>self.projection = nn.Conv2d(in_chans, embed_dim, kernel_size=patch_size, stride=patch_size)</code> 입니다. 이 한 줄의 코드가 이미지 패치 분할과 임베딩을 동시에 수행합니다.</p>
<ul>
<li><strong><code>nn.Conv2d</code></strong>: 2D Convolution 연산을 수행하는 PyTorch 레이어입니다.</li>
<li><strong><code>in_chans</code></strong>: 입력 이미지의 채널 수 (RGB 이미지의 경우 3).</li>
<li><strong><code>embed_dim</code></strong>: 출력 임베딩 벡터의 차원 (ViT-Base 모델의 경우 768).</li>
<li><strong><code>kernel_size=patch_size</code></strong>: Convolution 필터(커널)의 크기를 패치 크기와 동일하게 설정합니다.</li>
<li><strong><code>stride=patch_size</code></strong>: 필터가 이미지 위를 이동하는 간격(stride)을 패치 크기와 동일하게 설정합니다.</li>
</ul>
<p><code>kernel_size</code>와 <code>stride</code>를 <code>patch_size</code>와 동일하게 설정함으로써, Convolution 필터는 이미지를 겹치지 않게, 마치 바둑판처럼 정확하게 패치 크기로 나누는 역할을 합니다. 각 Convolution 필터는 하나의 패치에 대한 정보를 압축하여 하나의 임베딩 벡터를 생성합니다.</p>
</section>
<section id="linear-projection" class="level4">
<h4 class="anchored" data-anchor-id="linear-projection">10.5.2.2 Linear Projection</h4>
<p><code>PatchEmbed</code> 클래스의 <code>forward</code> 메서드에서는 <code>self.projection(x)</code>를 통해 실제로 이미지 패치 임베딩을 수행합니다.</p>
<ol type="1">
<li><p><strong><code>self.projection(x)</code></strong>: 입력 이미지 <code>x</code> (<code>[batch_size, in_chans, img_size, img_size]</code>)에 <code>Conv2d</code> 연산을 적용합니다. 출력은 <code>[batch_size, embed_dim, num_patches_h, num_patches_w]</code> 형태가 됩니다. (<code>num_patches_h</code>와 <code>num_patches_w</code>는 각각 이미지의 높이와 너비를 패치 크기로 나눈 값)</p></li>
<li><p><strong><code>x.flatten(2)</code></strong>: <code>Conv2d</code>의 출력을 <code>[batch_size, embed_dim, num_patches]</code> 형태로 평탄화(flatten)합니다. <code>num_patches</code>는 총 패치의 개수 (<code>num_patches_h * num_patches_w</code>)입니다.</p></li>
<li><p><strong><code>x.transpose(1, 2)</code></strong>: 텐서의 차원을 <code>[batch_size, num_patches, embed_dim]</code> 형태로 바꿉니다. 이는 트랜스포머 인코더의 입력으로 사용하기 위한 형태로, 각 패치 임베딩 벡터가 시퀀스의 한 요소처럼 취급됩니다.</p></li>
</ol>
<p>결과적으로, <code>PatchEmbed</code> 클래스는 이미지를 패치로 나누고, 각 패치를 <code>embed_dim</code> 차원의 벡터로 선형 변환(Linear Projection)하여, 트랜스포머 인코더의 입력으로 사용할 수 있는 시퀀스 형태로 만들어 줍니다.</p>
</section>
</section>
<section id="포지셔널-인코딩-메커니즘" class="level3">
<h3 class="anchored" data-anchor-id="포지셔널-인코딩-메커니즘">10.5.3 포지셔널 인코딩 메커니즘</h3>
<p>ViT는 이미지를 패치로 분할하고, 각 패치를 마치 텍스트의 단어처럼 취급하여 트랜스포머에 입력합니다. 하지만 트랜스포머는 입력 시퀀스의 순서 정보를 자체적으로 인식하지 못합니다. 따라서 각 패치가 이미지의 <em>어느 위치</em>에 해당하는지를 모델에게 알려주어야 합니다. 이 역할을 수행하는 것이 바로 <strong>포지셔널 인코딩(Positional Encoding)</strong>입니다.</p>
<p>PyTorch의 <code>VisionTransformer</code> 클래스에서는 <em>학습 가능한</em> (learnable) 포지셔널 임베딩을 사용합니다. 즉, 각 패치의 위치에 해당하는 고유한 임베딩 벡터를 학습 과정에서 함께 최적화합니다.</p>
<div id="cell-69" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb86"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> VisionTransformer(nn.Module):</span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, ..., num_patches, embed_dim, ...):</span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ...</span></span>
<span id="cb86-5"><a href="#cb86-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.cls_token <span class="op">=</span> nn.Parameter(torch.zeros(<span class="dv">1</span>, <span class="dv">1</span>, embed_dim))  <span class="co"># Class token</span></span>
<span id="cb86-6"><a href="#cb86-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.pos_embed <span class="op">=</span> nn.Parameter(torch.zeros(<span class="dv">1</span>, num_patches <span class="op">+</span> <span class="dv">1</span>, embed_dim)) <span class="co"># Positional embedding</span></span>
<span id="cb86-7"><a href="#cb86-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.pos_drop <span class="op">=</span> nn.Dropout(p<span class="op">=</span>drop_rate)</span>
<span id="cb86-8"><a href="#cb86-8" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ...</span></span>
<span id="cb86-9"><a href="#cb86-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-10"><a href="#cb86-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _pos_embed(<span class="va">self</span>, x):</span>
<span id="cb86-11"><a href="#cb86-11" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> torch.cat((<span class="va">self</span>.cls_token.expand(x.shape[<span class="dv">0</span>], <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>), x), dim<span class="op">=</span><span class="dv">1</span>) <span class="co"># Prepend class token</span></span>
<span id="cb86-12"><a href="#cb86-12" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> x <span class="op">+</span> <span class="va">self</span>.pos_embed  <span class="co"># Add positional embedding</span></span>
<span id="cb86-13"><a href="#cb86-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.pos_drop(x)</span>
<span id="cb86-14"><a href="#cb86-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-15"><a href="#cb86-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, x):</span>
<span id="cb86-16"><a href="#cb86-16" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> <span class="va">self</span>.patch_embed(x)  <span class="co"># Patch embedding</span></span>
<span id="cb86-17"><a href="#cb86-17" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> <span class="va">self</span>._pos_embed(x)  <span class="co"># Add positional embedding</span></span>
<span id="cb86-18"><a href="#cb86-18" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ... (Transformer Encoder etc.) ...</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p><strong>코드 설명</strong></p>
<ol type="1">
<li><strong><code>self.pos_embed</code> (학습 가능한 파라미터):</strong> <code>nn.Parameter</code>로 정의되어 학습 과정에서 업데이트됩니다. <code>(1, num_patches + 1, embed_dim)</code> 크기를 가집니다.
<ul>
<li><code>num_patches + 1</code>: 패치의 개수에 1을 더한 것은, 이미지 패치 외에 특별한 역할을 하는 <strong>클래스 토큰 (class token)</strong> 을 위한 공간을 확보하기 위함입니다.</li>
<li><code>embed_dim</code>: 패치 임베딩의 차원과 동일한 차원을 가집니다.</li>
<li>즉, 각 패치(와 클래스 토큰)는 <code>embed_dim</code> 차원의 고유한 위치 임베딩 벡터를 할당받습니다.</li>
</ul></li>
<li><strong><code>_pos_embed</code> 메서드:</strong>
<ul>
<li><strong>클래스 토큰 추가:</strong> 입력 <code>x</code> (패치 임베딩 시퀀스)의 맨 앞에 <code>self.cls_token</code>을 추가합니다. <code>cls_token</code>은 배치 크기만큼 복제(<code>expand</code>)되어 모든 이미지에 대해 동일하게 적용됩니다.</li>
<li><strong>포지셔널 임베딩 더하기:</strong> 패치 임베딩(및 클래스 토큰 임베딩)에 해당 위치의 <code>self.pos_embed</code> 값을 더합니다. PyTorch의 브로드캐스팅(broadcasting) 규칙에 따라, <code>self.pos_embed</code>의 각 위치 임베딩 벡터는 해당 위치의 모든 패치 임베딩 벡터에 자동으로 더해집니다.</li>
<li><strong>드롭아웃:</strong> 과적합(overfitting)을 방지하기 위해 드롭아웃을 적용합니다.</li>
</ul></li>
<li><strong><code>forward</code> 메서드:</strong> <code>forward</code> 메서드에서는 <code>self.patch_embed(x)</code>를 통해 이미지를 패치 임베딩으로 변환한 후, <code>self._pos_embed(x)</code>를 호출하여 포지셔널 임베딩을 추가합니다.</li>
</ol>
<p><strong>정리</strong></p>
<p>ViT는 각 패치(및 클래스 토큰)에 대해 <em>학습 가능한</em> 포지셔널 임베딩을 사용하고, 이를 패치 임베딩에 더하는 방식으로 위치 정보를 모델에 주입합니다. 포지셔널 임베딩은 모델 학습 과정에서 다른 가중치들과 함께 최적화되므로, 데이터에 가장 적합한 형태로 위치 정보를 표현할 수 있게 됩니다.</p>
</section>
<section id="vit의-구조와-주요-구성-요소" class="level3">
<h3 class="anchored" data-anchor-id="vit의-구조와-주요-구성-요소">10.5.4 ViT의 구조와 주요 구성 요소</h3>
<p>ViT (Vision Transformer)는 이미지를 텍스트처럼 처리하여 분류와 같은 비전 태스크를 수행하는 모델입니다. PyTorch에서는 <code>torchvision.models.VisionTransformer</code> 클래스를 통해 ViT 모델을 사용할 수 있습니다.</p>
<div id="cell-71" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb87"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> VisionTransformer(nn.Module):</span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, ..., embed_dim, depth, num_heads, ...):</span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb87-4"><a href="#cb87-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-5"><a href="#cb87-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.patch_embed <span class="op">=</span> PatchEmbed(...)  <span class="co"># Image patch embedding</span></span>
<span id="cb87-6"><a href="#cb87-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.cls_token <span class="op">=</span> nn.Parameter(...)   <span class="co"># Class token</span></span>
<span id="cb87-7"><a href="#cb87-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.pos_embed <span class="op">=</span> nn.Parameter(...)   <span class="co"># Positional embedding</span></span>
<span id="cb87-8"><a href="#cb87-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.pos_drop <span class="op">=</span> nn.Dropout(...)</span>
<span id="cb87-9"><a href="#cb87-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-10"><a href="#cb87-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.blocks <span class="op">=</span> nn.Sequential(<span class="op">*</span>[</span>
<span id="cb87-11"><a href="#cb87-11" aria-hidden="true" tabindex="-1"></a>            TransformerEncoderLayer(...) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(depth) <span class="co"># Transformer Encoder blocks</span></span>
<span id="cb87-12"><a href="#cb87-12" aria-hidden="true" tabindex="-1"></a>        ])</span>
<span id="cb87-13"><a href="#cb87-13" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.norm <span class="op">=</span> nn.LayerNorm(embed_dim) <span class="co"># Layer Normalization</span></span>
<span id="cb87-14"><a href="#cb87-14" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.head <span class="op">=</span> nn.Linear(embed_dim, num_classes) <span class="co"># Classification Head</span></span>
<span id="cb87-15"><a href="#cb87-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-16"><a href="#cb87-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-17"><a href="#cb87-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward_features(<span class="va">self</span>, x):</span>
<span id="cb87-18"><a href="#cb87-18" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> <span class="va">self</span>.patch_embed(x)       <span class="co"># 1. Patch embedding</span></span>
<span id="cb87-19"><a href="#cb87-19" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> torch.cat((<span class="va">self</span>.cls_token.expand(x.shape[<span class="dv">0</span>], <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>), x), dim<span class="op">=</span><span class="dv">1</span>) <span class="co"># 2. Prepend class token</span></span>
<span id="cb87-20"><a href="#cb87-20" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> x <span class="op">+</span> <span class="va">self</span>.pos_embed       <span class="co"># 3. Add positional embedding</span></span>
<span id="cb87-21"><a href="#cb87-21" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> <span class="va">self</span>.pos_drop(x)</span>
<span id="cb87-22"><a href="#cb87-22" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> <span class="va">self</span>.blocks(x)            <span class="co"># 4. Transformer Encoder</span></span>
<span id="cb87-23"><a href="#cb87-23" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> <span class="va">self</span>.norm(x)              <span class="co"># 5. LayerNorm</span></span>
<span id="cb87-24"><a href="#cb87-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> x[:, <span class="dv">0</span>]                <span class="co"># 6. Return class token</span></span>
<span id="cb87-25"><a href="#cb87-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-26"><a href="#cb87-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-27"><a href="#cb87-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, x):</span>
<span id="cb87-28"><a href="#cb87-28" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> <span class="va">self</span>.forward_features(x)   <span class="co"># Feature extraction</span></span>
<span id="cb87-29"><a href="#cb87-29" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> <span class="va">self</span>.head(x)               <span class="co"># Classification</span></span>
<span id="cb87-30"><a href="#cb87-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p><strong>ViT의 핵심 구성 요소:</strong></p>
<ol type="1">
<li><strong><code>PatchEmbed</code> (패치 임베딩):</strong> 이미지를 여러 개의 작은 패치로 나누고, 각 패치를 고정된 차원의 벡터(임베딩)로 변환합니다. (10.5.2절 참조)</li>
<li><strong><code>cls_token</code> (클래스 토큰):</strong> 학습 가능한 파라미터로, 패치 임베딩 시퀀스의 맨 앞에 추가되는 특별한 토큰입니다. 트랜스포머 인코더를 통과한 후, 이 클래스 토큰은 이미지 전체를 대표하는 정보(feature)를 담게 되며, 최종 분류(classification)에 사용됩니다.</li>
<li><strong><code>pos_embed</code> (포지셔널 임베딩):</strong> 각 패치(와 클래스 토큰)의 위치 정보를 나타내는 학습 가능한 파라미터입니다. 트랜스포머는 입력 시퀀스의 순서를 자체적으로 알 수 없기 때문에, 포지셔널 임베딩을 통해 위치 정보를 명시적으로 제공해야 합니다. (10.5.3절 참조)</li>
<li><strong><code>blocks</code> (트랜스포머 인코더):</strong> 여러 개의 <code>TransformerEncoderLayer</code>가 쌓여서 구성됩니다.
<ul>
<li><strong><code>TransformerEncoderLayer</code>:</strong> ViT의 핵심 블록으로, 멀티헤드 셀프 어텐션(Multi-Head Self-Attention)과 Feed-Forward Network (FFN)으로 구성됩니다.
<ul>
<li><strong>Multi-Head Self-Attention:</strong> 각 패치가 다른 모든 패치(자기 자신 포함)와의 관계를 고려하여, 이미지 전체의 맥락 정보를 파악합니다.</li>
<li><strong>FFN:</strong> 각 패치 임베딩을 개별적으로 처리하여 비선형성을 추가하고, 더 복잡한 특징을 학습할 수 있도록 합니다.</li>
<li><strong>(Pre-LN, Residual Connection, Dropout 등):</strong> 9장, 10장 초반에서 살펴본 내용처럼, 안정적인 학습과 성능향상을 위한 여러 기법이 적용됩니다.</li>
</ul></li>
</ul></li>
<li><strong><code>norm</code> (Layer Normalization) :</strong> Transformer Encoder의 출력에 Layer Normalization을 적용</li>
<li><strong><code>head</code> (Classification Head):</strong> 트랜스포머 인코더를 통과한 클래스 토큰을 입력으로 받아, 최종적으로 이미지의 클래스를 예측하는 fully-connected layer입니다.</li>
</ol>
<p><strong><code>forward</code> 메서드 (전체적인 처리 흐름):</strong></p>
<ol type="1">
<li><code>forward_features</code> 메서드:
<ul>
<li><code>self.patch_embed(x)</code>: 입력 이미지를 패치 임베딩 시퀀스로 변환합니다.</li>
<li>클래스 토큰(<code>self.cls_token</code>)을 패치 임베딩 시퀀스 맨 앞에 추가합니다.</li>
<li>포지셔널 임베딩(<code>self.pos_embed</code>)을 더합니다.</li>
<li>트랜스포머 인코더(<code>self.blocks</code>)를 통과시킵니다.</li>
<li>Layer Normalization(<code>self.norm</code>)을 적용합니다.</li>
<li>클래스 토큰에 해당하는 부분(<code>x[:, 0]</code>)만 반환합니다.</li>
</ul></li>
<li><code>self.head(x)</code>: <code>forward_features</code>에서 반환된 클래스 토큰을 classification head에 통과시켜 최종 예측(분류) 결과를 얻습니다.</li>
</ol>
<p><strong>요약:</strong></p>
<p>ViT는 이미지를 패치로 나누고, 각 패치를 트랜스포머 인코더에 입력하여 이미지 전체의 특징을 추출합니다. 이때, 클래스 토큰과 포지셔널 임베딩을 사용하여 이미지의 전역적인 정보와 패치의 위치 정보를 함께 고려합니다. 최종적으로 클래스 토큰을 사용하여 이미지를 분류합니다.</p>
</section>
<section id="vit-훈련-예제" class="level3">
<h3 class="anchored" data-anchor-id="vit-훈련-예제">10.5.5 ViT 훈련 예제</h3>
<p>ViT를 이용하여 CIFAR-10 데이터셋을 훈련하는 간단한 예제를 살펴보겠습니다. 아래 코드는 PyTorch를 사용하여 ViT 모델을 훈련하고, 에폭별 손실(loss)과 정확도(accuracy)를 출력합니다.</p>
<div id="cell-73" class="cell" data-execution_count="1">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb88"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.nn <span class="im">as</span> nn</span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.optim <span class="im">as</span> optim</span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> torchvision <span class="im">import</span> datasets, transforms</span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> torchvision.models <span class="im">import</span> vit_b_16  <span class="co"># Using vit_b_16 model as an example</span></span>
<span id="cb88-6"><a href="#cb88-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> torch.utils.data <span class="im">import</span> DataLoader</span>
<span id="cb88-7"><a href="#cb88-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-8"><a href="#cb88-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Hyperparameter setup for a simple training run</span></span>
<span id="cb88-9"><a href="#cb88-9" aria-hidden="true" tabindex="-1"></a>num_epochs <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb88-10"><a href="#cb88-10" aria-hidden="true" tabindex="-1"></a>batch_size <span class="op">=</span> <span class="dv">32</span></span>
<span id="cb88-11"><a href="#cb88-11" aria-hidden="true" tabindex="-1"></a>learning_rate <span class="op">=</span> <span class="fl">1e-4</span></span>
<span id="cb88-12"><a href="#cb88-12" aria-hidden="true" tabindex="-1"></a>image_size <span class="op">=</span> <span class="dv">224</span>  <span class="co"># ViT input image size</span></span>
<span id="cb88-13"><a href="#cb88-13" aria-hidden="true" tabindex="-1"></a>num_classes <span class="op">=</span> <span class="dv">10</span>   <span class="co"># Number of classes in the CIFAR-10 dataset</span></span>
<span id="cb88-14"><a href="#cb88-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-15"><a href="#cb88-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Use GPU if available</span></span>
<span id="cb88-16"><a href="#cb88-16" aria-hidden="true" tabindex="-1"></a>device <span class="op">=</span> torch.device(<span class="st">"cuda"</span> <span class="cf">if</span> torch.cuda.is_available() <span class="cf">else</span> <span class="st">"cpu"</span>)</span>
<span id="cb88-17"><a href="#cb88-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-18"><a href="#cb88-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Data loading and preprocessing (using CIFAR-10 dataset)</span></span>
<span id="cb88-19"><a href="#cb88-19" aria-hidden="true" tabindex="-1"></a>transform <span class="op">=</span> transforms.Compose([</span>
<span id="cb88-20"><a href="#cb88-20" aria-hidden="true" tabindex="-1"></a>    transforms.Resize((image_size, image_size)),</span>
<span id="cb88-21"><a href="#cb88-21" aria-hidden="true" tabindex="-1"></a>    transforms.ToTensor(),</span>
<span id="cb88-22"><a href="#cb88-22" aria-hidden="true" tabindex="-1"></a>    transforms.Normalize((<span class="fl">0.5</span>, <span class="fl">0.5</span>, <span class="fl">0.5</span>), (<span class="fl">0.5</span>, <span class="fl">0.5</span>, <span class="fl">0.5</span>)), <span class="co"># Normalize with CIFAR-10 statistics</span></span>
<span id="cb88-23"><a href="#cb88-23" aria-hidden="true" tabindex="-1"></a>])</span>
<span id="cb88-24"><a href="#cb88-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-25"><a href="#cb88-25" aria-hidden="true" tabindex="-1"></a>train_dataset <span class="op">=</span> datasets.CIFAR10(root<span class="op">=</span><span class="st">'./data'</span>, train<span class="op">=</span><span class="va">True</span>, download<span class="op">=</span><span class="va">True</span>, transform<span class="op">=</span>transform)</span>
<span id="cb88-26"><a href="#cb88-26" aria-hidden="true" tabindex="-1"></a>train_loader <span class="op">=</span> DataLoader(train_dataset, batch_size<span class="op">=</span>batch_size, shuffle<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb88-27"><a href="#cb88-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-28"><a href="#cb88-28" aria-hidden="true" tabindex="-1"></a><span class="co"># Create ViT model (not using pretrained weights)</span></span>
<span id="cb88-29"><a href="#cb88-29" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> vit_b_16(pretrained<span class="op">=</span><span class="va">False</span>, num_classes<span class="op">=</span>num_classes).to(device)</span>
<span id="cb88-30"><a href="#cb88-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-31"><a href="#cb88-31" aria-hidden="true" tabindex="-1"></a><span class="co"># Define loss function and optimizer</span></span>
<span id="cb88-32"><a href="#cb88-32" aria-hidden="true" tabindex="-1"></a>criterion <span class="op">=</span> nn.CrossEntropyLoss()</span>
<span id="cb88-33"><a href="#cb88-33" aria-hidden="true" tabindex="-1"></a>optimizer <span class="op">=</span> optim.AdamW(model.parameters(), lr<span class="op">=</span>learning_rate)</span>
<span id="cb88-34"><a href="#cb88-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-35"><a href="#cb88-35" aria-hidden="true" tabindex="-1"></a><span class="co"># Training loop</span></span>
<span id="cb88-36"><a href="#cb88-36" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> epoch <span class="kw">in</span> <span class="bu">range</span>(num_epochs):</span>
<span id="cb88-37"><a href="#cb88-37" aria-hidden="true" tabindex="-1"></a>    model.train()  <span class="co"># Set the model to training mode</span></span>
<span id="cb88-38"><a href="#cb88-38" aria-hidden="true" tabindex="-1"></a>    running_loss <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb88-39"><a href="#cb88-39" aria-hidden="true" tabindex="-1"></a>    correct_predictions <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb88-40"><a href="#cb88-40" aria-hidden="true" tabindex="-1"></a>    total_samples <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb88-41"><a href="#cb88-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-42"><a href="#cb88-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, (images, labels) <span class="kw">in</span> <span class="bu">enumerate</span>(train_loader):</span>
<span id="cb88-43"><a href="#cb88-43" aria-hidden="true" tabindex="-1"></a>        images <span class="op">=</span> images.to(device)</span>
<span id="cb88-44"><a href="#cb88-44" aria-hidden="true" tabindex="-1"></a>        labels <span class="op">=</span> labels.to(device)</span>
<span id="cb88-45"><a href="#cb88-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-46"><a href="#cb88-46" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Forward and backward passes</span></span>
<span id="cb88-47"><a href="#cb88-47" aria-hidden="true" tabindex="-1"></a>        outputs <span class="op">=</span> model(images)</span>
<span id="cb88-48"><a href="#cb88-48" aria-hidden="true" tabindex="-1"></a>        loss <span class="op">=</span> criterion(outputs, labels)</span>
<span id="cb88-49"><a href="#cb88-49" aria-hidden="true" tabindex="-1"></a>        optimizer.zero_grad()</span>
<span id="cb88-50"><a href="#cb88-50" aria-hidden="true" tabindex="-1"></a>        loss.backward()</span>
<span id="cb88-51"><a href="#cb88-51" aria-hidden="true" tabindex="-1"></a>        optimizer.step()</span>
<span id="cb88-52"><a href="#cb88-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-53"><a href="#cb88-53" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Calculate statistics</span></span>
<span id="cb88-54"><a href="#cb88-54" aria-hidden="true" tabindex="-1"></a>        running_loss <span class="op">+=</span> loss.item()</span>
<span id="cb88-55"><a href="#cb88-55" aria-hidden="true" tabindex="-1"></a>        _, predicted <span class="op">=</span> torch.<span class="bu">max</span>(outputs, <span class="dv">1</span>)  <span class="co"># Select the class with the highest probability</span></span>
<span id="cb88-56"><a href="#cb88-56" aria-hidden="true" tabindex="-1"></a>        total_samples <span class="op">+=</span> labels.size(<span class="dv">0</span>)</span>
<span id="cb88-57"><a href="#cb88-57" aria-hidden="true" tabindex="-1"></a>        correct_predictions <span class="op">+=</span> (predicted <span class="op">==</span> labels).<span class="bu">sum</span>().item()</span>
<span id="cb88-58"><a href="#cb88-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-59"><a href="#cb88-59" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Print every 100 batches.</span></span>
<span id="cb88-60"><a href="#cb88-60" aria-hidden="true" tabindex="-1"></a>        <span class="co"># if (i + 1) % 100 == 0:</span></span>
<span id="cb88-61"><a href="#cb88-61" aria-hidden="true" tabindex="-1"></a>        <span class="co">#     print(f'Epoch [{epoch+1}/{num_epochs}], Step [{i+1}/{len(train_loader)}], Loss: {loss.item():.4f}')</span></span>
<span id="cb88-62"><a href="#cb88-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-63"><a href="#cb88-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-64"><a href="#cb88-64" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Print epoch statistics</span></span>
<span id="cb88-65"><a href="#cb88-65" aria-hidden="true" tabindex="-1"></a>    epoch_loss <span class="op">=</span> running_loss <span class="op">/</span> <span class="bu">len</span>(train_loader)</span>
<span id="cb88-66"><a href="#cb88-66" aria-hidden="true" tabindex="-1"></a>    epoch_accuracy <span class="op">=</span> correct_predictions <span class="op">/</span> total_samples <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb88-67"><a href="#cb88-67" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f'Epoch [</span><span class="sc">{</span>epoch<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">/</span><span class="sc">{</span>num_epochs<span class="sc">}</span><span class="ss">], Loss: </span><span class="sc">{</span>epoch_loss<span class="sc">:.4f}</span><span class="ss">, Accuracy: </span><span class="sc">{</span>epoch_accuracy<span class="sc">:.2f}</span><span class="ss">%'</span>)</span>
<span id="cb88-68"><a href="#cb88-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-69"><a href="#cb88-69" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Training finished!'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>100%|██████████| 170M/170M [00:21&lt;00:00, 8.09MB/s] 
/home/sean/anaconda3/envs/DL/lib/python3.10/site-packages/torchvision/models/_utils.py:208: UserWarning: The parameter 'pretrained' is deprecated since 0.13 and may be removed in the future, please use 'weights' instead.
  warnings.warn(
/home/sean/anaconda3/envs/DL/lib/python3.10/site-packages/torchvision/models/_utils.py:223: UserWarning: Arguments other than a weight enum or `None` for 'weights' are deprecated since 0.13 and may be removed in the future. The current behavior is equivalent to passing `weights=None`.
  warnings.warn(msg)</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Epoch [1/5], Step [100/1563], Loss: 2.1349
Epoch [1/5], Step [200/1563], Loss: 1.8978
Epoch [1/5], Step [300/1563], Loss: 1.9483
Epoch [1/5], Step [400/1563], Loss: 2.0783
Epoch [1/5], Step [500/1563], Loss: 1.7614
Epoch [1/5], Step [600/1563], Loss: 1.8051
Epoch [1/5], Step [700/1563], Loss: 1.7448
Epoch [1/5], Step [800/1563], Loss: 1.8347
Epoch [1/5], Step [900/1563], Loss: 1.8127
Epoch [1/5], Step [1000/1563], Loss: 1.7755
Epoch [1/5], Step [1100/1563], Loss: 1.6506
Epoch [1/5], Step [1200/1563], Loss: 1.7523
Epoch [1/5], Step [1300/1563], Loss: 1.5987
Epoch [1/5], Step [1400/1563], Loss: 1.6078
Epoch [1/5], Step [1500/1563], Loss: 1.7110
Epoch [1/5], Loss: 1.8429, Accuracy: 29.66%
Epoch [2/5], Step [100/1563], Loss: 1.4902
Epoch [2/5], Step [200/1563], Loss: 1.5161
Epoch [2/5], Step [300/1563], Loss: 1.4563
Epoch [2/5], Step [400/1563], Loss: 1.5858
Epoch [2/5], Step [500/1563], Loss: 1.6702
Epoch [2/5], Step [600/1563], Loss: 1.5833
Epoch [2/5], Step [700/1563], Loss: 1.4790
Epoch [2/5], Step [800/1563], Loss: 1.6507
Epoch [2/5], Step [900/1563], Loss: 1.6017
Epoch [2/5], Step [1000/1563], Loss: 1.5102
Epoch [2/5], Step [1100/1563], Loss: 1.2946
Epoch [2/5], Step [1200/1563], Loss: 1.3225
Epoch [2/5], Step [1300/1563], Loss: 1.9922
Epoch [2/5], Step [1400/1563], Loss: 1.3685
Epoch [2/5], Step [1500/1563], Loss: 1.4852
Epoch [2/5], Loss: 1.5410, Accuracy: 42.69%
Epoch [3/5], Step [100/1563], Loss: 1.2692
Epoch [3/5], Step [200/1563], Loss: 1.1648
Epoch [3/5], Step [300/1563], Loss: 1.2412
Epoch [3/5], Step [400/1563], Loss: 1.6217
Epoch [3/5], Step [500/1563], Loss: 1.3776
Epoch [3/5], Step [600/1563], Loss: 1.2591
Epoch [3/5], Step [700/1563], Loss: 1.4333
Epoch [3/5], Step [800/1563], Loss: 1.3301
Epoch [3/5], Step [900/1563], Loss: 1.3536
Epoch [3/5], Step [1000/1563], Loss: 1.4488
Epoch [3/5], Step [1100/1563], Loss: 1.3179
Epoch [3/5], Step [1200/1563], Loss: 1.0684
Epoch [3/5], Step [1300/1563], Loss: 1.6526
Epoch [3/5], Step [1400/1563], Loss: 1.1815
Epoch [3/5], Step [1500/1563], Loss: 1.3683
Epoch [3/5], Loss: 1.3836, Accuracy: 49.23%
Epoch [4/5], Step [100/1563], Loss: 1.2601
Epoch [4/5], Step [200/1563], Loss: 1.3277
Epoch [4/5], Step [300/1563], Loss: 1.1337
Epoch [4/5], Step [400/1563], Loss: 1.2273
Epoch [4/5], Step [500/1563], Loss: 1.7351
Epoch [4/5], Step [600/1563], Loss: 1.3826
Epoch [4/5], Step [700/1563], Loss: 1.2639
Epoch [4/5], Step [800/1563], Loss: 1.5757
Epoch [4/5], Step [900/1563], Loss: 1.0702
Epoch [4/5], Step [1000/1563], Loss: 1.3986
Epoch [4/5], Step [1100/1563], Loss: 1.1105
Epoch [4/5], Step [1200/1563], Loss: 1.2621
Epoch [4/5], Step [1300/1563], Loss: 1.4261
Epoch [4/5], Step [1400/1563], Loss: 1.3028
Epoch [4/5], Step [1500/1563], Loss: 1.9051
Epoch [4/5], Loss: 1.2850, Accuracy: 52.98%
Epoch [5/5], Step [100/1563], Loss: 0.9517
Epoch [5/5], Step [200/1563], Loss: 0.9844
Epoch [5/5], Step [300/1563], Loss: 1.2391
Epoch [5/5], Step [400/1563], Loss: 1.3588
Epoch [5/5], Step [500/1563], Loss: 0.9441
Epoch [5/5], Step [600/1563], Loss: 1.1711
Epoch [5/5], Step [700/1563], Loss: 1.1687
Epoch [5/5], Step [800/1563], Loss: 1.0097
Epoch [5/5], Step [900/1563], Loss: 0.9899
Epoch [5/5], Step [1000/1563], Loss: 1.3289
Epoch [5/5], Step [1100/1563], Loss: 1.5510
Epoch [5/5], Step [1200/1563], Loss: 0.9139
Epoch [5/5], Step [1300/1563], Loss: 0.9221
Epoch [5/5], Step [1400/1563], Loss: 1.3378
Epoch [5/5], Step [1500/1563], Loss: 1.1785
Epoch [5/5], Loss: 1.2116, Accuracy: 55.78%
Training finished!</code></pre>
</div>
</div>
<p>이 코드는 ViT 모델의 동작 방식을 보여주기 위한 간단한 예제 입니다. 실제 ViT는 ImageNet과 같은 대규모 데이터셋 에서 사전 학습(pre-training)된 후, 특정 태스크(예: CIFAR-10 분류)에 맞게 미세 조정(fine-tuning)하는 방식으로 사용될 때 훨씬 더 좋은 성능을 보입니다. 여기서는 단순하게 훈련이 가능한 여부만을 확인합니다.</p>
<p><strong>ViT의 의의 및 영향</strong></p>
<p>ViT는 이미지 분류 태스크에서 CNN을 능가하는 성능을 보여주면서, 컴퓨터 비전 분야에 큰 반향을 일으켰습니다. 특히, JFT-300M과 같이 3억 장 이상의 <strong>대규모 이미지 데이터셋</strong>으로 사전 학습했을 때 그 진가를 발휘했습니다. 이는 다음의 두 가지 중요한 시사점을 던져주었습니다.</p>
<ol type="1">
<li><p><strong>Scalability (확장성):</strong> ViT는 데이터셋의 크기가 커질수록 성능이 <em>지속적으로 향상</em>되는 뛰어난 확장성을 보여주었습니다. 이는 CNN 기반 모델들이 일정 규모 이상의 데이터셋에서는 성능 향상이 정체되거나 오히려 저하되는 현상과는 대조적입니다. ViT의 이러한 특징은, 앞으로 더 많은 데이터를 활용하여 더욱 강력한 비전 모델을 구축할 수 있는 가능성을 열었습니다.</p></li>
<li><p><strong>Transformer의 범용성:</strong> ViT는 자연어 처리(NLP) 분야에서 널리 사용되던 트랜스포머 아키텍처가 이미지 처리 분야에서도 효과적일 수 있음을 입증했습니다. 이는 <em>하나의 아키텍처</em>로 다양한 모달리티(modality, 텍스트, 이미지, 음성 등)를 처리할 수 있는 <em>멀티모달(multimodal) 모델</em> 연구의 기폭제가 되었습니다.</p></li>
</ol>
<p>ViT의 성공은 이후 CLIP (Contrastive Language-Image Pre-training)과 같은 멀티모달 모델 개발의 중요한 기반이 되었습니다. CLIP은 ViT의 이미지 인코더와 트랜스포머 기반의 텍스트 인코더를 결합하여, 이미지와 텍스트를 <em>하나의 통합된 공간</em>에 표현하는 방식을 학습합니다. 이를 통해, 이미지에 대한 텍스트 설명을 생성하거나, 텍스트 설명을 기반으로 이미지를 검색하는 등 다양한 응용이 가능해졌습니다.</p>
</section>
<section id="vit-22b-극한의-스케일" class="level3">
<h3 class="anchored" data-anchor-id="vit-22b-극한의-스케일">10.5.6 ViT-22B: 극한의 스케일</h3>
<p><strong>Google Research</strong> 팀이 제안하고 훈련시킨 ViT-22B는 이미지 분류에서 CNN을 능가하는 성능을 보이면서, 컴퓨터 비전 분야에 큰 반향을 일으켰습니다. ViT-22B는 모델과 데이터의 크기를 확장하는 것이 성능 향상의 핵심 요인 중 하나임을 입증했습니다. 220억 개의 파라미터라는 압도적인 크기와, 수십억 장의 이미지로 구성된 초대규모 데이터셋으로 학습된 ViT-22B는 이전에는 상상하기 어려웠던 수준의 성능을 달성하며 비전 AI의 새로운 지평을 열었습니다.</p>
<p><strong>탄생 배경: 스케일링 법칙과 거대 언어 모델의 성공</strong></p>
<p>ViT-22B의 등장은 자연어 처리(NLP) 분야에서 거대 언어 모델(Large Language Model, LLM)이 보여준 놀라운 성공과 깊은 관련이 있습니다. GPT-3와 같은 LLM은 모델의 크기(파라미터 수)와 데이터의 양을 늘릴수록 성능이 꾸준히 향상되는 <em>스케일링 법칙(scaling law)</em>을 따르는 것으로 나타났습니다. 이러한 경향은 “더 큰 것이 더 좋다(bigger is better)”라는 믿음을 확산시켰고, 비전 분야에서도 유사한 시도가 이루어지게 되었습니다.</p>
<p>ViT는 트랜스포머 아키텍처를 기반으로 하기 때문에, LLM에서 검증된 스케일링 전략을 적용하기에 용이했습니다. 이미지 패치를 텍스트 토큰처럼 처리하는 ViT의 특성상, 모델의 구조를 크게 변경하지 않고도 파라미터 수를 늘리고 더 많은 데이터를 사용하여 학습할 수 있었기 때문입니다.</p>
<p><strong>ViT-22B의 구조 및 특징</strong></p>
<p>ViT-22B는 기본적으로 ViT의 아키텍처를 따르지만, <em>규모</em> 면에서 차원이 다릅니다.</p>
<ul>
<li><p><strong>거대한 모델 크기:</strong> 220억 개의 파라미터를 가진 ViT-22B는, ViT-Base (8600만 개), ViT-Large (3억 700만 개), ViT-Huge (6억 3200만 개)와 비교했을 때 압도적으로 큰 규모를 자랑합니다. 이는 모델이 훨씬 더 복잡하고 미묘한 이미지 특징을 포착하고, 더 많은 지식을 내재화할 수 있음을 의미합니다.</p></li>
<li><p><strong>초대규모 데이터셋:</strong> ViT-22B는 수십억 장 이상의 이미지로 구성된 <em>비공개</em> 데이터셋(JFT-4B 등)으로 학습되었습니다. 이러한 대규모 데이터는 모델이 일반화 성능(generalization performance)을 극대화하고, 다양한 이미지 분포를 포괄적으로 학습하는 데 필수적입니다.</p></li>
<li><p><strong>향상된 성능:</strong> ViT-22B는 이미지 분류, 객체 탐지, 이미지 분할 등 다양한 비전 벤치마크에서 기존의 어떤 모델보다 뛰어난 성능(SOTA, State-Of-The-Art)을 기록했습니다. 이는 모델의 크기와 데이터의 양이 성능에 미치는 긍정적인 영향을 명확하게 보여줍니다.</p></li>
</ul>
<p><strong>ViT-22B 훈련의 어려움과 시사점</strong></p>
<p>ViT-22B와 같은 초대규모 모델을 훈련하는 것은 일반적인 연구 환경에서는 거의 불가능합니다. 수백, 수천 개의 GPU 또는 TPU와 같은 고가의 특수 하드웨어가 필요하며, 훈련 시간도 몇 주에서 몇 달까지 소요될 수 있습니다. 또한, 엄청난 양의 데이터를 저장하고 처리하는 인프라 구축도 큰 과제입니다.</p>
<p>ViT-22B의 등장은 ViT 아키텍처의 확장 가능성(scalability)을 입증했지만, 동시에 <em>효율성(efficiency)</em>에 대한 고민을 던져주었습니다. 모델의 크기가 커질수록 성능은 향상되지만, 훈련 및 추론(inference)에 필요한 컴퓨팅 자원과 에너지 소비량도 기하급수적으로 증가하기 때문입니다. 따라서, 앞으로의 연구는 모델의 성능을 유지하면서도 효율성을 높이는 방향으로 진행될 것으로 예상됩니다.</p>
</section>
<section id="mae-v3-자기-지도-학습" class="level3">
<h3 class="anchored" data-anchor-id="mae-v3-자기-지도-학습">10.5.7 MAE v3: 자기 지도 학습</h3>
<p><strong>Meta AI (Facebook AI Research, FAIR)</strong> 팀이 제안한 MAE(Masked Autoencoder)는 레이블이 없는 대규모 이미지 데이터셋을 활용하여 강력한 이미지 표현(representation)을 학습하는 <em>자기 지도 학습(self-supervised learning)</em> 방법입니다. ViT를 기반으로 하는 MAE는 이미지의 상당 부분을 무작위로 가리고(masking), 가려진 부분을 복원하도록 모델을 훈련시킵니다. MAE v3는 이러한 MAE의 최신 버전으로, 여러 가지 개선 사항을 통해 성능과 효율성을 더욱 향상시켰습니다.</p>
<p><strong>MAE의 작동 원리</strong></p>
<p>MAE의 핵심 아이디어는 사람이 “빈칸 채우기” 문제를 풀듯이, 이미지의 <em>일부 정보</em>만 보고도 전체 이미지를 <em>이해</em>하고 <em>복원</em>하도록 모델을 학습시키는 것입니다.</p>
<ol type="1">
<li><p><strong>입력 이미지의 무작위 마스킹:</strong> 입력 이미지의 상당 부분(예: 75%)을 무작위로 가립니다. 이때, 이미지 패치 단위로 마스킹을 수행합니다.</p></li>
<li><p><strong>인코딩 (Encoding):</strong> 가려지지 않은, 즉 <em>보이는</em> 패치들만 ViT 인코더에 입력하여 특징 벡터를 추출합니다.</p></li>
<li><p><strong>디코딩 (Decoding):</strong> 인코더의 출력(보이는 패치들의 특징)과 <em>마스킹된 패치</em>에 대한 정보를 함께 사용하여 원래 이미지를 복원합니다. 이때, 디코더는 가벼운(lightweight) Transformer 블록으로 구성하여 계산 효율성을 높입니다.</p></li>
<li><p><strong>복원 손실 (Reconstruction Loss):</strong> 복원된 이미지와 원본 이미지 간의 픽셀 수준 차이(예: Mean Squared Error, MSE)를 계산하고, 이 차이를 최소화하는 방향으로 모델(인코더와 디코더)을 학습합니다.</p></li>
</ol>
<p><strong>MAE v3의 구조적 개선</strong></p>
<p>MAE v3는 다음과 같은 주요 개선 사항을 통해 이전 버전보다 더 나은 성능과 효율성을 달성했습니다.</p>
<ol type="1">
<li><p><strong>향상된 마스킹 전략:</strong> 초기 MAE에서는 단순히 무작위로 패치를 마스킹했지만, MAE v3에서는 더 정교한 마스킹 전략을 사용합니다. 예를 들어, 이미지의 <em>의미 있는 영역</em>(객체의 경계 등)을 더 잘 보존하도록 마스킹하거나, <em>다양한 크기</em>의 패치를 마스킹하는 등의 방법을 적용할 수 있습니다.</p></li>
<li><p><strong>최적화된 인코더-디코더 구조</strong></p>
<ul>
<li>인코더: ViT-Large, ViT-Huge와 같이 더 큰 ViT 모델을 사용하여, 보이는 패치로부터 더 풍부한 특징을 추출합니다.</li>
<li>디코더: 얕고 가벼운 Transformer 블록을 사용하여, 계산 효율성을 유지하면서도 복원 성능을 향상시킵니다.</li>
</ul></li>
<li><p><strong>스케일 확장</strong>: ViT-L/16, ViT-H/16에서 ViT-g/14(파라미터 25억개)까지 모델 스케일을 확장하였습니다.</p></li>
</ol>
<p><strong>MAE의 장점과 의의</strong></p>
<p>MAE는 다음과 같은 장점을 통해 자기 지도 학습 분야에서 주목받고 있습니다.</p>
<ol type="1">
<li><p><strong>레이블이 필요 없는 학습:</strong> MAE는 레이블이 없는 <em>대규모 이미지 데이터셋</em>을 활용하여 사전 학습(pre-training)을 수행할 수 있습니다. 이는 레이블을 수작업으로 생성하는 데 드는 비용과 시간을 절약하고, 더 많은 데이터를 활용할 수 있게 해줍니다.</p></li>
<li><p><strong>강력한 표현 학습:</strong> MAE는 이미지의 상당 부분이 가려진 상태에서도 이미지를 복원하는 과정을 통해, 이미지의 <em>구조</em>, <em>의미</em>, <em>맥락</em> 등을 파악하는 능력을 키웁니다. 이러한 능력은 이미지 분류, 객체 탐지, 분할 등 다양한 다운스트림 태스크(downstream task)에서 좋은 성능을 내는 데 도움이 됩니다.</p></li>
<li><p><strong>전이 학습(Transfer Learning) 용이성:</strong> MAE로 사전 학습된 모델은 다양한 태스크에 <em>미세 조정(fine-tuning)</em>하여 사용할 수 있습니다. 이는 레이블이 부족한 태스크에서도 좋은 성능을 얻을 수 있게 해줍니다.</p></li>
</ol>
<p><strong>결론</strong></p>
<p>MAE는 “빈칸 채우기”라는 직관적인 아이디어를 통해, 레이블 없이도 강력한 이미지 표현을 학습할 수 있는 효과적인 방법을 제시했습니다. MAE v3는 이러한 MAE의 장점을 더욱 발전시켜, 더 높은 성능과 효율성을 달성하며 자기 지도 학습 연구의 발전을 이끌고 있습니다.</p>
</section>
</section>
<section id="clip-멀티모달-학습의-이정표" class="level2">
<h2 class="anchored" data-anchor-id="clip-멀티모달-학습의-이정표">10.6 CLIP: 멀티모달 학습의 이정표</h2>
<p>2021년, OpenAI는 “Learning Transferable Visual Models From Natural Language Supervision” 논문을 통해 <strong>CLIP (Contrastive Language-Image Pre-training)</strong> 모델을 발표했습니다. CLIP은 이미지와 텍스트, 두 가지 다른 모달리티(modality)를 <em>하나의 공유된 공간(shared space)</em>에 표현하는 방법을 학습함으로써, 멀티모달 학습 분야에 혁신적인 발전을 가져왔습니다.</p>
<section id="clip의-기본-구조-듀얼-인코더-dual-encoder" class="level3">
<h3 class="anchored" data-anchor-id="clip의-기본-구조-듀얼-인코더-dual-encoder">10.6.1 CLIP의 기본 구조: 듀얼 인코더 (Dual Encoder)</h3>
<p>CLIP의 핵심은 <strong>이미지 인코더(Image Encoder)</strong>와 <strong>텍스트 인코더(Text Encoder)</strong>, 두 개의 독립적인 인코더로 구성된 <em>듀얼 인코더</em> 구조입니다.</p>
<ul>
<li><strong>이미지 인코더:</strong> 입력 이미지를 고정된 차원의 벡터(이미지 임베딩)로 변환합니다.</li>
<li><strong>텍스트 인코더:</strong> 입력 텍스트(이미지에 대한 설명)를 이미지 인코더와 <em>동일한 차원</em>의 벡터(텍스트 임베딩)로 변환합니다.</li>
</ul>
<p>이 두 인코더는 <em>대조 학습(contrastive learning)</em>을 통해 훈련됩니다.</p>
<p><strong>CLIP 훈련의 핵심: 대조 학습 (Contrastive Learning)</strong></p>
<p>CLIP 훈련의 핵심은 <em>대규모 이미지-텍스트 쌍 데이터셋</em>을 사용하는 <em>대조 학습</em>입니다.</p>
<ol type="1">
<li><strong>데이터:</strong> 인터넷에서 수집된 수억 개의 (이미지, 텍스트) 쌍으로 구성된 데이터셋을 사용합니다. 각 쌍에서 텍스트는 해당 이미지에 대한 설명입니다.</li>
<li><strong>목표:</strong> <em>같은 쌍</em>에 속하는 이미지와 텍스트의 임베딩은 서로 <em>가깝게</em>, <em>다른 쌍</em>에 속하는 이미지와 텍스트의 임베딩은 서로 <em>멀어지도록</em> 인코더를 학습시킵니다.</li>
<li><strong>손실 함수:</strong> 대조 손실(contrastive loss) 함수를 사용합니다. 이 손실 함수는 <em>같은 쌍</em>의 임베딩 간 유사도(예: 코사인 유사도)는 <em>높이고</em>, <em>다른 쌍</em>의 임베딩 간 유사도는 <em>낮추는</em> 방식으로 작동합니다. (10.4절 대조학습 참조)</li>
</ol>
<p><strong>코드 예시</strong></p>
<div id="cell-78" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb91"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.nn <span class="im">as</span> nn</span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.nn.functional <span class="im">as</span> F</span>
<span id="cb91-4"><a href="#cb91-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb91-5"><a href="#cb91-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-6"><a href="#cb91-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> CLIP(nn.Module):</span>
<span id="cb91-7"><a href="#cb91-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, image_encoder, text_encoder, embed_dim):</span>
<span id="cb91-8"><a href="#cb91-8" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb91-9"><a href="#cb91-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.image_encoder <span class="op">=</span> image_encoder</span>
<span id="cb91-10"><a href="#cb91-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.text_encoder <span class="op">=</span> text_encoder</span>
<span id="cb91-11"><a href="#cb91-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.image_projection <span class="op">=</span> nn.Linear(image_encoder.output_dim, embed_dim)</span>
<span id="cb91-12"><a href="#cb91-12" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.text_projection <span class="op">=</span> nn.Linear(text_encoder.output_dim, embed_dim)</span>
<span id="cb91-13"><a href="#cb91-13" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.logit_scale <span class="op">=</span> nn.Parameter(torch.ones([]) <span class="op">*</span> np.log(<span class="dv">1</span> <span class="op">/</span> <span class="fl">0.07</span>)) <span class="co"># Learnable scale parameter</span></span>
<span id="cb91-14"><a href="#cb91-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-15"><a href="#cb91-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, images, texts):</span>
<span id="cb91-16"><a href="#cb91-16" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 1. Image encoding</span></span>
<span id="cb91-17"><a href="#cb91-17" aria-hidden="true" tabindex="-1"></a>        image_features <span class="op">=</span> <span class="va">self</span>.image_encoder(images)  <span class="co"># [batch_size, image_encoder.output_dim]</span></span>
<span id="cb91-18"><a href="#cb91-18" aria-hidden="true" tabindex="-1"></a>        image_embeddings <span class="op">=</span> <span class="va">self</span>.image_projection(image_features)  <span class="co"># [batch_size, embed_dim]</span></span>
<span id="cb91-19"><a href="#cb91-19" aria-hidden="true" tabindex="-1"></a>        image_embeddings <span class="op">=</span> F.normalize(image_embeddings, dim<span class="op">=-</span><span class="dv">1</span>) <span class="co"># L2 normalization</span></span>
<span id="cb91-20"><a href="#cb91-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-21"><a href="#cb91-21" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 2. Text encoding</span></span>
<span id="cb91-22"><a href="#cb91-22" aria-hidden="true" tabindex="-1"></a>        text_features <span class="op">=</span> <span class="va">self</span>.text_encoder(texts)   <span class="co"># [batch_size, text_encoder.output_dim]</span></span>
<span id="cb91-23"><a href="#cb91-23" aria-hidden="true" tabindex="-1"></a>        text_embeddings <span class="op">=</span> <span class="va">self</span>.text_projection(text_features)    <span class="co"># [batch_size, embed_dim]</span></span>
<span id="cb91-24"><a href="#cb91-24" aria-hidden="true" tabindex="-1"></a>        text_embeddings <span class="op">=</span> F.normalize(text_embeddings, dim<span class="op">=-</span><span class="dv">1</span>) <span class="co"># L2 normalization</span></span>
<span id="cb91-25"><a href="#cb91-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-26"><a href="#cb91-26" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 3. Similarity calculation</span></span>
<span id="cb91-27"><a href="#cb91-27" aria-hidden="true" tabindex="-1"></a>        logits_per_image <span class="op">=</span> <span class="va">self</span>.logit_scale.exp() <span class="op">*</span> image_embeddings <span class="op">@</span> text_embeddings.t()  <span class="co"># [batch_size, batch_size]</span></span>
<span id="cb91-28"><a href="#cb91-28" aria-hidden="true" tabindex="-1"></a>        logits_per_text <span class="op">=</span> logits_per_image.t() <span class="co"># [batch_size, batch_size]</span></span>
<span id="cb91-29"><a href="#cb91-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-30"><a href="#cb91-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> logits_per_image, logits_per_text</span>
<span id="cb91-31"><a href="#cb91-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-32"><a href="#cb91-32" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> contrastive_loss(logits_per_image, logits_per_text):</span>
<span id="cb91-33"><a href="#cb91-33" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb91-34"><a href="#cb91-34" aria-hidden="true" tabindex="-1"></a><span class="co">    Calculates the Contrastive Loss</span></span>
<span id="cb91-35"><a href="#cb91-35" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb91-36"><a href="#cb91-36" aria-hidden="true" tabindex="-1"></a>    batch_size <span class="op">=</span> logits_per_image.shape[<span class="dv">0</span>]</span>
<span id="cb91-37"><a href="#cb91-37" aria-hidden="true" tabindex="-1"></a>    labels <span class="op">=</span> torch.arange(batch_size).to(logits_per_image.device) <span class="co"># Correct labels (diagonal: same pair)</span></span>
<span id="cb91-38"><a href="#cb91-38" aria-hidden="true" tabindex="-1"></a>    loss_i <span class="op">=</span> F.cross_entropy(logits_per_image, labels)  <span class="co"># Loss based on image</span></span>
<span id="cb91-39"><a href="#cb91-39" aria-hidden="true" tabindex="-1"></a>    loss_t <span class="op">=</span> F.cross_entropy(logits_per_text, labels)   <span class="co"># Loss based on text</span></span>
<span id="cb91-40"><a href="#cb91-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (loss_i <span class="op">+</span> loss_t) <span class="op">/</span> <span class="dv">2</span>  <span class="co"># Average loss</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="image-encoder" class="level3">
<h3 class="anchored" data-anchor-id="image-encoder">10.6.2 Image Encoder</h3>
<p>CLIP의 이미지 인코더는 이미지를 입력받아 고정된 차원의 임베딩 벡터로 변환합니다. 초기 CLIP 논문에서는 ResNet과 ViT(Vision Transformer)를 모두 실험했습니다.</p>
<ul>
<li><strong>ResNet 기반 인코더</strong>: 기존의 CNN 기반 이미지 분류 모델 (e.g., ResNet-50, ResNet-101)을 사용합니다.</li>
<li><strong>ViT 기반 인코더</strong>: ViT (Vision Transformer)를 이미지 인코더로 사용합니다 (10.5절 참조). ViT는 이미지를 패치로 나누고, 각 패치를 트랜스포머의 입력으로 사용하는 방식입니다.</li>
</ul>
<p>실험 결과, ViT 기반 인코더가 ResNet 기반 인코더보다 더 좋은 성능을 보였습니다. 특히, 모델과 데이터의 크기가 커질수록 ViT의 성능 향상 폭이 더 컸습니다.</p>
</section>
<section id="text-encoder" class="level3">
<h3 class="anchored" data-anchor-id="text-encoder">10.6.3 Text Encoder</h3>
<p>CLIP의 텍스트 인코더는 텍스트 설명을 입력받아 이미지 인코더와 <em>동일한 차원</em>의 임베딩 벡터로 변환합니다. 초기 CLIP 논문에서는 Transformer 기반의 텍스트 인코더를 사용했습니다.</p>
<ul>
<li>텍스트 인코더는 Byte Pair Encoding (BPE)을 사용하여 텍스트를 토큰화하고, 각 토큰을 임베딩합니다.</li>
<li>Transformer 블록을 여러 층 쌓아서 텍스트의 문맥 정보를 파악하고, 최종적으로 텍스트 전체를 대표하는 하나의 임베딩 벡터를 생성합니다.</li>
</ul>
</section>
<section id="zero-shot-전이의-메커니즘" class="level3">
<h3 class="anchored">10.6.4 Zero-shot 전이의 메커니즘</h3>
<p>CLIP의 가장 큰 특징 중 하나는 <em>별도의 미세 조정(fine-tuning) 없이</em>도 다양한 이미지 분류 태스크에서 뛰어난 성능을 보이는 <strong>제로샷(zero-shot) 전이</strong> 능력입니다.</p>
<p><strong>Zero-shot 전이가 가능한 이유</strong></p>
<p>CLIP은 대규모 이미지-텍스트 쌍 데이터셋으로 <em>대조 학습</em>을 수행하는 과정에서, 이미지와 텍스트를 <em>동일한 의미 공간(semantic space)</em>에 표현하는 방법을 학습합니다. 즉, CLIP은 이미지와 텍스트 간의 <em>의미적인 관련성</em>을 파악하는 능력을 갖게 됩니다.</p>
<p><strong>Zero-shot 분류 과정</strong></p>
<ol type="1">
<li><p>분류할 클래스(class)에 대한 텍스트 설명을 준비합니다. 예를 들어, CIFAR-10 데이터셋의 경우, “a photo of a cat”, “a photo of a dog”, …, “a photo of a truck”과 같은 텍스트 설명을 준비합니다.</p></li>
<li><p>텍스트 인코더를 사용하여 각 텍스트 설명을 임베딩합니다.</p></li>
<li><p>주어진 이미지를 이미지 인코더를 사용하여 임베딩합니다.</p></li>
<li><p>이미지 임베딩과 각 텍스트 임베딩 간의 유사도(예: 코사인 유사도)를 계산합니다.</p></li>
<li><p>가장 높은 유사도를 갖는 텍스트 설명에 해당하는 클래스를 이미지의 예측 클래스로 선택합니다.</p></li>
</ol>
<p><strong>Zero-shot 전이의 의미</strong></p>
<p>Zero-shot 전이는 모델이 학습 과정에서 전혀 보지 못한 새로운 클래스나 태스크에 대해서도, 추가적인 학습이나 미세 조정(fine-tuning) 없이 바로 적용할 수 있는 능력을 의미합니다. 이는 기존의 지도 학습 방식이 특정 태스크에 특화된 레이블이 있는 데이터를 필요로 하는 것과 대조적입니다.</p>
<p>Zero-shot 전이의 핵심은 유연성입니다. 예를 들어, 이미지 분류 모델을 학습시킬 때 “고양이”와 “강아지” 클래스에 대한 데이터만 사용했더라도, “기린”이나 “코끼리”와 같이 학습 데이터에 없던 클래스에 대한 이미지가 주어져도, “기린 사진”, “코끼리 사진”과 같은 자연어 설명만 제공하면 모델이 이미지를 올바르게 분류할 수 있습니다. 이처럼 새로운 클래스나 태스크에 대한 데이터가 전혀 없는 상황에서도, 자연어 설명을 통해 모델의 일반화 능력을 극대화할 수 있다는 것이 zero-shot 전이의 가장 큰 강점입니다.</p>
<p>또한, Zero-shot 전이는 범용성을 제공합니다. 이미지 분류뿐만 아니라, 이미지 검색, 이미지 캡셔닝, 객체 탐지(object detection), 시각적 질의응답(Visual Question Answering, VQA) 등 다양한 멀티모달 태스크에 적용될 수 있습니다. 예를 들어, 이미지 검색 시스템에서 “빨간색 스포츠카”와 같은 텍스트 쿼리를 입력하면, 모델은 “빨간색 스포츠카”에 해당하는 이미지를 데이터베이스에서 찾아낼 수 있습니다. 이는 모델이 이미지와 텍스트 간의 의미적 연결 관계를 이해하고 있기 때문에 가능한 것입니다. 이처럼 하나의 모델을 다양한 태스크에 활용할 수 있다는 점은 시간과 자원을 절약하고, 인공지능 시스템의 활용도를 높이는 데 크게 기여합니다.</p>
<p><strong>CLIP의 영향</strong></p>
<p>CLIP은 제로샷 전이 능력을 통해 멀티모달 학습의 새로운 가능성을 제시했습니다. 이후, CLIP의 아이디어를 기반으로 한 다양한 후속 연구들이 진행되었으며, DALL-E, Stable Diffusion과 같은 이미지 생성 모델, 그리고 GPT-4V와 같은 대규모 멀티모달 모델 개발에 큰 영향을 미쳤습니다.</p>
<div class="callout callout-style-default callout-note callout-titled" title="클릭하여 내용 보기 (딥다이브: Contrastive Learning과 CLIP)">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-2-contents" aria-controls="callout-2" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
클릭하여 내용 보기 (딥다이브: Contrastive Learning과 CLIP)
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-2" class="callout-2-contents callout-collapse collapse">
<section id="딥다이브-contrastive-learning과-clip" class="level2 callout-body-container callout-body">
<h2 class="anchored" data-anchor-id="딥다이브-contrastive-learning과-clip">딥다이브: Contrastive Learning과 CLIP</h2>
<p>Contrastive Learning은 레이블이 없는 데이터에서 표현(representation)을 학습하는 강력한 방법론입니다. 특히, 이미지와 텍스트와 같이 서로 다른 모달리티(modality)를 연결하는 멀티모달 학습에서 뛰어난 성과를 보여주고 있습니다. 이 딥다이브에서는 Contrastive Learning의 기본 원리, 다양한 방법론, 그리고 Contrastive Learning을 기반으로 이미지와 텍스트를 연결하는 획기적인 모델인 CLIP (Contrastive Language-Image Pre-training)을 심층적으로 분석합니다.</p>
<section id="contrastive-learning의-기본-원리" class="level3">
<h3 class="anchored" data-anchor-id="contrastive-learning의-기본-원리">1. Contrastive Learning의 기본 원리</h3>
<p>Contrastive Learning의 핵심 아이디어는 <strong>유사한 샘플 쌍(positive pair)은 임베딩 공간에서 가깝게, 유사하지 않은 샘플 쌍(negative pair)은 멀리 떨어지도록 표현을 학습</strong>하는 것입니다.</p>
<ul>
<li><strong>Anchor:</strong> 기준이 되는 샘플.</li>
<li><strong>Positive Sample:</strong> Anchor와 의미적으로 유사한 샘플. (e.g., 같은 이미지의 다른 augmentation, 같은 문장의 다른 번역)</li>
<li><strong>Negative Sample:</strong> Anchor와 의미적으로 다른 샘플.</li>
</ul>
<p>Contrastive Learning은 일반적으로 다음과 같은 단계를 거칩니다.</p>
<ol type="1">
<li><strong>Data Augmentation:</strong> Anchor와 Positive Sample을 생성하기 위해 다양한 data augmentation 기법을 적용합니다. (e.g., 이미지의 경우 random cropping, color jittering, rotation 등)</li>
<li><strong>Encoding:</strong> Anchor, Positive Sample, Negative Sample을 각각 인코더(encoder)를 통해 임베딩 벡터로 변환합니다.</li>
<li><strong>Contrastive Loss:</strong> Contrastive loss 함수를 사용하여 Positive pair의 임베딩은 가깝게, Negative pair의 임베딩은 멀어지도록 인코더를 학습합니다.</li>
</ol>
</section>
<section id="contrastive-loss-함수" class="level3">
<h3 class="anchored" data-anchor-id="contrastive-loss-함수">2. Contrastive Loss 함수</h3>
<p>다양한 Contrastive Loss 함수가 제안되었으며, 대표적인 예시는 다음과 같습니다.</p>
<ul>
<li><p><strong>InfoNCE Loss (Noise Contrastive Estimation):</strong> Cross-entropy loss와 유사한 형태로, positive pair에 대한 softmax 확률을 최대화합니다.</p>
<p><span class="math inline">\(L = -\log \frac{\exp(\text{sim}(z_i, z_j) / \tau)}{\sum_{k=1}^{2N} \mathbb{1}_{[k \neq i]} \exp(\text{sim}(z_i, z_k) / \tau)}\)</span></p>
<ul>
<li><span class="math inline">\(z_i\)</span>: Anchor의 임베딩</li>
<li><span class="math inline">\(z_j\)</span>: Positive sample의 임베딩</li>
<li><span class="math inline">\(z_k\)</span>: Negative sample의 임베딩 (k ≠ i)</li>
<li><span class="math inline">\(\text{sim}(\cdot, \cdot)\)</span>: 유사도 함수 (e.g., cosine similarity)</li>
<li><span class="math inline">\(\tau\)</span>: Temperature parameter (유사도 분포를 조절)</li>
<li><span class="math inline">\(N\)</span>: Mini-batch size</li>
</ul></li>
<li><p><strong>NT-Xent Loss (Normalized Temperature-scaled Cross Entropy Loss):</strong> InfoNCE Loss의 변형으로, SimCLR 논문에서 제안되었습니다.</p></li>
<li><p><strong>Triplet Loss:</strong> Anchor, Positive, Negative 샘플을 사용하여, Anchor와 Positive 간의 거리가 Anchor와 Negative 간의 거리보다 작도록 학습합니다.</p>
<p><span class="math inline">\(L = \max(0, d(a, p) - d(a, n) + m)\)</span></p>
<ul>
<li><span class="math inline">\(a\)</span>: Anchor</li>
<li><span class="math inline">\(p\)</span>: Positive sample</li>
<li><span class="math inline">\(n\)</span>: Negative sample</li>
<li><span class="math inline">\(d(\cdot, \cdot)\)</span>: 거리 함수 (e.g., Euclidean distance)</li>
<li><span class="math inline">\(m\)</span>: Margin (거리를 얼마나 떨어뜨릴지 결정)</li>
</ul></li>
</ul>
</section>
<section id="contrastive-learning-방법론" class="level3">
<h3 class="anchored" data-anchor-id="contrastive-learning-방법론">3. Contrastive Learning 방법론</h3>
<ul>
<li><strong>SimCLR (A Simple Framework for Contrastive Learning of Visual Representations):</strong> Data augmentation, large batch size, projection head (MLP)를 사용하여 이미지 표현 학습.</li>
<li><strong>MoCo (Momentum Contrast):</strong> Momentum encoder를 사용하여 negative sample을 안정적으로 유지하고, large batch size 없이도 좋은 성능을 달성.</li>
<li><strong>SwAV (Swapping Assignments between multiple Views):</strong> Online clustering을 통해 positive/negative sample을 명시적으로 정의하지 않고, representation을 학습.</li>
<li><strong>BYOL (Bootstrap Your Own Latent):</strong> Negative sample 없이, target network와 online network 간의 예측을 통해 학습.</li>
</ul>
</section>
<section id="clip-contrastive-language-image-pre-training" class="level3">
<h3 class="anchored" data-anchor-id="clip-contrastive-language-image-pre-training">4. CLIP (Contrastive Language-Image Pre-training)</h3>
<p>CLIP은 OpenAI에서 개발한 모델로, Contrastive Learning을 사용하여 이미지와 텍스트를 연결하는 강력한 멀티모달 표현을 학습합니다.</p>
<section id="clip의-학습" class="level4">
<h4 class="anchored" data-anchor-id="clip의-학습">4.1 CLIP의 학습</h4>
<ul>
<li><strong>데이터:</strong> 대규모 이미지-텍스트 쌍 데이터셋 (4억 개)</li>
<li><strong>모델:</strong>
<ul>
<li><strong>Image Encoder:</strong> 이미지에서 특징 벡터를 추출 (e.g., ResNet, ViT)</li>
<li><strong>Text Encoder:</strong> 텍스트에서 특징 벡터를 추출 (e.g., Transformer)</li>
</ul></li>
<li><strong>학습:</strong>
<ol type="1">
<li>이미지와 텍스트를 각각 인코딩하여 임베딩 벡터를 얻습니다.</li>
<li>같은 쌍(positive pair)의 이미지-텍스트 임베딩 간의 cosine similarity는 높이고, 다른 쌍(negative pair)의 임베딩 간의 cosine similarity는 낮추도록 Contrastive Loss (InfoNCE)를 사용하여 학습합니다.</li>
</ol>
<ul>
<li>배치 내에서 각 이미지는 하나의 긍정 텍스트와 (N-1)개의 부정 텍스트가 존재</li>
<li>마찬가지로 각 텍스트는 하나의 긍정 이미지와 (N-1)개의 부정 이미지가 존재</li>
</ul></li>
</ul>
</section>
<section id="clip의-특징" class="level4">
<h4 class="anchored" data-anchor-id="clip의-특징">4.2 CLIP의 특징</h4>
<ul>
<li><strong>Zero-shot learning:</strong> 별도의 fine-tuning 없이, 학습된 이미지-텍스트 representation을 사용하여 새로운 태스크(e.g., 이미지 분류, 이미지 검색)를 수행할 수 있습니다.
<ul>
<li>Zero-shot Image Classification 예시:
<ol type="1">
<li>분류할 클래스 이름을 텍스트로 표현 (e.g., “a photo of a cat”, “a photo of a dog”).</li>
<li>각 텍스트를 Text Encoder로 인코딩.</li>
<li>주어진 이미지를 Image Encoder로 인코딩.</li>
<li>이미지 임베딩과 각 텍스트 임베딩 간의 cosine similarity를 계산.</li>
<li>가장 높은 similarity를 갖는 텍스트에 해당하는 클래스로 이미지를 분류.</li>
</ol></li>
</ul></li>
<li><strong>강력한 representation learning:</strong> 다양한 태스크에 전이 가능한 일반적인 이미지/텍스트 표현 학습.</li>
</ul>
</section>
<section id="clip의-활용" class="level4">
<h4 class="anchored" data-anchor-id="clip의-활용">4.3 CLIP의 활용</h4>
<ul>
<li><strong>Image Classification:</strong> Zero-shot classification, few-shot classification.</li>
<li><strong>Image Retrieval:</strong> 텍스트 쿼리를 사용하여 이미지 검색.</li>
<li><strong>Image Generation:</strong> DALL-E, Stable Diffusion과 같은 텍스트 기반 이미지 생성 모델의 기반 기술로 활용.</li>
<li><strong>Visual Question Answering (VQA):</strong> 이미지와 질문 텍스트를 함께 입력받아 답변 생성.</li>
<li><strong>Object Detection:</strong> CLIP을 object detection 모델에 통합하여 open-vocabulary object detection 수행.</li>
</ul>
</section>
</section>
<section id="contrastive-learning과-clip의-한계-및-향후-연구-방향" class="level3">
<h3 class="anchored" data-anchor-id="contrastive-learning과-clip의-한계-및-향후-연구-방향">5. Contrastive Learning과 CLIP의 한계 및 향후 연구 방향</h3>
<ul>
<li><strong>Data Augmentation 의존성:</strong> Contrastive Learning은 data augmentation 기법에 민감합니다. 어떤 augmentation이 효과적인지에 대한 연구가 필요합니다.</li>
<li><strong>Negative Sampling Bias:</strong> Negative sample을 어떻게 선택하느냐에 따라 학습 결과가 달라질 수 있습니다. Hard negative mining 등의 기법이 연구되고 있습니다.</li>
<li><strong>Mode Collapse:</strong> 모든 샘플이 하나의 표현으로 수렴하는 현상.</li>
<li><strong>Fine-grained Understanding:</strong> CLIP은 이미지와 텍스트 간의 coarse-grained alignment는 잘 학습하지만, fine-grained understanding (e.g., 이미지 내 객체 간의 관계, 텍스트의 미묘한 뉘앙스)은 부족할 수 있습니다.</li>
<li><strong>계산 비용:</strong> 대규모 데이터셋과 큰 배치 크기를 필요로 합니다.</li>
</ul>
</section>
<section id="결론-1" class="level3">
<h3 class="anchored" data-anchor-id="결론-1">6. 결론</h3>
<p>Contrastive Learning은 레이블이 없는 데이터를 활용하여 강력한 표현을 학습하는 효과적인 방법론입니다. 특히, CLIP은 Contrastive Learning을 멀티모달 학습에 성공적으로 적용하여, 이미지와 텍스트를 연결하는 새로운 지평을 열었습니다. Contrastive Learning과 CLIP은 앞으로도 다양한 분야에서 활용될 것으로 기대됩니다.</p>
<p><strong>참고 문헌:</strong></p>
<ul>
<li>Chen, T., Kornblith, S., Norouzi, M., &amp; Hinton, G. (2020). A simple framework for contrastive learning of visual representations. <em>International conference on machine learning</em>. PMLR.</li>
<li>Radford, A., Kim, J. W., Hallacy, C., Ramesh, A., Goh, G., Agarwal, S., … &amp; Sutskever, I. (2021). Learning transferable visual models from natural language supervision. <em>International Conference on Machine Learning</em>. PMLR.</li>
<li>He, K., Fan, H., Wu, Y., Xie, S., &amp; Girshick, R. (2020). Momentum contrast for unsupervised visual representation learning. In <em>Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition</em> (pp.&nbsp;9729-9738).</li>
<li>Grill, J. B., Strub, F., Altché, F., Tallec, C., Richemond, P., Buchatskaya, E., … &amp; Valko, M. (2020). Bootstrap your own latent-a new approach to self-supervised learning. <em>Advances in neural information processing systems</em>, 33, 21271-21284.</li>
</ul>
</section>
</section>
</div>
</div>
</section>
</section>
<section id="연습문제" class="level2">
<h2 class="anchored" data-anchor-id="연습문제">연습문제</h2>
<p><strong>기본 문제</strong></p>
<ol type="1">
<li>멀티모달 데이터란 무엇인지 설명하고, 멀티모달 데이터의 예시를 3가지 이상 제시하세요.</li>
<li>Joint Representation과 Coordinated Representation의 차이점을 설명하고, 각 표현 방식의 장단점을 비교하세요.</li>
<li>Image Captioning 태스크를 정의하고, 이 태스크를 해결하기 위한 딥러닝 모델의 일반적인 구조 (인코더-디코더)를 설명하세요.</li>
</ol>
<p><strong>응용 문제</strong></p>
<ol type="1">
<li>Visual Question Answering (VQA) 태스크를 해결하기 위해, 이미지와 질문 텍스트를 입력으로 받아 답변을 생성하는 간단한 모델의 구조를 설계하고 (블록 다이어그램 등 활용), 각 구성 요소의 역할을 설명하세요.</li>
<li>CLIP 모델의 학습 방식을 설명하고, 이 방식이 기존의 이미지-텍스트 지도 학습 방식과 비교하여 어떤 장점을 가지는지 설명하세요.</li>
<li>Hugging Face Transformers 라이브러리를 사용하여, 이미지와 관련된 텍스트 캡션을 생성하는 코드를 작성하세요 (e.g., <code>blip-image-captioning-base</code> 모델 활용).</li>
</ol>
<p><strong>심화 문제</strong></p>
<ol type="1">
<li>멀티모달 퓨전 (Multimodal Fusion)의 다양한 방법 (early fusion, late fusion, hybrid fusion)을 조사하고, 각 방법의 장단점과 어떤 상황에서 어떤 퓨전 방법이 적합할지 설명하세요.</li>
<li>Cross-Modal Attention 메커니즘의 작동 원리를 설명하고, 이 메커니즘이 멀티모달 학습에서 어떤 역할을 하는지 구체적인 예시 (e.g., VQA, Image Captioning)와 함께 설명하세요.</li>
<li>텍스트 설명을 기반으로 이미지를 생성하는 모델 (e.g., DALL-E, Stable Diffusion)의 작동 원리를 조사하고, 이러한 모델이 사회에 미칠 수 있는 긍정적/부정적 영향에 대해 논하세요.(아이디어 제안 및 토론 수준)</li>
</ol>
<div class="callout callout-style-default callout-note callout-titled" title="클릭하여 내용 보기 (연습문제 해답)">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-3-contents" aria-controls="callout-3" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
클릭하여 내용 보기 (연습문제 해답)
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-3" class="callout-3-contents callout-collapse collapse">
<section id="연습문제-해답" class="level2 callout-body-container callout-body">
<h2 class="anchored" data-anchor-id="연습문제-해답">연습문제 해답</h2>
<section id="기본-문제" class="level3">
<h3 class="anchored" data-anchor-id="기본-문제">기본 문제</h3>
<ol type="1">
<li><strong>멀티모달 데이터:</strong> 둘 이상의 서로 다른 형태의 데이터(모달리티)가 결합된 데이터를 의미합니다. 예시:
<ul>
<li>이미지와 텍스트 캡션</li>
<li>비디오와 오디오 트랙</li>
<li>센서 데이터 (e.g., 가속도계, 자이로스코프)와 텍스트 설명</li>
</ul></li>
<li><strong>Joint Representation vs.&nbsp;Coordinated Representation:</strong>
<ul>
<li><strong>Joint Representation:</strong> 여러 모달리티의 정보를 하나의 통합된 벡터 공간에 표현합니다.
<ul>
<li>장점: 여러 모달리티 간의 상관관계를 직접적으로 모델링 가능.</li>
<li>단점: 하나의 모달리티가 다른 모달리티를 압도할 수 있음.</li>
</ul></li>
<li><strong>Coordinated Representation:</strong> 각 모달리티를 별도의 벡터 공간에 표현하되, 이 공간들이 서로 관련되도록 (e.g., 유사성 제약) 학습합니다.
<ul>
<li>장점: 각 모달리티의 고유한 특성을 유지하면서도 상호 작용 가능.</li>
<li>단점: Joint Representation보다 모달리티 간 상호작용 모델링이 간접적.</li>
</ul></li>
</ul></li>
<li><strong>Image Captioning:</strong> 주어진 이미지에 대한 텍스트 설명을 생성하는 태스크입니다.
<ul>
<li><strong>일반적인 구조 (인코더-디코더):</strong>
<ul>
<li><strong>인코더:</strong> 이미지의 특징(feature)을 추출합니다 (일반적으로 CNN 사용).</li>
<li><strong>디코더:</strong> 인코더에서 추출된 이미지 특징과 이전 시점까지 생성된 단어를 기반으로 다음 단어를 예측합니다 (일반적으로 RNN 또는 Transformer 사용). 어텐션 메커니즘을 사용하여 이미지의 특정 영역에 집중할 수 있습니다.</li>
</ul></li>
</ul></li>
</ol>
</section>
<section id="응용-문제" class="level3">
<h3 class="anchored" data-anchor-id="응용-문제">응용 문제</h3>
<ol type="1">
<li><p><strong>VQA 모델 구조:</strong></p>
<pre class="mermaid"><code>graph LR
    subgraph VQA Model
        A[Image] --&gt; B(Image Encoder - CNN)
        C[Question Text] --&gt; D(Text Encoder - RNN/Transformer)
        B --&gt; E(Fusion Module)
        D --&gt; E
        E --&gt; F(Decoder - RNN/Transformer)
        F --&gt; G(Answer)
    end</code></pre>
<ul>
<li><strong>Image Encoder (CNN):</strong> 이미지를 입력받아 특징 벡터를 추출합니다.</li>
<li><strong>Text Encoder (RNN/Transformer):</strong> 질문 텍스트를 입력받아 특징 벡터를 추출합니다.</li>
<li><strong>Fusion Module:</strong> 이미지 특징 벡터와 질문 텍스트 특징 벡터를 결합합니다 (e.g., concatenation, element-wise multiplication, cross-modal attention).</li>
<li><strong>Decoder (RNN/Transformer):</strong> 융합된 특징 벡터를 기반으로 답변을 생성합니다.</li>
</ul></li>
<li><p><strong>CLIP 학습 방식 및 장점:</strong></p>
<ul>
<li><strong>학습 방식:</strong> CLIP은 대규모 이미지-텍스트 쌍 데이터셋을 사용하여, 이미지와 텍스트를 각각 인코딩하고, 같은 쌍에서 나온 이미지와 텍스트 임베딩은 가깝게, 다른 쌍에서 나온 임베딩은 멀어지도록 contrastive loss를 사용하여 학습합니다.</li>
<li><strong>장점:</strong>
<ul>
<li><strong>Zero-shot learning:</strong> 별도의 fine-tuning 없이 새로운 태스크(e.g., 이미지 분류)에 적용 가능.</li>
<li><strong>강력한 representation learning:</strong> 다양한 태스크에 전이 가능한 일반적인 이미지/텍스트 표현 학습.</li>
<li><strong>데이터 효율성:</strong> 레이블이 없는 이미지-텍스트 쌍 데이터를 활용 가능.</li>
</ul></li>
</ul></li>
<li><p><strong>Hugging Face Transformers Image Captioning 코드:</strong></p>
<div class="sourceCode" id="cb93"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> transformers <span class="im">import</span> pipeline</span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a>captioner <span class="op">=</span> pipeline(<span class="st">"image-to-text"</span>, model<span class="op">=</span><span class="st">"nlpconnect/vit-gpt2-image-captioning"</span>) <span class="co"># 또는 "blip-image-captioning-base"</span></span>
<span id="cb93-4"><a href="#cb93-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-5"><a href="#cb93-5" aria-hidden="true" tabindex="-1"></a>image_path <span class="op">=</span> <span class="st">"path/to/your/image.jpg"</span>  <span class="co"># 이미지 파일 경로</span></span>
<span id="cb93-6"><a href="#cb93-6" aria-hidden="true" tabindex="-1"></a>caption <span class="op">=</span> captioner(image_path)[<span class="dv">0</span>][<span class="st">'generated_text'</span>]</span>
<span id="cb93-7"><a href="#cb93-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(caption)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
</ol>
</section>
<section id="심화-문제" class="level3">
<h3 class="anchored" data-anchor-id="심화-문제">심화 문제</h3>
<ol type="1">
<li><p><strong>멀티모달 퓨전 방법:</strong></p>
<ul>
<li><strong>Early Fusion:</strong> 입력 단계에서 모달리티들을 결합합니다 (e.g., 채널 concatenation).
<ul>
<li>장점: 모달리티 간의 저수준 상호작용을 포착 가능.</li>
<li>단점: 차원이 매우 커질 수 있고, 각 모달리티의 고유한 특성이 희석될 수 있음.</li>
</ul></li>
<li><strong>Late Fusion:</strong> 각 모달리티를 독립적으로 처리한 후, 마지막 단계에서 결과를 결합합니다 (e.g., averaging, voting).
<ul>
<li>장점: 각 모달리티의 특성을 최대한 활용, 구현이 간단.</li>
<li>단점: 모달리티 간의 저수준 상호작용을 포착하기 어려움.</li>
</ul></li>
<li><strong>Hybrid Fusion:</strong> Early Fusion과 Late Fusion을 혼합한 방식. 다양한 수준에서 퓨전을 수행.
<ul>
<li>장점: Early/Late Fusion의 장점을 모두 취할 수 있음.</li>
<li>단점: 모델이 복잡해짐.</li>
</ul></li>
<li><strong>적합한 상황:</strong>
<ul>
<li><strong>Early Fusion:</strong> 모달리티 간의 긴밀한 상호작용이 중요한 경우 (e.g., 비디오와 오디오의 동기화).</li>
<li><strong>Late Fusion:</strong> 각 모달리티가 독립적으로 의미를 가지는 경우 (e.g., 이미지 태깅과 텍스트 설명).</li>
<li><strong>Hybrid Fusion:</strong> 복잡한 태스크에서 다양한 수준의 상호작용을 포착해야 하는 경우.</li>
</ul></li>
</ul></li>
<li><p><strong>Cross-Modal Attention:</strong></p>
<ul>
<li><strong>작동 원리:</strong> 한 모달리티의 쿼리(query)를 사용하여 다른 모달리티의 키(key)에 대한 어텐션 가중치를 계산하고, 이 가중치를 사용하여 다른 모달리티의 값(value)을 가중 합산하여 새로운 표현을 생성합니다.</li>
<li><strong>역할:</strong>
<ul>
<li><strong>VQA:</strong> 질문 텍스트의 각 단어(query)가 이미지의 어떤 영역(key, value)에 주목해야 하는지 결정.</li>
<li><strong>Image Captioning:</strong> 생성되는 각 단어(query)가 이미지의 어떤 영역(key, value)에 관련되어 있는지 결정.</li>
</ul></li>
</ul></li>
<li><p><strong>텍스트 기반 이미지 생성 모델 (DALL-E, Stable Diffusion 등):</strong></p>
<ul>
<li><strong>작동 원리 (간략화):</strong>
<ul>
<li><strong>DALL-E (Transformer 기반):</strong> 텍스트와 이미지를 토큰화하고 Transformer를 이용해 텍스트 토큰 시퀀스가 주어졌을 때 이미지 토큰 시퀀스가 나타날 확률을 모델링.</li>
<li><strong>Stable Diffusion (Diffusion Model 기반):</strong> 이미지에 점진적으로 노이즈를 추가하는 forward process와, 노이즈로부터 이미지를 복원하는 reverse process를 학습. 텍스트 정보는 reverse process에서 조건으로 주어져 이미지를 제어.</li>
</ul></li>
<li><strong>긍정적 영향:</strong>
<ul>
<li><strong>창의성 증진:</strong> 새로운 아이디어 시각화, 예술 작품 창작 지원.</li>
<li><strong>콘텐츠 제작 효율성 향상:</strong> 디자인, 광고, 교육 자료 제작 자동화.</li>
<li><strong>접근성 향상:</strong> 시각 장애인을 위한 이미지 설명 생성.</li>
</ul></li>
<li><strong>부정적 영향:</strong>
<ul>
<li><strong>Deepfake, 허위 정보 확산:</strong> 현실 왜곡, 명예 훼손.</li>
<li><strong>저작권 침해:</strong> 기존 이미지 무단 사용 및 변형.</li>
<li><strong>일자리 감소:</strong> 디자이너, 일러스트레이터 등 직업 대체.</li>
<li><strong>편향 및 차별:</strong> 학습 데이터의 편향을 반영하여 특정 집단에 대한 차별적인 이미지 생성.</li>
</ul></li>
</ul></li>
</ol>
</section>
</section>
</div>
</div>
</section>
<section id="참고-자료" class="level2">
<h2 class="anchored" data-anchor-id="참고-자료">참고 자료</h2>
<ol type="1">
<li><p><strong>CLIP (Learning Transferable Visual Models From Natural Language Supervision):</strong> 이미지와 텍스트를 연결하는 멀티모달 표현 학습 방법인 CLIP의 원 논문. <a href="https://www.google.com/url?sa=E&amp;source=gmail&amp;q=https://arxiv.org/abs/2103.00020">https://arxiv.org/abs/2103.00020</a></p></li>
<li><p><strong>ViT (An Image is Worth 16x16 Words: Transformers for Image Recognition at Scale):</strong> CNN 없이 Transformer 구조만으로 이미지 분류에서 뛰어난 성능을 보인 ViT 원 논문. <a href="https://www.google.com/url?sa=E&amp;source=gmail&amp;q=https://arxiv.org/abs/2010.11929">https://arxiv.org/abs/2010.11929</a></p></li>
<li><p><strong>DALL-E (Zero-Shot Text-to-Image Generation):</strong> 텍스트 설명을 기반으로 이미지를 생성하는 DALL-E 모델 논문. <a href="https://www.google.com/url?sa=E&amp;source=gmail&amp;q=https://arxiv.org/abs/2102.12092">https://arxiv.org/abs/2102.12092</a></p></li>
<li><p><strong>MAE (Masked Autoencoders Are Scalable Vision Learners):</strong> 이미지의 일부를 가리고 복원하는 방식으로 비전 표현을 학습하는 MAE 논문. <a href="https://www.google.com/url?sa=E&amp;source=gmail&amp;q=https://arxiv.org/abs/2111.06377">https://arxiv.org/abs/2111.06377</a></p></li>
<li><p><strong>Visual Question Answering (VQA):</strong> 초기 VQA 연구 중 하나로, VQA 데이터셋과 baseline 모델 제시. <a href="https://www.google.com/url?sa=E&amp;source=gmail&amp;q=https://arxiv.org/abs/1505.00468">https://arxiv.org/abs/1505.00468</a></p></li>
<li><p><strong>Show, Attend and Tell (Neural Image Caption Generation with Visual Attention):</strong> 어텐션 메커니즘을 이미지 캡셔닝에 처음 도입한 논문. <a href="https://www.google.com/url?sa=E&amp;source=gmail&amp;q=https://arxiv.org/abs/1502.03044">https://arxiv.org/abs/1502.03044</a></p></li>
<li><p><strong>Multimodal Machine Learning: A Survey and Taxonomy:</strong> 멀티모달 머신러닝에 대한 포괄적인 survey 논문. <a href="https://www.google.com/url?sa=E&amp;source=gmail&amp;q=https://arxiv.org/abs/1705.09406">https://arxiv.org/abs/1705.09406</a></p></li>
<li><p><strong>A Tutorial on Multimodal Deep Learning, Jiquan Ngiam:</strong> NeurIPS 2011의 멀티모달 딥러닝 튜토리얼 (영상). <a href="https://www.google.com/search?q=https://www.youtube.com/watch%3Fv%3DcR_ACqfF-bY%26list%3DPL_45CaSOtPzL-HWxMcnr02KvmP9Gq-xdb">https://www.youtube.com/watch?v=cR_ACqfF-bY&amp;list=PL_45CaSOtPzL-HWxMcnr02KvmP9Gq-xdb</a></p></li>
<li><p><strong>CMU Multimodal Machine Learning Course (11-777, Spring 2023), Louis-Philippe Morency:</strong> 카네기 멜론 대학교 멀티모달 머신러닝 강의 자료. <a href="https://www.google.com/url?sa=E&amp;source=gmail&amp;q=https://cmu-multicomp-lab.github.io/mmml-course/spring2023/">https://cmu-multicomp-lab.github.io/mmml-course/spring2023/</a></p></li>
<li><p><strong>A Comprehensive Survey on Deep Multimodal Learning:</strong> 2022년 멀티모달 딥러닝 survey 논문. <a href="https://www.google.com/url?sa=E&amp;source=gmail&amp;q=https://arxiv.org/abs/2204.11984">https://arxiv.org/abs/2204.11984</a></p></li>
<li><p><strong>arXiv:</strong> 최신 멀티모달 학습 연구 논문 검색. “multimodal learning”, “vision-language” 등 키워드 활용. <a href="https://arxiv.org/">https://arxiv.org/</a></p></li>
<li><p><strong>Hugging Face Transformers Multimodal Documentation:</strong> Hugging Face Transformers 라이브러리의 멀티모달 모델 문서. <a href="https://www.google.com/search?q=https://huggingface.co/docs/transformers/main/en/model_doc/auto%23multimodal-models">https://huggingface.co/docs/transformers/main/en/model_doc/auto#multimodal-models</a></p></li>
</ol>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>