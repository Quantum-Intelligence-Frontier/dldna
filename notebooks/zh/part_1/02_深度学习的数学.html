<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>quarto-inputa5b90fd1dd1ec639 – Deep Learning DNA: Surviving Architectures and Essential Principles</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap-f507c7d0488cb7630e20aad62ad8c2aa.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script>window.MathJax = {loader: {load: ['[tex]/boldsymbol']},tex: {packages: {'[+]': ['boldsymbol']}}};</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-sidebar docked">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../../notebooks/zh/part_1/01_深度学习的开始.html">part_1</a></li><li class="breadcrumb-item"><a href="../../../notebooks/zh/part_1/02_深度学习的数学.html">2. 深度学习的数学</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../../../">中文</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Language</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../index_de.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Deutsch</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../index_en.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">English</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../index_es.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Español</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">한국어</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../index_zh.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">中文</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../notebooks/zh/part_1/00_引言.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">引言</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true">
 <span class="menu-text">part_1</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../notebooks/zh/part_1/01_深度学习的开始.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">1. 深度学习的开始</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../notebooks/zh/part_1/02_深度学习的数学.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">2. 深度学习的数学</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../notebooks/zh/part_1/03_深度学习框架.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">3. 深度学习框架</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../notebooks/zh/part_1/04_激活函数.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">4. 激活函数</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../notebooks/zh/part_1/05_优化和可视化.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">5. 优化和可视化</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../notebooks/zh/part_1/06_过拟合和解决技术的发展.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">6. 过拟合和解决技术的发展</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../notebooks/zh/part_1/07_卷积神经网络的进化.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">7. 卷积神经网络的进化</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../notebooks/zh/part_1/08_变压器的诞生.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">8. 变压器的诞生</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../notebooks/zh/part_1/09_变压器的进化.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">9. 变压器的进化</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../notebooks/zh/part_1/10_多模态深度学习：多感官融合的开始.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">10. 多模态深度学习：多感官融合的开始</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../notebooks/zh/part_1/11_多模态深度学习：超越智能的极限.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">11. 多模态深度学习：超越智能的极限</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true">
 <span class="menu-text">深度学习的最前沿</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../notebooks/zh/深度学习的最前沿/01_SLM: 小但强大的语言模型.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">1. SLM: 小但强大的语言模型</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../notebooks/zh/深度学习的最前沿/02_自动驾驶.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">2. 自动驾驶</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#深度学习的数学" id="toc-深度学习的数学" class="nav-link active" data-scroll-target="#深度学习的数学">2. 深度学习的数学</a>
  <ul class="collapse">
  <li><a href="#线性代数基础" id="toc-线性代数基础" class="nav-link" data-scroll-target="#线性代数基础">2.1 线性代数基础</a>
  <ul class="collapse">
  <li><a href="#向量" id="toc-向量" class="nav-link" data-scroll-target="#向量">2.1.1 向量</a></li>
  <li><a href="#维度秩" id="toc-维度秩" class="nav-link" data-scroll-target="#维度秩">2.1.2 维度，秩</a></li>
  <li><a href="#线性变换的基础" id="toc-线性变换的基础" class="nav-link" data-scroll-target="#线性变换的基础">2.1.3 线性变换的基础</a></li>
  <li><a href="#张量运算" id="toc-张量运算" class="nav-link" data-scroll-target="#张量运算">2.1.4 张量运算</a></li>
  <li><a href="#奇异值分解和主成分分析" id="toc-奇异值分解和主成分分析" class="nav-link" data-scroll-target="#奇异值分解和主成分分析">2.1.5 奇异值分解和主成分分析</a></li>
  </ul></li>
  <li><a href="#微积分和优化" id="toc-微积分和优化" class="nav-link" data-scroll-target="#微积分和优化">2.2 微积分和优化</a>
  <ul class="collapse">
  <li><a href="#链式法则" id="toc-链式法则" class="nav-link" data-scroll-target="#链式法则">2.2.1 链式法则</a></li>
  <li><a href="#梯度和雅可比矩阵" id="toc-梯度和雅可比矩阵" class="nav-link" data-scroll-target="#梯度和雅可比矩阵">2.2.2 梯度和雅可比矩阵</a></li>
  <li><a href="#链式法则与神经网络的反向传播" id="toc-链式法则与神经网络的反向传播" class="nav-link" data-scroll-target="#链式法则与神经网络的反向传播">2.2.3 链式法则与神经网络的反向传播</a></li>
  <li><a href="#反向传播的梯度计算" id="toc-反向传播的梯度计算" class="nav-link" data-scroll-target="#反向传播的梯度计算">2.2.4 反向传播的梯度计算</a></li>
  </ul></li>
  <li><a href="#概率与统计" id="toc-概率与统计" class="nav-link" data-scroll-target="#概率与统计">2.3 概率与统计</a>
  <ul class="collapse">
  <li><a href="#概率分布与期望值" id="toc-概率分布与期望值" class="nav-link" data-scroll-target="#概率分布与期望值">2.3.1 概率分布与期望值</a></li>
  <li><a href="#贝叶斯定理和最大似然估计" id="toc-贝叶斯定理和最大似然估计" class="nav-link" data-scroll-target="#贝叶斯定理和最大似然估计">2.3.2 贝叶斯定理和最大似然估计</a></li>
  <li><a href="#信息论基础" id="toc-信息论基础" class="nav-link" data-scroll-target="#信息论基础">2.3.3 信息论基础</a></li>
  <li><a href="#损失函数" id="toc-损失函数" class="nav-link" data-scroll-target="#损失函数">2.3.4 损失函数</a></li>
  </ul></li>
  <li><a href="#练习题" id="toc-练习题" class="nav-link" data-scroll-target="#练习题">练习题</a>
  <ul class="collapse">
  <li><a href="#线性代数" id="toc-线性代数" class="nav-link" data-scroll-target="#线性代数">1. 线性代数</a></li>
  </ul></li>
  <li><a href="#练习题-1" id="toc-练习题-1" class="nav-link" data-scroll-target="#练习题-1">练习题</a>
  <ul class="collapse">
  <li><a href="#概率与统计-1" id="toc-概率与统计-1" class="nav-link" data-scroll-target="#概率与统计-1">3 概率与统计</a></li>
  </ul></li>
  <li><a href="#参考文献" id="toc-参考文献" class="nav-link" data-scroll-target="#参考文献">参考文献</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../../notebooks/zh/part_1/01_深度学习的开始.html">part_1</a></li><li class="breadcrumb-item"><a href="../../../notebooks/zh/part_1/02_深度学习的数学.html">2. 深度学习的数学</a></li></ol></nav></header>




<p><a href="https://colab.research.google.com/github/Quantum-Intelligence-Frontier/dldna/blob/main/notebooks/zh/part_1/02_深度学习的数学.ipynb" target="_parent"> <img src="https://colab.research.google.com/assets/colab-badge.svg" alt="在Colab中打开"> </a></p>
<section id="深度学习的数学" class="level1">
<h1>2. 深度学习的数学</h1>
<blockquote class="blockquote">
<p>“所有的数都是由单位组成的，所有的数都可以被分解为单位” - 阿尔-花拉子米 (780-850)，波斯数学家</p>
</blockquote>
<p>在本章中，我们将探讨构成深度学习核心的数学概念。深度学习模型是由复杂的数学函数组合而成的。深入理解线性代数、微积分、概率和统计对于掌握模型的工作原理、提高性能以及设计新模型至关重要。例如，对矩阵运算的理解对于理解卷积神经网络 (CNN) 的工作方式非常重要，而微分和优化在理解模型的学习过程中起着核心作用。</p>
<p>如果您觉得本章难以理解，可以跳到下一章。随时回过头来熟悉这些内容会更好。</p>
<section id="线性代数基础" class="level2">
<h2 class="anchored" data-anchor-id="线性代数基础">2.1 线性代数基础</h2>
<p>线性代数是深度学习的基础。从矩阵运算到高级优化技术，线性代数都是必不可少的工具。在这一节中，我们将从向量、矩阵、张量等基本概念开始，一直探讨到奇异值分解和主成分分析等高级主题。</p>
<section id="向量" class="level3">
<h3 class="anchored" data-anchor-id="向量">2.1.1 向量</h3>
<p>向量和矩阵是表示数据并转换每个数据的基本运算。</p>
<p><strong>向量的基础</strong></p>
<p>向量是一个具有大小和方向的数学对象。其数学定义是一致的。然而，根据应用领域的不同，看待它的角度会略有差异。</p>
<ul>
<li>数学视角: 在数学中，向量被定义为一个具有大小和方向的抽象对象。作为向量空间中的元素，它具有关于加法和标量乘法封闭的特点。</li>
<li>物理学视角: 在物理学中，向量主要用于表示力、速度、加速度等物理量。在这种情况下，向量的大小和方向具有实际的物理意义。物理学处理所有的变化都使用向量，并且向量的维度是有限的。空间通常是三维的，时空则是四维的。</li>
<li>计算机科学视角: 在计算机科学中，尤其是在机器学习和深度学习领域，向量主要用于表示数据的特征(feature)。这里的每个元素代表了特定的数据属性，不一定具有物理上的方向性。为了表达特性，向量维度可以从几十到几千不等。</li>
</ul>
<p>理解这些不同的观点对于在深度学习中处理向量非常重要。虽然在深度学习中向量主要从计算机科学的角度使用，但数学运算和物理直觉也是共同使用的。</p>
<p>在深度学习中，向量主要用于同时表示数据的多个特征(features)。例如，在一个用于预测房价的模型中，可以使用一个五维向量来表示如下内容。</p>
<p><span class="math inline">\(\mathbf{v} = \begin{bmatrix} v_1 \ v_2 \ v_3 \ v_4 \ v_5 \end{bmatrix}\)</span></p>
<p>该向量中的每个元素代表了房子的不同特征。 <span class="math inline">\(v_1\)</span>: 房屋面积 (平方米), <span class="math inline">\(v_2\)</span>: 卧室数量, <span class="math inline">\(v_3\)</span>: 房龄 (年), <span class="math inline">\(v_4\)</span>: 距离最近学校的距离 (公里), <span class="math inline">\(v_5\)</span>: 犯罪率 (百分比)</p>
<p>深度学习模型可以将这样的多维向量作为输入来预测房价。像这样，向量用于有效地表示和处理复杂的真实数据的多个特征。</p>
<p>在NumPy中，可以轻松地创建并使用向量。</p>
<div id="cell-2" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="op">!</span>pip install dldna[colab] <span class="co"># in Colab</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co"># !pip install dldna[all] # in your local</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="cell-3" class="cell" data-execution_count="1">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Vector creation</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>v <span class="op">=</span> np.array([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>])</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Vector magnitude (L2 norm)</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>magnitude <span class="op">=</span> np.linalg.norm(v)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Vector magnitude: </span><span class="sc">{</span>magnitude<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Vector normalization</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>normalized_v <span class="op">=</span> v <span class="op">/</span> magnitude</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Normalized vector: </span><span class="sc">{</span>normalized_v<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Vector magnitude: 3.7416573867739413
Normalized vector: [0.26726124 0.53452248 0.80178373]</code></pre>
</div>
</div>
<p>向量的概念更深入地探讨时，涉及行向量和列向量的区别，以及物理学和工程学中使用的协变向量和逆变向量的概念。</p>
<p><strong>行向量与列向量</strong></p>
<p>向量通常以列向量为基本形式表示。行向量可以视为列向量的转置（transpose）。更精确地说，从数学角度来看，行向量也可以称为对偶向量或协变向量(covector)。</p>
<p>列向量: <span class="math inline">\(\mathbf{v} = \begin{bmatrix} v_1 \ v_2 \ v_3 \end{bmatrix}\)</span>, 行向量: <span class="math inline">\(\mathbf{v}^T = [v_1 \quad v_2 \quad v_3]\)</span></p>
<p>行向量和列向量具有不同的性质。行向量作为线性函数作用于列向量，生成标量。这通过内积运算来表示。</p>
<p><span class="math display">\[\mathbf{u}^T\mathbf{v} = u_1v_1 + u_2v_2 + u_3v_3\]</span></p>
<p><strong>协变向量与逆变向量</strong></p>
<p>在物理学和工程学中，协变向量(covariant vector)和逆变向量(contravariant vector)的概念是非常重要的。这表示了向量在坐标系变换时的转换特性。</p>
<ul>
<li>逆变向量: 当坐标系改变时，沿基向量相反方向变换的向量。通常用上标表示（例如：<span class="math inline">\(v^i\)</span>）。</li>
<li>协变向量: 当坐标系改变时，沿基向量相同方向变换的向量。通常用下标表示（例如：<span class="math inline">\(v_i\)</span>）。</li>
</ul>
<p>在张量记法中，这种区别非常重要。例如，<span class="math inline">\(T^i_j\)</span>中的上指标<span class="math inline">\(i\)</span>表示逆变性，而下指标<span class="math inline">\(j\)</span>表示协变性。特别是，在广义相对论中，这些协变性和逆变性的概念是非常重要的。</p>
<p><strong>深度学习中的应用</strong></p>
<p>在深度学习中，这样的协变性与逆变性的区别通常不会被明确强调。原因如下：</p>
<ol type="1">
<li>标准化的数据表示：在深度学习中，大多数情况下，数据以标准化的形式（例如：列向量）处理，因此协变性和逆变性的区分变得不那么重要。</li>
<li>欧几里得空间假设：许多深度学习模型假定数据位于欧几里得空间。在这种空间中，协变性与逆变性的区分并不明显。</li>
<li>运算的简化：深度学习的主要运算（例如：矩阵乘法、激活函数应用）即使没有这些区分也可以有效地执行。</li>
<li>自动微分：现代深度学习框架的自动微分功能可以在不考虑这些细微区别的前提下计算准确的梯度。</li>
</ol>
<p>然而，在某些领域，特别是在基于物理的机器学习或几何深度学习中，这样的概念仍然非常重要。例如，在利用微分几何学的深度学习模型中，协变性和逆变性的区分可能在模型的设计和解释中发挥重要作用。</p>
<p>总之，在深度学习中，向量的基本概念被简化使用，但在更复杂的数学概念对于高级模型设计和特殊应用领域仍然是重要的。</p>
<div class="callout callout-style-default callout-note callout-titled" title="点击查看内容（深入探讨：向量空间和线性组合）">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-1-contents" aria-controls="callout-1" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
点击查看内容（深入探讨：向量空间和线性组合）
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-1" class="callout-1-contents callout-collapse collapse">
<section id="向量空间与线性组合" class="level3 callout-body-container callout-body">
<h3 class="anchored" data-anchor-id="向量空间与线性组合">向量空间与线性组合</h3>
<p>向量空间（vector space）是线性代数的核心概念，为深度学习中数据的表示和转换提供了基本框架。在此次深入探讨中，我们将仔细研究向量空间的严格定义及其相关概念，并提供在深度学习中的应用示例。</p>
<section id="向量空间-vector-space" class="level4">
<h4 class="anchored" data-anchor-id="向量空间-vector-space">向量空间 (Vector Space)</h4>
<p>向量空间是由满足以下8条公理（axiom）的集合<span class="math inline">\(V\)</span>和加法（addition）及标量乘法（scalar multiplication）运算组成。其中，<span class="math inline">\(V\)</span>的元素称为向量（vector），而标量（scalar）是实数集<span class="math inline">\(\mathbb{R}\)</span>或复数集<span class="math inline">\(\mathbb{C}\)</span>中的元素。（深度学习中主要使用实数）</p>
<p><strong>向量加法 (Vector Addition):</strong> 对于<span class="math inline">\(V\)</span>中的任意两个元素<span class="math inline">\(\mathbf{u}, \mathbf{v}\)</span>，<span class="math inline">\(\mathbf{u} + \mathbf{v}\)</span>也是<span class="math inline">\(V\)</span>的元素。 （对加法封闭，closed under addition）</p>
<p><strong>标量乘法 (Scalar Multiplication):</strong> 对于<span class="math inline">\(V\)</span>中的任意元素<span class="math inline">\(\mathbf{u}\)</span>和标量<span class="math inline">\(c\)</span>，<span class="math inline">\(c\mathbf{u}\)</span>也是<span class="math inline">\(V\)</span>的元素。（对标量乘法封闭，closed under scalar multiplication）</p>
<p><strong>向量加法和标量乘法必须满足以下8条公理。</strong> (<span class="math inline">\(\mathbf{u}, \mathbf{v}, \mathbf{w} \in V\)</span>, <span class="math inline">\(c, d\)</span>: 标量)</p>
<ol type="1">
<li><strong>加法的交换律 (Commutativity of addition):</strong> <span class="math inline">\(\mathbf{u} + \mathbf{v} = \mathbf{v} + \mathbf{u}\)</span></li>
<li><strong>加法的结合律 (Associativity of addition):</strong> <span class="math inline">\((\mathbf{u} + \mathbf{v}) + \mathbf{w} = \mathbf{u} + (\mathbf{v} + \mathbf{w})\)</span></li>
<li><strong>加法的单位元 (Additive identity):</strong> 存在<span class="math inline">\(\mathbf{0} \in V\)</span>（零向量，zero vector），使得对于所有<span class="math inline">\(\mathbf{u} \in V\)</span>有<span class="math inline">\(\mathbf{u} + \mathbf{0} = \mathbf{u}\)</span>。</li>
<li><strong>加法的逆元 (Additive inverse):</strong> 对于每个<span class="math inline">\(\mathbf{u} \in V\)</span>，存在<span class="math inline">\(-\mathbf{u} \in V\)</span>（加法的逆元），使得<span class="math inline">\(\mathbf{u} + (-\mathbf{u}) = \mathbf{0}\)</span>。</li>
<li><strong>标量乘法对向量加法的分配律 (Distributivity of scalar multiplication with respect to vector addition):</strong> <span class="math inline">\(c(\mathbf{u} + \mathbf{v}) = c\mathbf{u} + c\mathbf{v}\)</span></li>
<li><strong>标量乘法对标量加法的分配律 (Distributivity of scalar multiplication with respect to scalar addition):</strong> <span class="math inline">\((c + d)\mathbf{u} = c\mathbf{u} + d\mathbf{u}\)</span></li>
<li><strong>标量乘法与标量乘法的相容性 (Compatibility of scalar multiplication with scalar multiplication):</strong> <span class="math inline">\(c(d\mathbf{u}) = (cd)\mathbf{u}\)</span></li>
<li><strong>标量乘法的单位元 (Identity element of scalar multiplication):</strong> <span class="math inline">\(1\mathbf{u} = \mathbf{u}\)</span> （这里的1是标量乘法的单位元）</li>
</ol>
<p><strong>示例:</strong> * <span class="math inline">\(\mathbb{R}^n\)</span>: <span class="math inline">\(n\)</span>维实数向量空间 (n-tuples of real numbers) * <span class="math inline">\(\mathbb{C}^n\)</span>: <span class="math inline">\(n\)</span>维复数向量空间 * <span class="math inline">\(M_{m \times n}(\mathbb{R})\)</span>: <span class="math inline">\(m \times n\)</span> 实数矩阵空间 * <span class="math inline">\(P_n\)</span>: 次数不超过<span class="math inline">\(n\)</span>的实系数多项式空间 * <span class="math inline">\(C[a, b]\)</span>: 区间 <span class="math inline">\([a, b]\)</span> 上连续的实值函数的空间</p>
</section>
<section id="子空间-subspace" class="level4">
<h4 class="anchored" data-anchor-id="子空间-subspace">子空间 (Subspace)</h4>
<p>向量空间 <span class="math inline">\(V\)</span> 的子集 <span class="math inline">\(W\)</span> 如果满足以下条件，则称 <span class="math inline">\(W\)</span> 为 <span class="math inline">\(V\)</span> 的子空间。</p>
<ol type="1">
<li><span class="math inline">\(\mathbf{0} \in W\)</span> (包含零向量)</li>
<li><span class="math inline">\(\mathbf{u}, \mathbf{v} \in W\)</span> 则，<span class="math inline">\(\mathbf{u} + \mathbf{v} \in W\)</span> (关于加法封闭)</li>
<li><span class="math inline">\(\mathbf{u} \in W\)</span> 并且 <span class="math inline">\(c\)</span> 是标量，则 <span class="math inline">\(c\mathbf{u} \in W\)</span> (关于标量乘法封闭)</li>
</ol>
<p>也就是说，子空间是向量空间的子集，并且它本身也满足向量空间的性质。</p>
</section>
<section id="线性组合-linear-combination" class="level4">
<h4 class="anchored" data-anchor-id="线性组合-linear-combination">线性组合 (Linear Combination)</h4>
<p>对于向量空间 <span class="math inline">\(V\)</span> 中的向量 <span class="math inline">\(\mathbf{v}_1, \mathbf{v}_2, ..., \mathbf{v}_k\)</span> 和标量 <span class="math inline">\(c_1, c_2, ..., c_k\)</span>，以下形式的表达式称为线性组合。</p>
<p><span class="math inline">\(c_1\mathbf{v}_1 + c_2\mathbf{v}_2 + ... + c_k\mathbf{v}_k\)</span></p>
</section>
<section id="线性独立-linear-independence-和-线性依赖-linear-dependence" class="level4">
<h4 class="anchored" data-anchor-id="线性独立-linear-independence-和-线性依赖-linear-dependence">线性独立 (Linear Independence) 和 线性依赖 (Linear Dependence)</h4>
<p>向量集合 {<span class="math inline">\(\mathbf{v}_1, \mathbf{v}_2, ..., \mathbf{v}_k\)</span>} 如果满足以下条件，则称为 <em>线性独立</em>：</p>
<p><span class="math inline">\(c_1\mathbf{v}_1 + c_2\mathbf{v}_2 + ... + c_k\mathbf{v}_k = \mathbf{0}\)</span> 时，必须有 <span class="math inline">\(c_1 = c_2 = ... = c_k = 0\)</span></p>
<p>如果上述条件不满足（即存在不是全为零的标量 <span class="math inline">\(c_1, ..., c_k\)</span> 能使上式成立），则该向量集合称为 <em>线性依赖</em>。</p>
<p><strong>直观意义:</strong></p>
<ul>
<li><strong>线性独立:</strong> 可以将向量视为 “朝不同方向” 延伸。任何向量都不能用其他向量的线性组合表示。</li>
<li><strong>线性依赖:</strong> 可以认为某些向量 “位于同一方向” (或 “平面”, “超平面”)。有些向量可以用其他向量的线性组合表示。</li>
</ul>
</section>
<section id="基-basis-和-维数-dimension" class="level4">
<h4 class="anchored" data-anchor-id="基-basis-和-维数-dimension">基 (Basis) 和 维数 (Dimension)</h4>
<ul>
<li><strong>基 (Basis):</strong> 向量空间 <span class="math inline">\(V\)</span> 的 <em>基</em> 是满足以下两个条件的向量集合。
<ol type="1">
<li>线性独立</li>
<li>span <span class="math inline">\(V\)</span> (参见下面的 span 解释)</li>
</ol></li>
<li><strong>维数 (Dimension):</strong> 基中包含的向量的数量称为 <em>维数</em>。 (dim <span class="math inline">\(V\)</span>)</li>
</ul>
<p><strong>关键:</strong> 给定的向量空间的基不是唯一的，但所有基都具有相同数量的向量。</p>
</section>
<section id="span" class="level4">
<h4 class="anchored" data-anchor-id="span">Span</h4>
<p>向量集合 {<span class="math inline">\(\mathbf{v}_1, \mathbf{v}_2, ..., \mathbf{v}_k\)</span>} 的 <em>span</em> 是这些向量的所有可能线性组合的集合。</p>
<p>span{<span class="math inline">\(\mathbf{v}_1, \mathbf{v}_2, ..., \mathbf{v}_k\)</span>} = {<span class="math inline">\(c_1\mathbf{v}_1 + c_2\mathbf{v}_2 + ... + c_k\mathbf{v}_k\)</span> | <span class="math inline">\(c_1, c_2, ..., c_k\)</span> 是标量}</p>
<p>也就是说，给定向量可以生成的所有向量的集合。 Span 始终是一个子空间。 #### 深度学习中的向量空间示例</p>
<ul>
<li><strong>特征向量 (Feature Vector):</strong> 图像、文本、音频等深度学习模型的输入数据通常表示为高维向量。例如，28x28 像素大小的灰度图像可以表示为 784 维向量。每个维度表示图像中特定像素的亮度值。</li>
<li><strong>权重向量 (Weight Vector):</strong> 神经网络的每一层(layer)由权重矩阵(weight matrix)和偏置向量(bias vector)组成。权重矩阵的每一行（或列）可以看作是一个特定神经元的权重向量。</li>
<li><strong>嵌入向量 (Embedding Vector):</strong> 用于将单词、用户、项目等表示为低维向量空间中的点。Word2Vec、GloVe、BERT 等是典型的将单词表示为向量的嵌入技术。</li>
<li><strong>潜在空间 (Latent Space):</strong> 自动编码器(Autoencoder)、变分自动编码器(Variational Autoencoder, VAE)、生成对抗网络(Generative Adversarial Network, GAN)等学习将数据映射到低维潜在空间的方法。这个潜在空间也可以看作是一个向量空间。</li>
</ul>
</section>
</section>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled" title="点击以查看内容（深入探讨：范数与距离 - 深度学习视角）">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-2-contents" aria-controls="callout-2" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
点击以查看内容（深入探讨：范数与距离 - 深度学习视角）
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-2" class="callout-2-contents callout-collapse collapse">
<section id="深度学习中的范数和距离" class="level3 callout-body-container callout-body">
<h3 class="anchored" data-anchor-id="深度学习中的范数和距离">深度学习中的范数和距离</h3>
<p>测量向量的大小(magnitude)或两个向量之间的距离(distance)在深度学习中非常重要。它们被应用于损失函数、正则化(regularization)、相似性度量等各个领域。</p>
<section id="范数-norm" class="level4">
<h4 class="anchored" data-anchor-id="范数-norm">范数 (Norm)</h4>
<p>向量 <span class="math inline">\(\mathbf{x} = [x_1, x_2, ..., x_n]\)</span> 的 Lp-范数定义如下 (<span class="math inline">\(p \ge 1\)</span>)。</p>
<p><span class="math inline">\(||\mathbf{x}||_p = \left( \sum_{i=1}^{n} |x_i|^p \right)^{1/p}\)</span></p>
<ul>
<li><strong>L1-范数 (<span class="math inline">\(p=1\)</span>):</strong> <span class="math inline">\(||\mathbf{x}||_1 = \sum_{i=1}^{n} |x_i|\)</span> (曼哈顿距离, 出租车范数)
<ul>
<li><strong>特点:</strong> 各个元素的绝对值之和。当特征向量中每个元素的大小都很重要时非常有用。</li>
<li><strong>深度学习应用:</strong> L1 正则化 (Lasso 回归) 通过限制权重的绝对值总和来创建稀疏(sparse)模型（部分权重为0）。</li>
</ul></li>
<li><strong>L2-范数 (<span class="math inline">\(p=2\)</span>):</strong> <span class="math inline">\(||\mathbf{x}||_2 = \sqrt{\sum_{i=1}^{n} x_i^2}\)</span> (欧几里得范数)
<ul>
<li><strong>特点:</strong> 从原点到向量坐标的直线距离（勾股定理）。最常用的范数。</li>
<li><strong>深度学习应用:</strong> L2 正则化 (Ridge 回归) 通过限制权重的平方和来防止权重变得过大(防止过拟合)。也称为权重衰减(weight decay)。</li>
</ul></li>
<li><strong>L∞-范数 (<span class="math inline">\(p \to \infty\)</span>):</strong> <span class="math inline">\(||\mathbf{x}||_\infty = \max_i |x_i|\)</span>
<ul>
<li><strong>特点:</strong> 向量元素中绝对值最大的值。</li>
<li><strong>深度学习应用:</strong> （不太常见）当希望限制某个元素的值过大时使用。</li>
</ul></li>
</ul>
</section>
<section id="距离-distance" class="level4">
<h4 class="anchored" data-anchor-id="距离-distance">距离 (Distance)</h4>
<p>两个向量 <span class="math inline">\(\mathbf{x}\)</span> 和 <span class="math inline">\(\mathbf{y}\)</span> 之间的距离通常定义为两向量差的范数。</p>
<p><span class="math inline">\(d(\mathbf{x}, \mathbf{y}) = ||\mathbf{x} - \mathbf{y}||\)</span></p>
<ul>
<li><strong>L1 距离:</strong> <span class="math inline">\(d(\mathbf{x}, \mathbf{y}) = ||\mathbf{x} - \mathbf{y}||_1 = \sum_{i=1}^{n} |x_i - y_i|\)</span></li>
<li><strong>L2 距离:</strong> <span class="math inline">\(d(\mathbf{x}, \mathbf{y}) = ||\mathbf{x} - \mathbf{y}||_2 = \sqrt{\sum_{i=1}^{n} (x_i - y_i)^2}\)</span></li>
</ul>
<p><strong>深度学习中的应用示例:</strong></p>
<ul>
<li><strong>损失函数:</strong> MSE (L2 损失), MAE (L1 损失)</li>
<li><strong>正则化:</strong> L1 正则化, L2 正则化 (权重衰减)</li>
<li><strong>基于相似性/距离的学习:</strong> k-NN, SVM, Siamese 网络, Triplet 网络, 对比学习</li>
<li><strong>嵌入:</strong> 将单词、用户、项目等表示在向量空间中，并通过向量之间的距离来衡量相似性/相关性</li>
<li><strong>异常检测 (Outlier Detection):</strong> 基于数据点之间的距离进行异常检测。</li>
</ul>
<p><strong>参考:</strong> 在深度学习中，区分“距离”和“相似度(similarity)”非常重要。距离越小相似度越高，而相似度越大则表示越接近。余弦相似度(cosine similarity)是深度学习中常用的相似性度量方法之一。</p>
</section>
</section>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled" title="点击查看内容（深入探讨：仿射空间）">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-3-contents" aria-controls="callout-3" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
点击查看内容（深入探讨：仿射空间）
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-3" class="callout-3-contents callout-collapse collapse">
<section id="仿射空间-affine-space" class="level3 callout-body-container callout-body">
<h3 class="anchored" data-anchor-id="仿射空间-affine-space">仿射空间 (Affine Space)</h3>
<p>仿射空间(Affine Space)是线性代数中向量空间(Vector Space)概念的推广，在几何学视角下，它是理解深度学习模型的有效工具。特别是，仿射变换(Affine Transformation)表示在深度学习中常用的线性变换加上偏置(bias)的形式。</p>
<section id="仿射空间的定义" class="level4">
<h4 class="anchored" data-anchor-id="仿射空间的定义">仿射空间的定义</h4>
<p>仿射空间是由（点集、向量空间、点与向量的加法）三个要素构成的结构。具体来说，</p>
<ul>
<li><strong>点集 (<span class="math inline">\(\mathcal{A}\)</span>):</strong> 几何对象(点)的集合。与向量空间不同，<em>没有固定的原点(origin)</em>。</li>
<li><strong>向量空间 (<span class="math inline">\(V\)</span>):</strong> 表示点之间<em>位移(displacement)</em>或<em>差值(difference)</em>的向量集。满足向量空间的所有性质（加法、标量乘法、八条公理）。</li>
<li><strong>点与向量的加法 (<span class="math inline">\(\mathcal{A} \times V \to \mathcal{A}\)</span>):</strong> 将点 <span class="math inline">\(P \in \mathcal{A}\)</span> 和向量 <span class="math inline">\(\mathbf{v} \in V\)</span> 相加得到新的点 <span class="math inline">\(Q \in \mathcal{A}\)</span> 的操作。记作 <span class="math inline">\(Q = P + \mathbf{v}\)</span>。</li>
</ul>
<p>此加法运算必须满足以下两个性质：</p>
<ol type="1">
<li><strong>对于任意的点 <span class="math inline">\(P \in \mathcal{A}\)</span>，有 <span class="math inline">\(P + \mathbf{0} = P\)</span> (其中 <span class="math inline">\(\mathbf{0}\)</span> 是向量空间 <span class="math inline">\(V\)</span> 的零向量)</strong></li>
<li><strong>对于任意的点 <span class="math inline">\(P, Q, R \in \mathcal{A}\)</span>，有 <span class="math inline">\((P + \mathbf{u}) + \mathbf{v} = P + (\mathbf{u} + \mathbf{v})\)</span> (其中 <span class="math inline">\(\mathbf{u}, \mathbf{v} \in V\)</span>)</strong></li>
</ol>
<p><strong>重要特征</strong></p>
<ul>
<li>仿射空间中没有“原点”这样的特殊点。所有点都是等价的。</li>
<li>两点 <span class="math inline">\(P, Q \in \mathcal{A}\)</span> 的“差值”用向量空间 <span class="math inline">\(V\)</span> 中的向量表示：<span class="math inline">\(\overrightarrow{PQ} = Q - P \in V\)</span>。（但两点的“和”是未定义的。）</li>
<li>通过点与向量的加法，可以从一个点移动到另一个点。</li>
</ul>
</section>
<section id="仿射组合-affine-combination" class="level4">
<h4 class="anchored" data-anchor-id="仿射组合-affine-combination">仿射组合 (Affine Combination)</h4>
<p>给定仿射空间 <span class="math inline">\(\mathcal{A}\)</span> 中的点 <span class="math inline">\(P_1, P_2, ..., P_k\)</span> 和标量 <span class="math inline">\(c_1, c_2, ..., c_k\)</span>，以下形式的表达式称为仿射组合。</p>
<p><span class="math inline">\(c_1P_1 + c_2P_2 + ... + c_kP_k\)</span> (其中，<span class="math inline">\(c_1 + c_2 + ... + c_k = 1\)</span>)</p>
<p><strong>重要:</strong> 与一般的线性组合不同，仿射组合中<em>系数的和必须为1</em>。这一条件反映了仿射空间“没有原点”的性质。</p>
</section>
<section id="仿射变换-affine-transformation" class="level4">
<h4 class="anchored" data-anchor-id="仿射变换-affine-transformation">仿射变换 (Affine Transformation)</h4>
<p>仿射变换是从一个仿射空间到另一个仿射空间的函数，可以表示为线性变换和平移(translation)的组合。也就是说，仿射变换包含<em>线性变换</em>和<em>偏置(bias)</em>。</p>
<p><span class="math inline">\(f(P) = T(P) + \mathbf{b}\)</span></p>
<ul>
<li><span class="math inline">\(T\)</span>: 线性变换 (从向量空间 <span class="math inline">\(V\)</span> 到 <span class="math inline">\(V\)</span> 的线性变换)</li>
<li><span class="math inline">\(\mathbf{b}\)</span>: 平移向量 (向量空间 <span class="math inline">\(V\)</span> 中的元素)</li>
</ul>
<p><strong>矩阵表示:</strong></p>
<p>仿射变换可以使用扩展矩阵(augmented matrix)来表示。在 <span class="math inline">\(n\)</span> 维仿射空间中，通过使用 <span class="math inline">\((n+1)\)</span> 维向量，可以用 <span class="math inline">\((n+1) \times (n+1)\)</span> 矩阵来表示仿射变换。 <span class="math inline">\(\begin{bmatrix} \mathbf{y} \\ 1 \end{bmatrix} = \begin{bmatrix} \mathbf{A} &amp; \mathbf{b} \\ \mathbf{0}^T &amp; 1 \end{bmatrix} \begin{bmatrix} \mathbf{x} \\ 1 \end{bmatrix}\)</span></p>
<ul>
<li><span class="math inline">\(\mathbf{A}\)</span>: <span class="math inline">\(n \times n\)</span> 线性变换矩阵</li>
<li><span class="math inline">\(\mathbf{b}\)</span>: <span class="math inline">\(n\)</span>维平移向量</li>
<li><span class="math inline">\(\mathbf{x}\)</span>: <span class="math inline">\(n\)</span>维输入向量（仿射空间中的点）</li>
<li><span class="math inline">\(\mathbf{y}\)</span>: <span class="math inline">\(n\)</span>维输出向量（仿射空间中的点）</li>
</ul>
</section>
<section id="深度学习中的仿射空间和仿射变换" class="level4">
<h4 class="anchored" data-anchor-id="深度学习中的仿射空间和仿射变换">深度学习中的仿射空间和仿射变换</h4>
<ul>
<li><strong>全连接层:</strong> 深度学习的全连接层（密集层）执行仿射变换。在 <span class="math inline">\(\mathbf{y} = \mathbf{W}\mathbf{x} + \mathbf{b}\)</span> 中，<span class="math inline">\(\mathbf{W}\mathbf{x}\)</span> 表示线性变换，而 <span class="math inline">\(\mathbf{b}\)</span> 表示偏置（平移）。</li>
<li><strong>输入空间:</strong> 深度学习模型的输入数据通常表示为高维向量，但严格来说可以被视为没有原点的仿射空间中的点。例如，图像数据可以用一个包含每个像素亮度值的向量来表示，但这个向量空间没有特别的原点。</li>
<li><strong>特征空间 (Feature Space):</strong> 神经网络的每一层将输入转换为新的特征空间。这种变换通常由线性变换（+偏置）和非线性激活函数的组合组成。</li>
<li><strong>数据增强 (Data Augmentation):</strong> 图像数据上的旋转、平移、缩放等可以表示为仿射变换。</li>
<li><strong>仿射层</strong>: 与线性变换不同，考虑了偏置。</li>
</ul>
</section>
<section id="不使用偏置的深度学习模型" class="level4">
<h4 class="anchored" data-anchor-id="不使用偏置的深度学习模型">不使用偏置的深度学习模型</h4>
<p>最近的深度学习研究中，基于计算效率、模型可解释性或特定理论背景，有时会提出不使用偏置（bias）项的模型。</p>
<ul>
<li><strong>DeepMind 的 MuZero (2020):</strong> 强化学习模型 MuZero 在策略网络和价值网络中不使用偏置。论文指出，去除偏置有助于表示学习。</li>
<li><strong>OpenAI 的 GPT 系列</strong>: 在某些研究和实现中，为了计算效率而移除偏置项。但是，并不是所有的 GPT 系列模型都 <em>不</em> 使用偏置。例如，在大规模的 GPT-3 模型中，仍然经常使用偏置。</li>
<li><strong>无偏网络 (No-Bias Networks):</strong> 一些研究系统地分析了去除偏置对模型泛化性能的影响。</li>
</ul>
<p><strong>去除偏置的原因</strong></p>
<ul>
<li><strong>计算效率:</strong> 去除偏置项可以减少模型的参数数量，从而降低计算量和内存使用。特别是对于大规模模型，这种效果可能会更加显著。</li>
<li><strong>表示学习 (Representation Learning):</strong> 在某些问题中，偏置项可能是不必要的，甚至可能妨碍表示学习。例如，在 MuZero 中，认为无偏的表示有助于学习更抽象且更具泛化的表示。</li>
<li><strong>理论/数学依据:</strong> 对于某些模型（如特定类型的生成模型），无偏形式在数学上可能更为自然，或者更适合特定的理论分析。</li>
<li><strong>正则化效果</strong>: 有研究表明，没有偏置的情况下，权重矩阵可能会承载更重要的信息，从而产生一种正则化效果。 <strong>注意:</strong> 去除bias并不<em>总是</em>保证性能提升。根据问题的特性、模型的结构、数据量等因素，bias的存在与否对性能的影响可能不同。</li>
</ul>
<p>仿射空间和仿射变换的概念可以在深度学习模型的几何解释、泛化性能分析、新架构设计等方面得到应用。</p>
</section>
</section>
</div>
</div>
</section>
<section id="维度秩" class="level3">
<h3 class="anchored" data-anchor-id="维度秩">2.1.2 维度，秩</h3>
<p>张量、向量、矩阵相关的术语在数学、物理学、计算机科学领域中有些许不同的使用方式，可能会引起混淆。为了避免这种混淆，我们将主要概念整理如下。首先看看张量的秩和维度。张量的秩表示张量具有的索引数量。例如，标量是0阶张量，向量是1阶张量，矩阵是2阶张量。三维以上的张量通常直接称为张量。</p>
<p>“维度”这个术语有两层含义需要注意。第一种情况下，“维度”与张量的秩同义使用。此时将向量称为一维张量，矩阵称为二维张量。第二种情况下，“维度”用于表示数组的长度或大小。例如，向量 <span class="math inline">\(\mathbf{a} = [1, 2, 3, 4]\)</span> 的维度为4即属于这种情况。</p>
<p>了解不同领域术语使用的差异也很重要。在物理学中，元素的数量具有物理意义，因此使用更为严格。而在计算机科学中，向量、矩阵、张量主要被视为数字的数组，“维度”一词通常同时指数据数量和索引数量。</p>
<p>为了避免由于术语使用差异引起的混淆，需要注意以下几点。术语的意义会随上下文而变化，因此需要仔细解读。在论文或书籍中，需要明确区分“维度”的具体含义。特别是在深度学习领域，张量的秩和数组大小经常都用“维度”来表示，保持一致的解释非常重要。</p>
<p>在深度学习框架中，使用‘维度(dimension)’或‘轴(axis)’这两个术语来表示张量的形状(shape)。例如，在PyTorch中，可以通过 <code>tensor.shape</code> 或 <code>tensor.size()</code> 来查看张量各维度的大小。本书将把张量的秩(rank)称为“维度”，数组的长度/大小用shape的每个元素值或维度表示。</p>
</section>
<section id="线性变换的基础" class="level3">
<h3 class="anchored" data-anchor-id="线性变换的基础">2.1.3 线性变换的基础</h3>
<p>让我们探讨一下深度学习训练所需的数学知识。神经网络的核心运算——线性变换，在前向计算中可以非常简洁地表示。在本节中，我们将重点放在通过激活函数之前的基本线性运算上。</p>
<p>前向运算的基本形式如下：</p>
<p><span class="math display">\[\boldsymbol y = \boldsymbol x \boldsymbol W + \boldsymbol b\]</span></p>
<p>其中，<span class="math inline">\(\boldsymbol x\)</span> 是输入，<span class="math inline">\(\boldsymbol W\)</span> 是权重，<span class="math inline">\(\boldsymbol b\)</span> 是偏置，而 <span class="math inline">\(\boldsymbol y\)</span> 是输出。在神经网络的数学表示中，输入和输出通常用向量表示，权重用矩阵表示。偏置（<span class="math inline">\(\boldsymbol b\)</span>）有时可以用标量值表示，但更准确地说，它应该以与输出相同形式的向量来表示。</p>
<p><strong>矩阵和线性变换</strong></p>
<p>矩阵是表达线性变换的强大工具。线性变换是将向量空间中的一点映射到另一点的过程，这可以看作是对整个空间的变形。为了帮助直观理解这一概念，推荐观看 3Blue1Brown 的 “Linear transformations and matrices” 视频[1]。该视频以直观的方式解释了线性代数的基本概念，并清楚地展示了矩阵是如何改变空间的。</p>
<p>当输入数据 <span class="math inline">\(\boldsymbol x\)</span> 表示为向量时，它代表单个数据点，向量的长度即为特征的数量。然而，在实际训练过程中，通常会一次性处理多个数据。在这种情况下，输入变为 (n, m) 形式的矩阵 <span class="math inline">\(\boldsymbol X\)</span>，其中 n 是数据数量，m 是特征数量。</p>
<p>在实际的深度学习模型中，输入数据可以超过二维矩阵，呈现更高维度的张量形式。</p>
<ul>
<li>图像数据：(批次大小, 高度, 宽度, 通道) 形式的四维张量</li>
<li>视频数据：(批次大小, 帧数, 高度, 宽度, 通道) 形式的五维张量</li>
</ul>
<p>为了处理这种高维数据，神经网络使用各种形式的线性和非线性变换。 在反向传播过程中计算梯度，并将其逆序传递给每一层以更新参数。这一过程可能会变得复杂，但通过自动微分工具可以高效地完成。 线性变换是深度学习模型的基本组成部分，但实际模型的性能是通过与非线性激活函数的结合获得的。在下一节中，我们将探讨这种非线性如何增强模型的表现力。</p>
<div id="cell-10" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># if in Colab, plase don't run this and below code. just see the result video bleow the following cell.</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="co">#from manim import *  </span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="cell-11" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="op">%%</span>manim <span class="op">-</span>qh <span class="op">-</span>v WARNING LinearTransformations  </span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> manim <span class="im">import</span> <span class="op">*</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> manim <span class="im">import</span> config</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> LinearTransformations(ThreeDScene):</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> construct(<span class="va">self</span>):</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.set_camera_orientation(phi<span class="op">=</span><span class="dv">75</span> <span class="op">*</span> DEGREES, theta<span class="op">=-</span><span class="dv">45</span> <span class="op">*</span> DEGREES)</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>        axes <span class="op">=</span> ThreeDAxes(x_range<span class="op">=</span>[<span class="op">-</span><span class="dv">6</span>, <span class="dv">6</span>, <span class="dv">1</span>], y_range<span class="op">=</span>[<span class="op">-</span><span class="dv">6</span>, <span class="dv">6</span>, <span class="dv">1</span>], z_range<span class="op">=</span>[<span class="op">-</span><span class="dv">6</span>, <span class="dv">6</span>, <span class="dv">1</span>], x_length<span class="op">=</span><span class="dv">10</span>, y_length<span class="op">=</span><span class="dv">10</span>, z_length<span class="op">=</span><span class="dv">10</span>).set_color(GRAY)</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.add(axes)</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>        <span class="co"># --- 3D Linear Transformation (Rotation and Shear) ---</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>        title <span class="op">=</span> Text(<span class="st">"3D Linear Transformations"</span>, color<span class="op">=</span>BLACK).to_edge(UP)</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.play(Write(title))</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.wait(<span class="dv">1</span>)</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 1. Rotation around Z-axis</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>        text_rotation <span class="op">=</span> Text(<span class="st">"Rotation around Z-axis"</span>, color<span class="op">=</span>BLUE).scale(<span class="fl">0.7</span>).next_to(title, DOWN, buff<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.play(Write(text_rotation))</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>        cube <span class="op">=</span> Cube(side_length<span class="op">=</span><span class="dv">2</span>, fill_color<span class="op">=</span>BLUE, fill_opacity<span class="op">=</span><span class="fl">0.5</span>, stroke_color<span class="op">=</span>WHITE, stroke_width<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.play(Create(cube))</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.play(Rotate(cube, angle<span class="op">=</span>PI<span class="op">/</span><span class="dv">2</span>, axis<span class="op">=</span>OUT, about_point<span class="op">=</span>ORIGIN), run_time<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.wait(<span class="dv">1</span>)</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.play(FadeOut(text_rotation))</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 2. Shear</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>        text_shear <span class="op">=</span> Text(<span class="st">"Shear Transformation"</span>, color<span class="op">=</span>GREEN).scale(<span class="fl">0.7</span>).next_to(title, DOWN, buff<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.play(Write(text_shear))</span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Define the shear transformation matrix.  This shears in x relative to y, and in y relative to x.</span></span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a>        shear_matrix <span class="op">=</span> np.array([</span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a>            [<span class="dv">1</span>, <span class="fl">0.5</span>, <span class="dv">0</span>],</span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a>            [<span class="fl">0.5</span>, <span class="dv">1</span>, <span class="dv">0</span>],</span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a>            [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>]</span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a>        ])</span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.play(</span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a>            cube.animate.apply_matrix(shear_matrix),</span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a>            run_time<span class="op">=</span><span class="dv">2</span>,</span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb5-40"><a href="#cb5-40" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.wait(<span class="dv">1</span>)</span>
<span id="cb5-41"><a href="#cb5-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-42"><a href="#cb5-42" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Add transformed axes to visualize the shear</span></span>
<span id="cb5-43"><a href="#cb5-43" aria-hidden="true" tabindex="-1"></a>        transformed_axes <span class="op">=</span> axes.copy().apply_matrix(shear_matrix)</span>
<span id="cb5-44"><a href="#cb5-44" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.play(Create(transformed_axes), run_time<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb5-45"><a href="#cb5-45" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.wait(<span class="dv">1</span>)</span>
<span id="cb5-46"><a href="#cb5-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-47"><a href="#cb5-47" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.play(FadeOut(cube), FadeOut(transformed_axes), FadeOut(text_shear))</span>
<span id="cb5-48"><a href="#cb5-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-49"><a href="#cb5-49" aria-hidden="true" tabindex="-1"></a>        <span class="co"># --- 2D to 3D Transformation (Paraboloid) ---</span></span>
<span id="cb5-50"><a href="#cb5-50" aria-hidden="true" tabindex="-1"></a>        text_2d_to_3d <span class="op">=</span> Text(<span class="st">"2D to 3D: Paraboloid"</span>, color<span class="op">=</span>MAROON).scale(<span class="fl">0.7</span>).next_to(title, DOWN, buff<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb5-51"><a href="#cb5-51" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.play(Write(text_2d_to_3d))</span>
<span id="cb5-52"><a href="#cb5-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-53"><a href="#cb5-53" aria-hidden="true" tabindex="-1"></a>        square <span class="op">=</span> Square(side_length<span class="op">=</span><span class="dv">4</span>, fill_color<span class="op">=</span>MAROON, fill_opacity<span class="op">=</span><span class="fl">0.5</span>, stroke_color<span class="op">=</span>WHITE, stroke_width<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb5-54"><a href="#cb5-54" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.play(Create(square))</span>
<span id="cb5-55"><a href="#cb5-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-56"><a href="#cb5-56" aria-hidden="true" tabindex="-1"></a>        <span class="kw">def</span> paraboloid(point):  <span class="co"># Function for the transformation</span></span>
<span id="cb5-57"><a href="#cb5-57" aria-hidden="true" tabindex="-1"></a>            x, y, _ <span class="op">=</span> point</span>
<span id="cb5-58"><a href="#cb5-58" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> [x, y, <span class="fl">0.2</span> <span class="op">*</span> (x<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> y<span class="op">**</span><span class="dv">2</span>)]  <span class="co"># Adjust scaling factor (0.2) as needed</span></span>
<span id="cb5-59"><a href="#cb5-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-60"><a href="#cb5-60" aria-hidden="true" tabindex="-1"></a>        paraboloid_surface <span class="op">=</span> always_redraw(<span class="kw">lambda</span>: Surface(</span>
<span id="cb5-61"><a href="#cb5-61" aria-hidden="true" tabindex="-1"></a>            <span class="kw">lambda</span> u, v: axes.c2p(<span class="op">*</span>paraboloid(axes.p2c(np.array([u,v,<span class="dv">0</span>])))),</span>
<span id="cb5-62"><a href="#cb5-62" aria-hidden="true" tabindex="-1"></a>            u_range<span class="op">=</span>[<span class="op">-</span><span class="dv">2</span>, <span class="dv">2</span>],</span>
<span id="cb5-63"><a href="#cb5-63" aria-hidden="true" tabindex="-1"></a>            v_range<span class="op">=</span>[<span class="op">-</span><span class="dv">2</span>, <span class="dv">2</span>],</span>
<span id="cb5-64"><a href="#cb5-64" aria-hidden="true" tabindex="-1"></a>            resolution<span class="op">=</span>(<span class="dv">15</span>, <span class="dv">15</span>), <span class="co"># Added for smoothness</span></span>
<span id="cb5-65"><a href="#cb5-65" aria-hidden="true" tabindex="-1"></a>            fill_color<span class="op">=</span>MAROON,</span>
<span id="cb5-66"><a href="#cb5-66" aria-hidden="true" tabindex="-1"></a>            fill_opacity<span class="op">=</span><span class="fl">0.7</span>,</span>
<span id="cb5-67"><a href="#cb5-67" aria-hidden="true" tabindex="-1"></a>            stroke_color<span class="op">=</span>WHITE,</span>
<span id="cb5-68"><a href="#cb5-68" aria-hidden="true" tabindex="-1"></a>            stroke_width<span class="op">=</span><span class="fl">0.5</span></span>
<span id="cb5-69"><a href="#cb5-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-70"><a href="#cb5-70" aria-hidden="true" tabindex="-1"></a>        ).set_shade_in_3d(<span class="va">True</span>))</span>
<span id="cb5-71"><a href="#cb5-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-72"><a href="#cb5-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-73"><a href="#cb5-73" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.play(</span>
<span id="cb5-74"><a href="#cb5-74" aria-hidden="true" tabindex="-1"></a>            Transform(square, paraboloid_surface),</span>
<span id="cb5-75"><a href="#cb5-75" aria-hidden="true" tabindex="-1"></a>            run_time<span class="op">=</span><span class="dv">3</span>,</span>
<span id="cb5-76"><a href="#cb5-76" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb5-77"><a href="#cb5-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-78"><a href="#cb5-78" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.wait(<span class="dv">2</span>)</span>
<span id="cb5-79"><a href="#cb5-79" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.play(FadeOut(square), FadeOut(text_2d_to_3d))</span>
<span id="cb5-80"><a href="#cb5-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-81"><a href="#cb5-81" aria-hidden="true" tabindex="-1"></a>        <span class="co"># --- 3D to 2D Transformation (Projection) ---</span></span>
<span id="cb5-82"><a href="#cb5-82" aria-hidden="true" tabindex="-1"></a>        text_3d_to_2d <span class="op">=</span> Text(<span class="st">"3D to 2D: Projection"</span>, color<span class="op">=</span>PURPLE).scale(<span class="fl">0.7</span>).next_to(title, DOWN, buff<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb5-83"><a href="#cb5-83" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.play(Write(text_3d_to_2d))</span>
<span id="cb5-84"><a href="#cb5-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-85"><a href="#cb5-85" aria-hidden="true" tabindex="-1"></a>        sphere <span class="op">=</span> Sphere(radius<span class="op">=</span><span class="fl">1.5</span>, fill_color<span class="op">=</span>PURPLE, fill_opacity<span class="op">=</span><span class="fl">0.7</span>, stroke_color<span class="op">=</span>WHITE, stroke_width<span class="op">=</span><span class="dv">1</span>, resolution<span class="op">=</span>(<span class="dv">20</span>,<span class="dv">20</span>)).set_shade_in_3d(<span class="va">True</span>)</span>
<span id="cb5-86"><a href="#cb5-86" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.play(Create(sphere))</span>
<span id="cb5-87"><a href="#cb5-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-88"><a href="#cb5-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-89"><a href="#cb5-89" aria-hidden="true" tabindex="-1"></a>        <span class="kw">def</span> project_to_2d(mob, alpha):</span>
<span id="cb5-90"><a href="#cb5-90" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> p <span class="kw">in</span> mob.points:</span>
<span id="cb5-91"><a href="#cb5-91" aria-hidden="true" tabindex="-1"></a>                p[<span class="dv">2</span>] <span class="op">*=</span> (<span class="dv">1</span><span class="op">-</span>alpha)</span>
<span id="cb5-92"><a href="#cb5-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-93"><a href="#cb5-93" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.play(</span>
<span id="cb5-94"><a href="#cb5-94" aria-hidden="true" tabindex="-1"></a>            UpdateFromAlphaFunc(sphere, project_to_2d),</span>
<span id="cb5-95"><a href="#cb5-95" aria-hidden="true" tabindex="-1"></a>            run_time<span class="op">=</span><span class="dv">2</span></span>
<span id="cb5-96"><a href="#cb5-96" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb5-97"><a href="#cb5-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-98"><a href="#cb5-98" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.wait(<span class="dv">1</span>)</span>
<span id="cb5-99"><a href="#cb5-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-100"><a href="#cb5-100" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Show a circle representing the final projection </span></span>
<span id="cb5-101"><a href="#cb5-101" aria-hidden="true" tabindex="-1"></a>        circle <span class="op">=</span> Circle(radius<span class="op">=</span><span class="fl">1.5</span>, color<span class="op">=</span>PURPLE, fill_opacity<span class="op">=</span><span class="fl">0.7</span>, stroke_color <span class="op">=</span> WHITE, stroke_width<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb5-102"><a href="#cb5-102" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.add(circle)</span>
<span id="cb5-103"><a href="#cb5-103" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.wait(<span class="dv">1</span>)</span>
<span id="cb5-104"><a href="#cb5-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-105"><a href="#cb5-105" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.play(FadeOut(sphere), FadeOut(text_3d_to_2d), FadeOut(circle), FadeOut(title))</span>
<span id="cb5-106"><a href="#cb5-106" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-107"><a href="#cb5-107" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.wait(<span class="dv">1</span>)</span>
<span id="cb5-108"><a href="#cb5-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-109"><a href="#cb5-109" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> logging</span>
<span id="cb5-110"><a href="#cb5-110" aria-hidden="true" tabindex="-1"></a>logging.getLogger(<span class="st">"manim"</span>).setLevel(logging.WARNING)</span>
<span id="cb5-111"><a href="#cb5-111" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-112"><a href="#cb5-112" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">"__main__"</span>:</span>
<span id="cb5-113"><a href="#cb5-113" aria-hidden="true" tabindex="-1"></a>    config.video_dir <span class="op">=</span> <span class="st">"./"</span></span>
<span id="cb5-114"><a href="#cb5-114" aria-hidden="true" tabindex="-1"></a>    scene <span class="op">=</span> LinearTransformations()</span>
<span id="cb5-115"><a href="#cb5-115" aria-hidden="true" tabindex="-1"></a>    scene.render()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<video width="640" height="480" controls="">
<source src="../../../assets/videos/LinearTransformations.mp4" type="video/mp4">
<p>您的浏览器不支持 video 标签。 </p>
<p>线性变换是将一个向量空间映射到另一个向量空间的函数，同时保留向量空间的结构。这种变换可以通过矩阵运算表示，并在深度学习中发挥核心作用。上面的动画可视化了线性变换。</p>
<p>理解线性变换对于掌握神经网络的工作原理至关重要。例如，过拟合模型可能会过度扭曲输入空间，而相比之下，泛化良好的模型则可以执行更平滑的变换。在设计和优化深度学习模型时，几何直觉可能非常有用。</p>
<div class="callout callout-style-default callout-note callout-titled" title="点击以查看内容（深入探讨：线性变换的严格定义和附加性质）">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-4-contents" aria-controls="callout-4" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
点击以查看内容（深入探讨：线性变换的严格定义和附加性质）
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-4" class="callout-4-contents callout-collapse collapse">
<section id="线性变换的严格定义和额外性质" class="level3 callout-body-container callout-body">
<h3 class="anchored" data-anchor-id="线性变换的严格定义和额外性质">线性变换的严格定义和额外性质</h3>
<p>线性变换（Linear Transformation）是向量空间之间的函数，它保持向量空间的线性结构（加法和标量乘法）。在深度学习中，全连接层是线性变换的一个典型例子。</p>
<section id="线性变换的严格定义" class="level4">
<h4 class="anchored" data-anchor-id="线性变换的严格定义">线性变换的严格定义</h4>
<p>设 <span class="math inline">\(V\)</span> 和 <span class="math inline">\(W\)</span> 是向量空间，如果函数 <span class="math inline">\(T: V \to W\)</span> 满足以下两个条件，则称其为 <em>线性变换</em>：</p>
<ol type="1">
<li><strong>加法保持：</strong> 对任意 <span class="math inline">\(\mathbf{u}, \mathbf{v} \in V\)</span>，有 <span class="math inline">\(T(\mathbf{u} + \mathbf{v}) = T(\mathbf{u}) + T(\mathbf{v})\)</span></li>
<li><strong>标量乘法保持：</strong> 对任意 <span class="math inline">\(\mathbf{u} \in V\)</span> 和标量 <span class="math inline">\(c\)</span>，有 <span class="math inline">\(T(c\mathbf{u}) = cT(\mathbf{u})\)</span></li>
</ol>
<p>只有满足这两个条件的函数才能被称为线性变换。</p>
</section>
<section id="深度学习中的线性变换示例全连接层" class="level4">
<h4 class="anchored" data-anchor-id="深度学习中的线性变换示例全连接层">深度学习中的线性变换示例：全连接层</h4>
<p>深度学习中的全连接层（dense layer）是线性变换的一个典型例子。对于输入向量 <span class="math inline">\(\mathbf{x} \in \mathbb{R}^m\)</span> 和权重矩阵 <span class="math inline">\(\mathbf{W} \in \mathbb{R}^{n \times m}\)</span>，偏置向量 <span class="math inline">\(\mathbf{b} \in \mathbb{R}^n\)</span>，全连接层的运算可以表示为：</p>
<p><span class="math inline">\(\mathbf{y} = \mathbf{W}\mathbf{x} + \mathbf{b}\)</span></p>
<p>这里 <span class="math inline">\(\mathbf{y} \in \mathbb{R}^n\)</span> 是输出向量。<span class="math inline">\(\mathbf{W}\mathbf{x}\)</span> 部分对应于线性变换，而 <span class="math inline">\(\mathbf{b}\)</span> 表示为了进行仿射变换的平移（translation）。严格来说，包含偏置项的是 <em>仿射变换</em>，但在深度学习中通常也称为 <em>线性变换</em>。</p>
</section>
<section id="核-kernel-和值域-range" class="level4">
<h4 class="anchored" data-anchor-id="核-kernel-和值域-range">核 (Kernel) 和值域 (Range)</h4>
<p>对于线性变换 <span class="math inline">\(T: V \to W\)</span>：</p>
<ul>
<li><strong>核 (Kernel, 或零空间 Null Space):</strong> 从 <span class="math inline">\(V\)</span> 映射到 <span class="math inline">\(\mathbf{0}_W\)</span>（<span class="math inline">\(W\)</span> 的零向量）的所有向量的集合。
<ul>
<li><span class="math inline">\(\text{ker}(T) = \{\mathbf{v} \in V | T(\mathbf{v}) = \mathbf{0}_W \}\)</span></li>
<li><span class="math inline">\(\text{ker}(T)\)</span> 是 <span class="math inline">\(V\)</span> 的子空间。</li>
</ul></li>
<li><strong>值域 (Range, 或像 Image):</strong> 由 <span class="math inline">\(V\)</span> 中的所有向量经 <span class="math inline">\(T\)</span> 映射到的 <span class="math inline">\(W\)</span> 的部分集合。
<ul>
<li><span class="math inline">\(\text{range}(T) = \{T(\mathbf{v}) | \mathbf{v} \in V \}\)</span></li>
<li><span class="math inline">\(\text{range}(T)\)</span> 是 <span class="math inline">\(W\)</span> 的子空间。</li>
</ul></li>
</ul>
</section>
<section id="秩-零化度定理-rank-nullity-theorem" class="level4">
<h4 class="anchored" data-anchor-id="秩-零化度定理-rank-nullity-theorem">秩-零化度定理 (Rank-Nullity Theorem)</h4>
<p>对于线性变换 <span class="math inline">\(T: V \to W\)</span>，当 <span class="math inline">\(V\)</span> 为有限维向量空间时，有：</p>
<p><span class="math inline">\(\text{dim}(\text{ker}(T)) + \text{dim}(\text{range}(T)) = \text{dim}(V)\)</span></p>
<ul>
<li><span class="math inline">\(\text{dim}(\text{ker}(T))\)</span>: <span class="math inline">\(T\)</span> 的 <em>零化度</em> (nullity)</li>
<li><span class="math inline">\(\text{dim}(\text{range}(T))\)</span>: <span class="math inline">\(T\)</span> 的 <em>秩</em> (rank)</li>
</ul>
<p>即，输入空间的维数等于核的维数（零化度）和值域的维数（秩）之和。</p>
</section>
<section id="线性变换的矩阵表示-matrix-representation" class="level4">
<h4 class="anchored" data-anchor-id="线性变换的矩阵表示-matrix-representation">线性变换的矩阵表示 (Matrix Representation)</h4>
<p>有限维向量空间之间的线性变换总是可以用矩阵表示。设<span class="math inline">\(V\)</span>的基(basis)为{<span class="math inline">\(\mathbf{v}_1, \mathbf{v}_2, ..., \mathbf{v}_m\)</span>}，<span class="math inline">\(W\)</span>的基为{<span class="math inline">\(\mathbf{w}_1, \mathbf{w}_2, ..., \mathbf{w}_n\)</span>}，则线性变换<span class="math inline">\(T: V \to W\)</span>可以表示为一个<span class="math inline">\(n \times m\)</span>矩阵<span class="math inline">\(\mathbf{A}\)</span>：</p>
<p><span class="math inline">\(T(\mathbf{v}_j) = \sum_{i=1}^{n} a_{ij}\mathbf{w}_i\)</span> (对于<span class="math inline">\(j = 1, 2, ..., m\)</span>)</p>
<p>这里，<span class="math inline">\(a_{ij}\)</span>是矩阵<span class="math inline">\(\mathbf{A}\)</span>的第<span class="math inline">\(i\)</span>行第<span class="math inline">\(j\)</span>列元素。即，矩阵<span class="math inline">\(\mathbf{A}\)</span>的第<span class="math inline">\(j\)</span>列是将<span class="math inline">\(T(\mathbf{v}_j)\)</span>用<span class="math inline">\(W\)</span>的基表示时的系数。</p>
<p>向量<span class="math inline">\(\mathbf{v} \in V\)</span>可以用基{<span class="math inline">\(\mathbf{v}_1, \mathbf{v}_2, ..., \mathbf{v}_m\)</span>}的线性组合表示为<span class="math inline">\(\mathbf{v} = c_1\mathbf{v}_1 + c_2\mathbf{v}_2 + ... + c_m\mathbf{v}_m\)</span>，该向量的坐标可以表示为列向量<span class="math inline">\(\begin{bmatrix} c_1 \\ c_2 \\ \vdots \\ c_m \end{bmatrix}\)</span>。那么，</p>
<p><span class="math inline">\(T(\mathbf{v}) = \mathbf{A} \begin{bmatrix} c_1 \\ c_2 \\ \vdots \\ c_m \end{bmatrix}\)</span></p>
<p><strong>深度学习中的矩阵表示：</strong> 深度学习中全连接层的运算<span class="math inline">\(\mathbf{y} = \mathbf{W}\mathbf{x}\)</span>与线性变换的矩阵表示完全一致。</p>
</section>
</section>
</div>
</div>
</video></section>
<section id="张量运算" class="level3">
<h3 class="anchored" data-anchor-id="张量运算">2.1.4 张量运算</h3>
<blockquote class="blockquote">
<p><strong>挑战任务:</strong> 如何高效地表示和计算多维数据？</p>
<p><strong>研究者的苦恼:</strong> 深度学习早期，研究人员需要处理图像、文本、音频等各种形式的数据。这些数据难以用简单的向量或矩阵来表示，并且需要一种能够有效处理复杂数据结构的方法。此外，快速处理大规模数据的高效运算方法也是重要的课题。</p>
</blockquote>
<p>张量是深度学习中用于表示数据和模型参数的基本数学对象。它是标量、向量、矩阵的一般化概念，可以看作多维数组。根据其维度（dimension, rank），张量可分为以下几类：</p>
<ul>
<li>0维张量: 标量 (例如: 3.14)</li>
<li>1维张量: 向量 (例如: [1, 2, 3])</li>
<li>2维张量: 矩阵 (例如: [[1, 2], [3, 4]])</li>
<li>3维及以上: 高维张量</li>
</ul>
<p>在深度学习中，通常处理以下形式的张量。</p>
<ul>
<li><strong>输入数据:</strong>
<ul>
<li><strong>一般:</strong> (批次大小, 特征数)</li>
<li><strong>时序/文本:</strong> (批次大小, 序列长度, 特征数/嵌入维度)</li>
<li><strong>图像:</strong> (批次大小, 高度, 宽度, 通道)</li>
</ul></li>
<li><strong>权重 (Weights):</strong>
<ul>
<li><strong>全连接:</strong> (输入特征数, 输出特征数)</li>
<li><strong>卷积:</strong> (输出通道数, 输入通道数, 核高度, 核宽度)</li>
</ul></li>
<li><strong>输出数据 (Output/Prediction):</strong>
<ul>
<li><strong>分类 (Classification):</strong> (批次大小, 类别数)</li>
<li><strong>回归 (Regression):</strong> (批次大小, 输出维度)</li>
</ul></li>
<li><strong>偏置(Bias):</strong>
<ul>
<li><strong>全连接:</strong> (输出特征数,)</li>
<li><strong>卷积:</strong> (输出通道数,)</li>
</ul></li>
<li><strong>特征图 (Convolutional layers的输出):</strong> (批次大小, 输出通道数, 高度, 宽度)</li>
</ul>
<p>神经网络的基本线性变换如下。</p>
<p><span class="math inline">\(y_j = \sum\limits_{i} x_i w_{ij} + b_j\)</span></p>
<p>这里 <span class="math inline">\(i\)</span> 是输入的索引，<span class="math inline">\(j\)</span> 是输出的索引。用向量和矩阵形式表示则为：</p>
<p><span class="math inline">\(\boldsymbol x = \begin{bmatrix}x_{1} &amp; x_{2} &amp; \cdots &amp; x_{i} \end{bmatrix}\)</span></p>
<p><span class="math inline">\(\boldsymbol W = \begin{bmatrix}
w_{11} &amp; \cdots &amp; w_{1j} \
\vdots &amp; \ddots &amp; \vdots \
w_{i1} &amp; \cdots &amp; w_{ij}
\end{bmatrix}\)</span></p>
<p><span class="math inline">\(\boldsymbol b = \begin{bmatrix}b_{1} &amp; b_{2} &amp; \cdots &amp; b_{j} \end{bmatrix}\)</span></p>
<p><span class="math inline">\(\boldsymbol y = \boldsymbol x \boldsymbol W + \boldsymbol b\)</span></p>
<p>张量运算的主要特点如下。</p>
<ol type="1">
<li>广播: 使不同大小的张量之间的运算成为可能。</li>
<li>维度缩减: 可以通过 sum(), mean() 等操作减少张量的特定维度。</li>
<li>重塑(reshape): 改变张量的形状，转换为其他维度的张量。</li>
</ol>
<p>在神经网络学习中最重要的运算之一是梯度计算。主要的梯度计算如下。</p>
<ol type="1">
<li>输入的梯度: <span class="math inline">\(\frac{\partial \boldsymbol y}{\partial \boldsymbol{x}}\)</span></li>
<li>权重的梯度: <span class="math inline">\(\frac{\partial \boldsymbol y}{\partial \boldsymbol W}\)</span></li>
</ol>
<p>这些梯度分别表示输出对输入和权重变化的响应，是反向传播算法的核心。 张量运算构成了现代深度学习的基础，并通过利用GPU的高度并行处理，使得大规模模型的高效训练和推理成为可能。此外，张量运算的自动微分（automatic differentiation）使高效的梯度计算成为可能，成为了现代深度学习研究的重要突破。这不仅超越了简单的数值计算，还使模型的结构和学习过程本身成为了可编程的对象。关于张量运算的实际例子，我们将在第3章PyTorch中进一步探讨。</p>
</section>
<section id="奇异值分解和主成分分析" class="level3">
<h3 class="anchored" data-anchor-id="奇异值分解和主成分分析">2.1.5 奇异值分解和主成分分析</h3>
<p>奇异值分解(Singular Value Decomposition, SVD)和主成分分析(Principal Component Analysis, PCA)是强大的数学工具，用于降低高维数据的维度，并提取数据中固有的主要特征。</p>
<section id="奇异值分解-svd" class="level4">
<h4 class="anchored" data-anchor-id="奇异值分解-svd">奇异值分解 (SVD)</h4>
<p>SVD 是将任意 <span class="math inline">\(m \times n\)</span> 矩阵 <span class="math inline">\(\mathbf{A}\)</span> 分解为三个矩阵乘积的方法。</p>
<p><span class="math inline">\(\mathbf{A} = \mathbf{U\Sigma V^T}\)</span></p>
<p>其中，</p>
<ul>
<li><span class="math inline">\(\mathbf{U}\)</span>: <span class="math inline">\(m \times m\)</span> 的正交矩阵 (左奇异向量)</li>
<li><span class="math inline">\(\mathbf{\Sigma}\)</span>: <span class="math inline">\(m \times n\)</span> 的对角矩阵 (奇异值, singular values)</li>
<li><span class="math inline">\(\mathbf{V}\)</span>: <span class="math inline">\(n \times n\)</span> 的正交矩阵 (右奇异向量)</li>
</ul>
<p><strong>核心思想:</strong></p>
<ul>
<li><strong>奇异值:</strong> <span class="math inline">\(\mathbf{\Sigma}\)</span> 的对角元素 (<span class="math inline">\(\sigma_1 \ge \sigma_2 \ge \dots \ge \sigma_r &gt; 0\)</span>) 是矩阵 <span class="math inline">\(\mathbf{A}\)</span> 的奇异值(singular value)，表示数据在该轴(方向)上的分散程度。大的奇异值代表数据的重要特征，小的奇异值代表噪声或不重要的信息。</li>
<li><strong>降维:</strong> 使用 <span class="math inline">\(k\)</span> 个最大的奇异值及其对应的奇异向量来近似矩阵 <span class="math inline">\(\mathbf{A}\)</span> (<span class="math inline">\(\mathbf{A} \approx \mathbf{U}_k \mathbf{\Sigma}_k \mathbf{V}_k^T\)</span>)，可以在保持原数据主要特征的同时，将维度从 <span class="math inline">\(m \times n\)</span> 降低到 <span class="math inline">\(k\)</span>。</li>
</ul>
<p><strong>在深度学习中的应用:</strong></p>
<ul>
<li><strong>模型压缩:</strong> 对神经网络的权重矩阵进行 SVD 近似为低维矩阵，可以减小模型的大小并提高推理速度。特别是在基于 Transformer 的语言模型（如 BERT）中，有效减少嵌入矩阵的大小。</li>
<li><strong>推荐系统</strong>: 利用 SVD 可以提取用户和项目之间的潜在因子(latent factor)。
<ul>
<li><strong>潜在因子</strong>: 通过 SVD 分解用户和项目矩阵，可以将用户和项目表示为低维空间中的点。
<ul>
<li>用户的潜在因子: 表示用户的隐藏偏好。（例如：电影爱好者、喜欢动作片、喜欢浪漫喜剧等）</li>
<li>项目的潜在因子: 表示项目的隐藏特征。（例如：大片、演员A参演、大团圆结局等）</li>
</ul></li>
<li><strong>低维表示</strong>: 通过 SVD，可以将原本非常大的用户-项目矩阵近似为低维矩阵的乘积。</li>
<li><strong>推荐</strong>: 在低维空间中计算用户和项目的相似度或内积，以预测用户对特定项目的偏好概率。</li>
</ul></li>
</ul>
</section>
<section id="主成分分析-pca" class="level4">
<h4 class="anchored" data-anchor-id="主成分分析-pca">主成分分析 (PCA)</h4>
<p>PCA 是一种方法，用于找到最大化数据方差的方向（主成分, principal component），并将数据投影到低维空间。它与 SVD 密切相关，并通过数据的协方差矩阵(covariance matrix)的特征值分解(eigenvalue decomposition)来寻找主成分。</p>
<p><strong>PCA 步骤:</strong> 1. <strong>数据居中化(Data Centering):</strong> 将每个特征(feature)的平均值设为0。 2. <strong>协方差矩阵计算:</strong> 计算表示特征之间相关关系的协方差矩阵。 3. <strong>特征值分解:</strong> 计算协方差矩阵的特征值(eigenvalue)和特征向量(eigenvector)。 * 特征向量: 主成分的方向 * 特征值: 在相应主成分方向上的方差大小 4. <strong>选择主成分:</strong> 从最大的特征值对应的特征向量开始选择<span class="math inline">\(k\)</span>个。(将数据降维到<span class="math inline">\(k\)</span>维) 5. <strong>数据投影:</strong> 将数据投影到选定的<span class="math inline">\(k\)</span>个主成分上，以实现降维。</p>
<p><strong>在深度学习中的应用:</strong></p>
<ul>
<li><strong>数据预处理:</strong> 可以将图像、文本等高维数据投影到低维空间中作为深度学习模型的输入，从而减少计算成本并防止过拟合。特别是在图像分类问题中，通过PCA将高分辨率图像表示为低维形式可以提高模型训练速度。</li>
<li><strong>特征提取</strong>: 通过PCA提取的主成分是互不相关的，并且可以被解释为保留了数据最大方差的新特征(feature)。</li>
</ul>
<p><strong>SVD vs.&nbsp;PCA</strong></p>
<ul>
<li>SVD是一种<em>矩阵</em>分解技术，而PCA是一种<em>数据</em>降维技术。</li>
<li>可以使用SVD来实现PCA。(数据矩阵的SVD与协方差矩阵的特征值分解有关)</li>
<li>PCA需要将数据的平均值设为0的预处理过程，而SVD可以直接应用无需此过程。</li>
</ul>
<p>SVD和PCA是深度学习中用于高效表示数据并提高模型性能的重要数学工具。</p>
<div id="cell-16" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_02.pca <span class="im">import</span> visualize_pca</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>visualize_pca()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="02_深度学习的数学_files/figure-html/cell-6-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Explained variance ratio: 0.5705</code></pre>
</div>
</div>
<p>这个示例展示了PCA将复杂的二维结构投影到一维的能力。对于螺旋形数据，单个主成分无法捕捉所有变化，但可以捕捉数据的主要趋势。通过解释的方差比例，可以评估这种一维表示在多大程度上保留了原始数据的结构。</p>
<p>这些技术是强大的工具，可以从复杂的数据中提取重要的模式。</p>
<ol type="1">
<li>数据预处理：减少输入数据的维度</li>
<li>模型压缩：对权重矩阵进行有效近似</li>
<li>特征提取：识别和选择重要特征</li>
</ol>
<p>SVD和PCA是强大的工具，可以从高维数据中提取重要的模式，并简化复杂的数据结构。</p>
</section>
</section>
</section>
<section id="微积分和优化" class="level2">
<h2 class="anchored" data-anchor-id="微积分和优化">2.2 微积分和优化</h2>
<section id="链式法则" class="level3">
<h3 class="anchored" data-anchor-id="链式法则">2.2.1 链式法则</h3>
<blockquote class="blockquote">
<p><strong>挑战问题：</strong> 如何高效地计算复杂嵌套函数的导数？</p>
<p><strong>研究者的苦恼：</strong> 初期深度学习的研究人员必须使用反向传播算法来更新神经网络的权重。然而，由于神经网络是多层函数复杂连接的结构，因此计算每个权重关于损失函数的导数是一个非常困难的问题。特别是，随着层数加深，计算量呈指数级增长，导致学习效率低下。</p>
</blockquote>
<p>深度学习中最重要的微积分规则之一就是链式法则(chain rule)。链式法则是一个强大而优雅的规则，它允许我们将复合函数的导数表示为构成函数导数的乘积。将链式法则可视化可以更容易地理解其概念。例如，假设 <span class="math inline">\(z\)</span> 是 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 的函数，而 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 分别是 <span class="math inline">\(s\)</span> 和 <span class="math inline">\(t\)</span> 的函数。这种关系可以用树形图表示。</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../../../assets/images/02_01.chain_rule.png" class="img-fluid figure-img"></p>
<figcaption>链式法则</figcaption>
</figure>
</div>
<p>在这个图中，<span class="math inline">\(z\)</span> 关于 <span class="math inline">\(s\)</span> 的偏导数 <span class="math inline">\(\frac{\partial z}{\partial s}\)</span> 等于从 <span class="math inline">\(z\)</span> 到 <span class="math inline">\(s\)</span> 所有路径上的偏导数乘积的和。</p>
<p><span class="math inline">\(\frac{\partial z}{\partial s} = \frac{\partial z}{\partial x} \frac{\partial x}{\partial s} + \frac{\partial z}{\partial y} \frac{\partial y}{\partial s}\)</span></p>
<p>在这个公式中，</p>
<ul>
<li><span class="math inline">\(\frac{\partial z}{\partial x}\)</span> 和 <span class="math inline">\(\frac{\partial z}{\partial y}\)</span> 表示 <span class="math inline">\(z\)</span> 如何随 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 变化。</li>
<li><span class="math inline">\(\frac{\partial x}{\partial s}\)</span> 和 <span class="math inline">\(\frac{\partial y}{\partial s}\)</span> 表示 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 如何随 <span class="math inline">\(s\)</span> 变化。</li>
</ul>
<p>另一个例子是使用链式法则来表达全微分的情况。考虑 <span class="math inline">\(z\)</span> 是相互独立变量的函数时的情形。在这种情况下，链式法则简化为全微分的形式。 例如，当 <span class="math inline">\(z = f(x, y)\)</span> 且 <span class="math inline">\(x = g(s)\)</span>, <span class="math inline">\(y = h(t)\)</span> 时，如果 <span class="math inline">\(s\)</span> 和 <span class="math inline">\(t\)</span> 相互独立，则 <span class="math inline">\(z\)</span> 的全微分可以表示为：</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../../../assets/images/02_02_chain_rule.png" class="img-fluid figure-img"></p>
<figcaption>链式法则</figcaption>
</figure>
</div>
<p><span class="math inline">\(dz = \frac{\partial z}{\partial x}dx + \frac{\partial z}{\partial y}dy\)</span></p>
<p>这里 <span class="math inline">\(dx = \frac{\partial x}{\partial s}ds\)</span> 和 <span class="math inline">\(dy = \frac{\partial y}{\partial t}dt\)</span>，因此最终形式如下：</p>
<p><span class="math inline">\(dz = \frac{\partial z}{\partial x}\frac{\partial x}{\partial s}ds + \frac{\partial z}{\partial y}\frac{\partial y}{\partial t}dt\)</span></p>
<p>这个表达式虽然看起来与链式法则的形式相似，但实际上表示的是全微分。这里的关键点是 <span class="math inline">\(s\)</span> 和 <span class="math inline">\(t\)</span> 是独立的，因此 <span class="math inline">\(\frac{\partial x}{\partial t}\)</span> 和 <span class="math inline">\(\frac{\partial y}{\partial s}\)</span> 为 0。这种形式即为全微分。全微分表示所有独立变量的变化对函数值产生的总影响，并可表示为各变量偏导数的和。 链式法则的这种结构使得可以将复杂函数的导数分解为更简单的部分。这在深度学习中尤其重要，因为神经网络是由多个层次的函数叠加而成的结构。使用树形图可以在更复杂的情况下轻松应用链式法则。从依赖变量开始，经过中间变量，到达独立变量的所有路径，然后沿着每条路径将偏导数相乘，最后将这些结果相加即可。</p>
<p>链式法则是深度学习中反向传播算法的数学基础。它为能够有效地更新复杂神经网络模型的权重提供了根本支持。</p>
</section>
<section id="梯度和雅可比矩阵" class="level3">
<h3 class="anchored">2.2.2 梯度和雅可比矩阵</h3>
<blockquote class="blockquote">
<p><strong>挑战任务</strong>: 如何对具有不同输入输出形式的函数进行微分的一般化？</p>
<p><strong>研究者的困扰</strong>: 早期深度学习主要处理标量函数，但逐渐扩展到处理具有各种形态（向量、矩阵等）的输入输出函数。以统一的方式表示和计算这些函数的导数是开发深度学习框架的关键任务。</p>
</blockquote>
<p>在深度学习中，我们处理具有不同形式的输入（标量、向量、矩阵、张量）和输出（标量、向量、矩阵、张量）的函数。因此，函数的微分（导数）表示也会有所不同。关键在于以一致的方式表达这些不同的情况，并应用链式法则(chain rule)高效计算。</p>
<section id="核心概念" class="level4">
<h4 class="anchored" data-anchor-id="核心概念">核心概念</h4>
<ul>
<li><p><strong>梯度(Gradient):</strong> 用于对标量函数关于向量求导的表示。它是一个包含输入向量每个元素的偏导数的列向量，表示函数最陡峭的上升方向。</p></li>
<li><p><strong>雅可比矩阵(Jacobian Matrix):</strong> 用于对向量函数关于向量求导的表示。它是输出向量的每个元素对输入向量的每个元素进行偏导数的结果构成的矩阵。</p></li>
</ul>
</section>
<section id="不同输入输出形式下的导数表示" class="level4">
<h4 class="anchored" data-anchor-id="不同输入输出形式下的导数表示">不同输入输出形式下的导数表示</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 14%">
<col style="width: 12%">
<col style="width: 57%">
<col style="width: 15%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">输入形式</th>
<th style="text-align: left;">输出形式</th>
<th style="text-align: left;">导数表示</th>
<th style="text-align: left;">维度</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">向量 (<span class="math inline">\(\mathbf{x}\)</span>)</td>
<td style="text-align: left;">向量 (<span class="math inline">\(\mathbf{f}\)</span>)</td>
<td style="text-align: left;">雅可比矩阵 (<span class="math inline">\(\mathbf{J} = \frac{\partial \mathbf{f}}{\partial \mathbf{x}}\)</span>)</td>
<td style="text-align: left;"><span class="math inline">\(n \times m\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">矩阵 (<span class="math inline">\(\mathbf{X}\)</span>)</td>
<td style="text-align: left;">向量 (<span class="math inline">\(\mathbf{f}\)</span>)</td>
<td style="text-align: left;">3维张量 (通常不常用)</td>
<td style="text-align: left;">-</td>
</tr>
<tr class="odd">
<td style="text-align: left;">向量 (<span class="math inline">\(\mathbf{x}\)</span>)</td>
<td style="text-align: left;">矩阵 (<span class="math inline">\(\mathbf{F}\)</span>)</td>
<td style="text-align: left;">3维张量 (通常不常用)</td>
<td style="text-align: left;">-</td>
</tr>
<tr class="even">
<td style="text-align: left;">标量 (<span class="math inline">\(x\)</span>)</td>
<td style="text-align: left;">向量 (<span class="math inline">\(\mathbf{f}\)</span>)</td>
<td style="text-align: left;">列向量 (<span class="math inline">\(\frac{\partial \mathbf{f}}{\partial x}\)</span>)</td>
<td style="text-align: left;"><span class="math inline">\(n \times 1\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">向量 (<span class="math inline">\(\mathbf{x}\)</span>)</td>
<td style="text-align: left;">标量 (<span class="math inline">\(f\)</span>)</td>
<td style="text-align: left;">梯度 (<span class="math inline">\(\nabla f = \frac{\partial f}{\partial \mathbf{x}}\)</span>)</td>
<td style="text-align: left;"><span class="math inline">\(m \times 1\)</span> (列向量)</td>
</tr>
<tr class="even">
<td style="text-align: left;">矩阵 (<span class="math inline">\(\mathbf{X}\)</span>)</td>
<td style="text-align: left;">标量 (<span class="math inline">\(f\)</span>)</td>
<td style="text-align: left;">矩阵 (<span class="math inline">\(\frac{\partial f}{\partial \mathbf{X}}\)</span>)</td>
<td style="text-align: left;"><span class="math inline">\(m \times n\)</span></td>
</tr>
</tbody>
</table>
<p><strong>参考:</strong></p>
<ul>
<li><span class="math inline">\(m\)</span>: 输入向量/矩阵的维度，<span class="math inline">\(n\)</span>: 输出向量/矩阵的维度，<span class="math inline">\(p, q\)</span>: 矩阵的行/列数</li>
<li>对于矩阵输入、向量/矩阵输出的情况，导数会变成三维张量。虽然深度学习框架在内部高效地处理了这些高维张量运算，但通常情况下，主要是针对向量/矩阵输入输出的雅可比矩阵/梯度计算。</li>
</ul>
</section>
<section id="在深度学习中的应用" class="level4">
<h4 class="anchored">在深度学习中的应用</h4>
<ul>
<li><strong>反向传播算法：</strong> 雅可比矩阵和梯度在实现深度学习中的反向传播算法时起着核心作用。通过神经网络的每一层并应用链式法则来计算损失函数关于权重的梯度，并利用这些梯度来更新权重。</li>
<li><strong>自动微分：</strong> 现代深度学习框架（如TensorFlow、PyTorch等）提供了自动微分（Automatic Differentiation）功能，可以自动处理这些复杂的微分计算。用户无需直接实现复杂的微分公式，只需定义模型的结构和损失函数即可。</li>
</ul>
<p>这样，梯度和雅可比矩阵的概念在深度学习中成为对各种形式的函数进行微分的一般化工具，并通过反向传播高效地训练模型。</p>
<div class="callout callout-style-default callout-note callout-titled" title="点击查看内容（深入探讨：海森矩阵）">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-5-contents" aria-controls="callout-5" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
点击查看内容（深入探讨：海森矩阵）
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-5" class="callout-5-contents callout-collapse collapse">
<section id="海森矩阵-hessian-matrix" class="level2 callout-body-container callout-body">
<h2 class="anchored" data-anchor-id="海森矩阵-hessian-matrix">海森矩阵 (Hessian Matrix)</h2>
<section id="海森矩阵的定义和意义" class="level3">
<h3 class="anchored" data-anchor-id="海森矩阵的定义和意义">1. 海森矩阵的定义和意义</h3>
<ul>
<li><p><strong>定义:</strong> 海森矩阵是标量函数(scalar-valued function)的二阶偏导数(second-order partial derivatives)以矩阵形式表示。即，给定函数 <span class="math inline">\(f(x_1, x_2, ..., x_n)\)</span> 时，海森矩阵 <span class="math inline">\(H\)</span> 定义如下。</p>
<p><span class="math display">\[
H = \begin{bmatrix}
\frac{\partial^2 f}{\partial x_1^2} &amp; \frac{\partial^2 f}{\partial x_1 \partial x_2} &amp; \cdots &amp; \frac{\partial^2 f}{\partial x_1 \partial x_n} \\
\frac{\partial^2 f}{\partial x_2 \partial x_1} &amp; \frac{\partial^2 f}{\partial x_2^2} &amp; \cdots &amp; \frac{\partial^2 f}{\partial x_2 \partial x_n} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
\frac{\partial^2 f}{\partial x_n \partial x_1} &amp; \frac{\partial^2 f}{\partial x_n \partial x_2} &amp; \cdots &amp; \frac{\partial^2 f}{\partial x_n^2}
\end{bmatrix}
\]</span></p>
<ul>
<li>每个元素表示函数对每个变量的二次导数。</li>
<li><strong>对称矩阵(Symmetric Matrix):</strong> 当二阶偏导数连续时，根据Schwarz定理，偏导数的顺序可以交换，因此海森矩阵是对称矩阵。 (<span class="math inline">\(\frac{\partial^2 f}{\partial x_i \partial x_j} = \frac{\partial^2 f}{\partial x_j \partial x_i}\)</span>)</li>
</ul></li>
<li><p><strong>意义:</strong></p>
<ul>
<li><strong>曲率(Curvature):</strong> 海森矩阵包含了函数的局部曲率信息，表示函数图形在特定点处的弯曲程度。</li>
<li><strong>变化率的变化率:</strong> 一阶导数(梯度, Gradient)表示函数的变化率，而海森矩阵则表示这个变化率的变化速度。</li>
</ul></li>
</ul>
</section>
<section id="海森矩阵与函数极值-critical-point-判别" class="level3">
<h3 class="anchored" data-anchor-id="海森矩阵与函数极值-critical-point-判别">2. 海森矩阵与函数极值 (Critical Point) 判别</h3>
<ul>
<li><strong>临界点(Critical Point):</strong> 函数的斜率(gradient)为0的点。即所有变量的一阶偏导数值为0的点。 (<span class="math inline">\(\nabla f = 0\)</span>)</li>
<li><strong>极值判别:</strong>
<ul>
<li>海森矩阵用于判断函数在临界点处是否具有极大值(local maximum)，极小值(local minimum)，或鞍点(saddle point)。</li>
<li><strong>极小值(Local Minimum):</strong> 如果海森矩阵是 <strong>正定(positive definite)</strong> 矩阵，则该临界点为极小值。 (所有特征值(eigenvalue)均为正数)</li>
<li><strong>极大值(Local Maximum):</strong> 如果海森矩阵是 <strong>负定(negative definite)</strong> 矩阵，则该临界点为极大值。 (所有特征值均为负数)</li>
<li><strong>鞍点(Saddle Point):</strong> 如果海森矩阵是 <strong>不定(indefinite)</strong> 矩阵，则该临界点为鞍点。 (既有正数也有负数的特征值)</li>
<li><strong>半定(Semi-definite):</strong> 如果海森矩阵为positive/negative semi-definite，没有额外信息则无法判断极点的类型。 (特征值包含0)</li>
</ul></li>
</ul>
</section>
<section id="深度学习中海森矩阵的应用" class="level3">
<h3 class="anchored" data-anchor-id="深度学习中海森矩阵的应用">3. 深度学习中海森矩阵的应用</h3>
<ul>
<li><strong>牛顿法 (Newton’s Method):</strong>
<ul>
<li>是一种用于寻找函数极值的优化算法。</li>
<li>与使用一阶导数（梯度）的梯度下降法不同，牛顿法使用二阶导数（海森矩阵）可以更快地收敛。</li>
<li>更新规则： <span class="math inline">\(x_{k+1} = x_k - H^{-1}(x_k) \nabla f(x_k)\)</span> （H是海森矩阵）</li>
</ul></li>
<li><strong>曲率矩阵:</strong>
<ul>
<li>海森矩阵可以用作表示损失函数（loss function）的曲率的曲率矩阵。</li>
<li>利用曲率信息可以调整学习率或改进优化算法的性能。（例如，自然梯度下降法）</li>
</ul></li>
</ul>
</section>
</section>
</div>
</div>
</section>
</section>
<section id="链式法则与神经网络的反向传播" class="level3">
<h3 class="anchored" data-anchor-id="链式法则与神经网络的反向传播">2.2.3 链式法则与神经网络的反向传播</h3>
<p>神经网络学习的核心是反向传播（Backpropagation）算法。反向传播是一种高效的方法，它将输出层产生的误差沿输入层方向传播，并更新各层的权重和偏置。在此过程中，链式法则（Chain Rule）通过将复杂复合函数的导数表示为简单导数的乘积来实现计算。</p>
<section id="神经网络中的链式法则应用" class="level4">
<h4 class="anchored" data-anchor-id="神经网络中的链式法则应用">神经网络中的链式法则应用</h4>
<p>神经网络是由多个层次函数组合而成的形式。例如，两层神经网络可以如下表示：</p>
<p><span class="math inline">\(\mathbf{z} = f_1(\mathbf{x}; \mathbf{W_1}, \mathbf{b_1})\)</span> <span class="math inline">\(\mathbf{y} = f_2(\mathbf{z}; \mathbf{W_2}, \mathbf{b_2})\)</span></p>
<p>这里，<span class="math inline">\(\mathbf{x}\)</span> 是输入，<span class="math inline">\(\mathbf{z}\)</span> 是第一层的输出（第二层的输入），<span class="math inline">\(\mathbf{y}\)</span> 是最终输出，<span class="math inline">\(\mathbf{W_1}\)</span>, <span class="math inline">\(\mathbf{b_1}\)</span> 是第一层的权重和偏置，<span class="math inline">\(\mathbf{W_2}\)</span>, <span class="math inline">\(\mathbf{b_2}\)</span> 是第二层的权重和偏置。</p>
<p>在反向传播过程中，我们需要计算损失函数 <span class="math inline">\(E\)</span> 对各个参数的梯度（<span class="math inline">\(\frac{\partial E}{\partial \mathbf{W_1}}\)</span>, <span class="math inline">\(\frac{\partial E}{\partial \mathbf{b_1}}\)</span>, <span class="math inline">\(\frac{\partial E}{\partial \mathbf{W_2}}\)</span>, <span class="math inline">\(\frac{\partial E}{\partial \mathbf{b_2}}\)</span>）。此时应用链式法则可以如下计算：</p>
<p><span class="math inline">\(\frac{\partial E}{\partial \mathbf{W_2}} = \frac{\partial E}{\partial \mathbf{y}} \frac{\partial \mathbf{y}}{\partial \mathbf{W_2}}\)</span> <span class="math inline">\(\frac{\partial E}{\partial \mathbf{b_2}} = \frac{\partial E}{\partial \mathbf{y}} \frac{\partial \mathbf{y}}{\partial \mathbf{b_2}}\)</span> <span class="math inline">\(\frac{\partial E}{\partial \mathbf{W_1}} = \frac{\partial E}{\partial \mathbf{y}} \frac{\partial \mathbf{y}}{\partial \mathbf{z}} \frac{\partial \mathbf{z}}{\partial \mathbf{W_1}}\)</span> <span class="math inline">\(\frac{\partial E}{\partial \mathbf{b_1}} = \frac{\partial E}{\partial \mathbf{y}} \frac{\partial \mathbf{y}}{\partial \mathbf{z}} \frac{\partial \mathbf{z}}{\partial \mathbf{b_1}}\)</span></p>
<p>这样，利用链式法则可以将复杂神经网络中各参数的梯度分解为连续导数的乘积，从而高效地进行计算。2.2.4 的理论深入部分详细解释了这一过程。</p>
</section>
<section id="梯度与方向导数" class="level4">
<h4 class="anchored" data-anchor-id="梯度与方向导数">梯度与方向导数</h4>
<ul>
<li><strong>梯度（Gradient）：</strong> 多变量函数对每个变量的偏导数（partial derivative）组成的向量。表示函数上升最陡的方向。</li>
<li><strong>方向导数（Directional Derivative）：</strong> 表示函数在特定方向上的变化率。可以通过梯度与方向向量的点积（dot product）来计算。</li>
</ul>
</section>
<section id="梯度表达的注意事项" class="level4">
<h4 class="anchored" data-anchor-id="梯度表达的注意事项">梯度表达的注意事项</h4>
<ul>
<li><strong>列向量 vs.&nbsp;行向量:</strong> 通常，向量表示为列向量，但在深度学习中，根据上下文也可能会表示为行向量。保持一致性很重要。（本书使用分子记法。）</li>
<li><strong>雅可比矩阵(Jacobian Matrix):</strong> 对于具有多个输入变量和多个输出变量的函数（向量函数），包含所有偏导数值的矩阵。在深度学习中用于反向传播计算。</li>
</ul>
<p>基于这些概念，下一节将详细探讨反向传播过程中的梯度计算方法，并附有具体示例。</p>
</section>
</section>
<section id="反向传播的梯度计算" class="level3">
<h3 class="anchored" data-anchor-id="反向传播的梯度计算">2.2.4 反向传播的梯度计算</h3>
<p>反向传播的核心是计算损失函数（Loss Function）的梯度，以更新权重。我们以一个简单的线性变换(<span class="math inline">\(\mathbf{y} = \mathbf{xW} + \mathbf{b}\)</span>)为例来探讨反向传播的过程。</p>
<section id="反向传播的核心思想" class="level4">
<h4 class="anchored" data-anchor-id="反向传播的核心思想">1. 反向传播的核心思想</h4>
<p>反向传播是一种算法，在该算法中，从输出层计算的误差沿输入层方向传播，同时更新每个权重对误差的贡献。这一过程中，计算各权重关于损失函数的梯度是核心内容。</p>
</section>
<section id="损失函数的梯度" class="level4">
<h4 class="anchored" data-anchor-id="损失函数的梯度">2. 损失函数的梯度</h4>
<p>如果使用均方误差（Mean Squared Error, MSE）作为损失函数，则输出 <span class="math inline">\(\mathbf{y}\)</span> 关于损失函数 <span class="math inline">\(E\)</span> 的梯度如下所示：</p>
<p><span class="math inline">\(E = \frac{1}{M} \sum_{i=1}^{M} (y_i - \hat{y}_i)^2\)</span></p>
<p><span class="math inline">\(\frac{\partial E}{\partial \mathbf{y}} = \frac{2}{M}(\mathbf{y} - \hat{\mathbf{y}})\)</span></p>
<p>其中，<span class="math inline">\(y_i\)</span> 是实际值，<span class="math inline">\(\hat{y}_i\)</span> 是模型的预测值，<span class="math inline">\(M\)</span> 是数据的数量。</p>
</section>
<section id="权重的梯度" class="level4">
<h4 class="anchored" data-anchor-id="权重的梯度">3. 权重的梯度</h4>
<p>通过应用链式法则可以计算损失函数 <span class="math inline">\(E\)</span> 关于权重 <span class="math inline">\(\mathbf{W}\)</span> 的梯度：</p>
<p><span class="math inline">\(\frac{\partial E}{\partial \mathbf{W}} = \frac{\partial E}{\partial \mathbf{y}} \frac{\partial \mathbf{y}}{\partial \mathbf{W}}\)</span></p>
<p>因为 <span class="math inline">\(\mathbf{y} = \mathbf{xW} + \mathbf{b}\)</span>，所以 <span class="math inline">\(\frac{\partial \mathbf{y}}{\partial \mathbf{W}} = \mathbf{x}^T\)</span>。</p>
<p>最终权重的梯度可以表示为：</p>
<p><span class="math inline">\(\frac{\partial E}{\partial \mathbf{W}} = \mathbf{x}^T \frac{\partial E}{\partial \mathbf{y}}\)</span></p>
</section>
<section id="输入的梯度" class="level4">
<h4 class="anchored" data-anchor-id="输入的梯度">4. 输入的梯度</h4>
<p>输入 <span class="math inline">\(\mathbf{x}\)</span> 关于损失函数 <span class="math inline">\(E\)</span> 的梯度用于向之前的层传播误差。</p>
<p><span class="math inline">\(\frac{\partial E}{\partial \mathbf{x}} = \frac{\partial E}{\partial \mathbf{y}} \frac{\partial \mathbf{y}}{\partial \mathbf{x}}\)</span></p>
<p>因为 <span class="math inline">\(\mathbf{y} = \mathbf{xW} + \mathbf{b}\)</span>，所以 <span class="math inline">\(\frac{\partial \mathbf{y}}{\partial \mathbf{x}} = \mathbf{W}^T\)</span>。</p>
<p>因此，输入的梯度为：</p>
<p><span class="math inline">\(\frac{\partial E}{\partial \mathbf{x}} = \frac{\partial E}{\partial \mathbf{y}} \mathbf{W}^T\)</span></p>
</section>
<section id="总结" class="level4">
<h4 class="anchored" data-anchor-id="总结">5. 总结</h4>
<p>反向传播通过以下关键步骤实现： 1. <strong>前向传播(Forward Propagation):</strong> 将输入数据 <span class="math inline">\(\mathbf{x}\)</span> 通过神经网络计算预测值 <span class="math inline">\(\hat{\mathbf{y}}\)</span>。 2. <strong>损失函数计算:</strong> 比较预测值 <span class="math inline">\(\hat{\mathbf{y}}\)</span> 和实际值 <span class="math inline">\(\mathbf{y}\)</span> 来计算损失 <span class="math inline">\(E\)</span>。 3. <strong>反向传播(Backward Propagation):</strong> * 计算输出层的损失函数梯度 <span class="math inline">\(\frac{\partial E}{\partial \mathbf{y}}\)</span>。 * 利用链式法则计算权重的梯度 <span class="math inline">\(\frac{\partial E}{\partial \mathbf{W}} = \mathbf{x}^T \frac{\partial E}{\partial \mathbf{y}}\)</span>。 * 计算输入的梯度 <span class="math inline">\(\frac{\partial E}{\partial \mathbf{x}} = \frac{\partial E}{\partial \mathbf{y}} \mathbf{W}^T\)</span> 并将误差传播到前一层。 4. <strong>权重更新:</strong> 使用计算出的梯度通过梯度下降等优化算法更新权重。</p>
<p>反向传播算法是深度学习模型训练的核心，通过该算法可以有效地近似复杂的非线性函数。</p>
<div class="callout callout-style-default callout-note callout-titled" title="点击查看内容（深入探讨：用于反向传播的梯度计算）">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-6-contents" aria-controls="callout-6" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
点击查看内容（深入探讨：用于反向传播的梯度计算）
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-6" class="callout-6-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>反向传播的核心是计算损失函数（Loss Function）的梯度以更新权重。以简单的线性变换(<span class="math inline">\(\mathbf{y} = \mathbf{xW} + \mathbf{b}\)</span>)为例，我们将详细解释反向传播过程。这里尽可能详细地展开计算过程。</p>
<section id="损失函数的梯度-1" class="level4">
<h4 class="anchored" data-anchor-id="损失函数的梯度-1">损失函数的梯度</h4>
<p>神经网络学习的目标是使损失函数 <span class="math inline">\(E\)</span> 最小化。当使用均方误差（MSE）作为损失函数时，情况如下所示。</p>
<p><span class="math inline">\(E = f(\mathbf{y}) = \frac{1}{M} \sum_{i=1}^{M} (y_i - \hat{y}_i)^2\)</span></p>
<p>其中 <span class="math inline">\(y_i\)</span> 是实际值，<span class="math inline">\(\hat{y}_i\)</span> 是预测值，<span class="math inline">\(M\)</span> 是数据的数量（或输出向量的维度）。</p>
<p><span class="math inline">\(E\)</span> 关于 <span class="math inline">\(\mathbf{y}\)</span> 的导数（derivative）如下所示。</p>
<p><span class="math inline">\(\frac{\partial E}{\partial \mathbf{y}} = \frac{2}{M} (\mathbf{y} - \hat{\mathbf{y}})\)</span></p>
<p>其中，<span class="math inline">\(\mathbf{y}\)</span> 是神经网络的输出向量，<span class="math inline">\(\hat{\mathbf{y}}\)</span> 是实际值（目标）向量。因为 <span class="math inline">\(y_i\)</span> 是常数（每个目标元素），所以只有关于 <span class="math inline">\(\mathbf{y}\)</span> 的偏导数留下。</p>
<p><strong>注意:</strong> 第1章的例子代码中使用了 <span class="math inline">\(-\frac{2}{M}\)</span> 项，这是因为损失函数定义中包含了负号(-)。在这里我们使用一般的 MSE 定义，因此使用正数 <span class="math inline">\(\frac{2}{M}\)</span>。实际学习时会乘以学习率（learning rate），所以这个常数的绝对大小并不重要。</p>
</section>
<section id="关于权重的损失函数梯度" class="level4">
<h4 class="anchored" data-anchor-id="关于权重的损失函数梯度">关于权重的损失函数梯度</h4>
<p>现在，我们将计算关于权重 <span class="math inline">\(\mathbf{W}\)</span> 的损失函数 <span class="math inline">\(E\)</span> 的梯度。<span class="math inline">\(E = f(\mathbf{y})\)</span> 且 <span class="math inline">\(\mathbf{y} = \mathbf{xW} + \mathbf{b}\)</span>。<span class="math inline">\(\mathbf{x}\)</span> 是输入向量，<span class="math inline">\(\mathbf{W}\)</span> 是权重矩阵，<span class="math inline">\(\mathbf{b}\)</span> 是偏置向量。</p>
<p><strong>计算图:</strong></p>
<p>为了直观地表示反向传播过程，可以使用计算图。（插入计算图）</p>
<p><span class="math inline">\(E\)</span> 是一个标量值，需要对每个 <span class="math inline">\(w_{ij}\)</span>（权重矩阵 <span class="math inline">\(\mathbf{W}\)</span> 的每个元素）求 <span class="math inline">\(E\)</span> 的偏导数。<span class="math inline">\(\mathbf{W}\)</span> 是 (输入维度) x (输出维度) 大小的矩阵。例如，如果输入为三维(<span class="math inline">\(x_1, x_2, x_3\)</span>)，输出为二维(<span class="math inline">\(y_1, y_2\)</span>)，则 <span class="math inline">\(\mathbf{W}\)</span> 为 3x2 矩阵。</p>
<p><span class="math inline">\(\frac{\partial E}{\partial \mathbf{W}} = \begin{bmatrix}
\frac{\partial E}{\partial w_{11}} &amp; \frac{\partial E}{\partial w_{12}} \\
\frac{\partial E}{\partial w_{21}} &amp; \frac{\partial E}{\partial w_{22}} \\
\frac{\partial E}{\partial w_{31}} &amp; \frac{\partial E}{\partial w_{32}}
\end{bmatrix}\)</span></p>
<p><span class="math inline">\(E\)</span> 关于 <span class="math inline">\(\mathbf{y}\)</span> 的导数可以表示为行向量：<span class="math inline">\(\frac{\partial E}{\partial \mathbf{y}} = \begin{bmatrix} \frac{\partial E}{\partial y_1} &amp; \frac{\partial E}{\partial y_2} \end{bmatrix}\)</span>（使用分子记法）。严格来说，梯度应表示为列向量，但这里为了计算方便而使用行向量。</p>
<p>根据链式法则， <span class="math inline">\(\frac{\partial E}{\partial \mathbf{W}} = \frac{\partial E}{\partial \mathbf{y}} \frac{\partial \mathbf{y}}{\partial \mathbf{W}}\)</span></p>
<p><span class="math inline">\(\frac{\partial E}{\partial w_{ij}} = \sum_k \frac{\partial E}{\partial y_k} \frac{\partial y_k}{\partial w_{ij}}\)</span> (这里 <span class="math inline">\(k\)</span> 是输出向量 <span class="math inline">\(\mathbf{y}\)</span> 的索引)</p>
<p>上面的式子展开为，</p>
<p><span class="math inline">\(\frac{\partial E}{\partial \mathbf{W}} = \frac{\partial E}{\partial y_1} \frac{\partial y_1}{\partial \mathbf{W}} + \frac{\partial E}{\partial y_2} \frac{\partial y_2}{\partial \mathbf{W}}\)</span></p>
<p>现在需要计算 <span class="math inline">\(\frac{\partial y_k}{\partial w_{ij}}\)</span>。由于 <span class="math inline">\(\mathbf{y} = \mathbf{xW} + \mathbf{b}\)</span>，</p>
<p><span class="math inline">\(y_1 = x_1w_{11} + x_2w_{21} + x_3w_{31} + b_1\)</span> <span class="math inline">\(y_2 = x_1w_{12} + x_2w_{22} + x_3w_{32} + b_2\)</span></p>
<p><span class="math inline">\(\frac{\partial y_1}{\partial w_{ij}} = \begin{bmatrix}
\frac{\partial y_1}{\partial w_{11}} &amp; \frac{\partial y_1}{\partial w_{12}} \\
\frac{\partial y_1}{\partial w_{21}} &amp; \frac{\partial y_1}{\partial w_{22}} \\
\frac{\partial y_1}{\partial w_{31}} &amp; \frac{\partial y_1}{\partial w_{32}}
\end{bmatrix} =
\begin{bmatrix}
x_1 &amp; 0 \\
x_2 &amp; 0 \\
x_3 &amp; 0
\end{bmatrix}\)</span></p>
<p><span class="math inline">\(\frac{\partial y_2}{\partial w_{ij}} = \begin{bmatrix}
0 &amp; x_1 \\
0 &amp; x_2 \\
0 &amp; x_3
\end{bmatrix}\)</span></p>
<p>因此，</p>
<p><span class="math inline">\(\frac{\partial E}{\partial \mathbf{W}} = \frac{\partial E}{\partial y_1} \begin{bmatrix}
x_1 &amp; 0 \\
x_2 &amp; 0 \\
x_3 &amp; 0
\end{bmatrix} + \frac{\partial E}{\partial y_2} \begin{bmatrix}
0 &amp; x_1 \\
0 &amp; x_2 \\
0 &amp; x_3
\end{bmatrix} = \begin{bmatrix}
\frac{\partial E}{\partial y_1}x_1 &amp; \frac{\partial E}{\partial y_2}x_1 \\
\frac{\partial E}{\partial y_1}x_2 &amp; \frac{\partial E}{\partial y_2}x_2 \\
\frac{\partial E}{\partial y_1}x_3 &amp; \frac{\partial E}{\partial y_2}x_3
\end{bmatrix} = \begin{bmatrix} x_1 \\ x_2 \\ x_3 \end{bmatrix} \begin{bmatrix} \frac{\partial E}{\partial y_1} &amp; \frac{\partial E}{\partial y_2} \end{bmatrix} = \mathbf{x}^T \frac{\partial E}{\partial \mathbf{y}}\)</span></p>
<p><strong>泛化:</strong></p>
<p>当输入为 <span class="math inline">\(1 \times m\)</span> 行向量 <span class="math inline">\(\mathbf{x}\)</span>，输出为 <span class="math inline">\(1 \times n\)</span> 行向量 <span class="math inline">\(\mathbf{y}\)</span> 时，权重 <span class="math inline">\(\mathbf{W}\)</span> 是 <span class="math inline">\(m \times n\)</span> 矩阵。此时， <span class="math inline">\(\frac{\partial E}{\partial \mathbf{W}} = \mathbf{x}^T \frac{\partial E}{\partial \mathbf{y}}\)</span></p>
</section>
<section id="输入的损失函数梯度" class="level4">
<h4 class="anchored" data-anchor-id="输入的损失函数梯度">输入的损失函数梯度</h4>
<p>输入 <span class="math inline">\(\mathbf{x}\)</span> 的损失函数 <span class="math inline">\(E\)</span> 的梯度同样可以使用链式法则进行计算。</p>
<p><span class="math inline">\(\frac{\partial E}{\partial \mathbf{x}} = \frac{\partial E}{\partial \mathbf{y}} \frac{\partial \mathbf{y}}{\partial \mathbf{x}}\)</span></p>
<p>由于 <span class="math inline">\(\mathbf{y} = \mathbf{xW} + \mathbf{b}\)</span>，因此 <span class="math inline">\(\frac{\partial \mathbf{y}}{\partial \mathbf{x}} = \mathbf{W}^T\)</span>。</p>
<p>因此，</p>
<p><span class="math inline">\(\frac{\partial E}{\partial \mathbf{x}} = \frac{\partial E}{\partial \mathbf{y}} \mathbf{W}^T\)</span></p>
</section>
<section id="偏置的梯度" class="level4">
<h4 class="anchored" data-anchor-id="偏置的梯度">偏置的梯度</h4>
<p>偏置 <span class="math inline">\(\mathbf{b}\)</span> 的损失函数的梯度如下所示。</p>
<p><span class="math inline">\(\frac{\partial E}{\partial \mathbf{b}} = \frac{\partial E}{\partial \mathbf{y}} \frac{\partial \mathbf{y}}{\partial \mathbf{b}}\)</span></p>
<p>由于 <span class="math inline">\(\mathbf{y} = \mathbf{xW} + \mathbf{b}\)</span>，因此 <span class="math inline">\(\frac{\partial \mathbf{y}}{\partial \mathbf{b}} = \begin{bmatrix} 1 &amp; 1 &amp; \dots &amp; 1\end{bmatrix}\)</span>（全为1的 <span class="math inline">\(1 \times n\)</span> 行向量）</p>
<p><span class="math inline">\(\frac{\partial E}{\partial \mathbf{b}} = \frac{\partial E}{\partial \mathbf{y}}\)</span></p>
</section>
<section id="总结及进一步说明" class="level4">
<h4 class="anchored" data-anchor-id="总结及进一步说明">总结及进一步说明</h4>
<ol type="1">
<li><strong>权重的梯度:</strong> <span class="math inline">\(\frac{\partial E}{\partial \mathbf{W}} = \mathbf{x}^T \frac{\partial E}{\partial \mathbf{y}}\)</span>
<ul>
<li>通过输入向量 <span class="math inline">\(\mathbf{x}\)</span> 的转置（transpose）与输出损失函数的梯度 (<span class="math inline">\(\frac{\partial E}{\partial \mathbf{y}}\)</span>，这里表示为行向量) 的矩阵乘积计算。</li>
</ul></li>
<li><strong>输入的梯度:</strong> <span class="math inline">\(\frac{\partial E}{\partial \mathbf{x}} = \frac{\partial E}{\partial \mathbf{y}} \mathbf{W}^T\)</span>
<ul>
<li>通过输出损失函数的梯度 (<span class="math inline">\(\frac{\partial E}{\partial \mathbf{y}}\)</span>) 和权重矩阵 <span class="math inline">\(\mathbf{W}\)</span> 的转置（transpose）的矩阵乘积计算。该结果反向传播到前一层 (layer)，用于更新该层的权重。</li>
</ul></li>
<li><strong>偏置的梯度</strong>: <span class="math inline">\(\frac{\partial E}{\partial \mathbf{b}} = \frac{\partial E}{\partial \mathbf{y}}\)</span></li>
</ol>
<ul>
<li>等于输出损失函数的梯度。</li>
</ul>
<ol start="4" type="1">
<li><strong>梯度的应用:</strong> 这样计算出的梯度在诸如梯度下降 (Gradient Descent) 等优化算法中用于更新权重和偏置。每个参数沿着梯度的反方向进行更新以最小化损失函数。</li>
<li><strong>记法:</strong> 上述描述中，我们使用了分子布局(numerator layout)来计算梯度。也可以使用分母布局(denominator layout)，但最终会得到相同的更新规则。重要的是使用一致的记法。本书采用分子布局。</li>
</ol>
<p>通过这种数学过程，深度学习模型能够从输入数据学习到输出数据的复杂非线性转换。</p>
</section>
</div>
</div>
</div>
</section>
</section>
</section>
<section id="概率与统计" class="level2">
<h2 class="anchored" data-anchor-id="概率与统计">2.3 概率与统计</h2>
<p>深度学习深深植根于处理数据不确定性概率和统计理论。本章将探讨概率分布、期望值、贝叶斯定理、最大似然估计等核心概念。这些概念对于理解模型的学习和推理过程至关重要。</p>
<section id="概率分布与期望值" class="level3">
<h3 class="anchored" data-anchor-id="概率分布与期望值">2.3.1 概率分布与期望值</h3>
<blockquote class="blockquote">
<p><strong>挑战任务</strong>: 如何对实际数据的不确定性进行数学建模？</p>
<p><strong>研究者的苦恼</strong>: 初期的机器学习研究人员意识到现实世界的数据无法用确定性（deterministic）规则来描述。这是因为数据中存在测量误差、噪声和不可预测的变化。需要一种数学工具来量化这种不确定性和将其反映在模型中。</p>
</blockquote>
<p>概率分布表示所有可能的结果及其发生的概率。可以分为离散概率分布和连续概率分布。</p>
<section id="离散概率分布" class="level4">
<h4 class="anchored" data-anchor-id="离散概率分布">离散概率分布</h4>
<p>离散概率分布处理的是随机变量可以取的值是有限或可数的情况。其特点是每个可能的结果都有一个明确的概率。</p>
<p>数学上，离散概率分布由概率质量函数（PMF）表示。</p>
<p><span class="math display">\[P(X = x) = p(x)\]</span></p>
<p>其中 p(x) 是 X 取值为 x 的概率。主要性质如下：</p>
<ol type="1">
<li>对于所有 x, <span class="math inline">\(0 ≤ p(x) ≤ 1\)</span></li>
<li><span class="math inline">\(\sum_{x} p(x) = 1\)</span></li>
</ol>
<p>典型的例子包括伯努利分布、二项分布和泊松分布。</p>
<p>掷骰子的概率质量函数如下所示。</p>
<p><span class="math display">\[P(X = x) = \begin{cases}
\frac{1}{6} &amp; \text{if } x \in \{1, 2, 3, 4, 5, 6\} \
0 &amp; \text{otherwise}
\end{cases}\]</span></p>
<p>离散概率分布在机器学习和深度学习中广泛应用于分类问题、强化学习、自然语言处理等领域。以下是模拟掷骰子的结果。</p>
<div id="cell-25" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_02.statistics <span class="im">import</span> simulate_dice_roll</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>simulate_dice_roll()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="02_深度学习的数学_files/figure-html/cell-7-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="连续概率分布" class="level4">
<h4 class="anchored" data-anchor-id="连续概率分布">连续概率分布</h4>
<p>连续概率分布处理随机变量可以取连续值的情况。与离散概率分布不同，特定点的概率为0，而是处理区间内的概率。数学上，连续概率分布由概率密度函数（Probability Density Function, PDF）表示。</p>
<p><span class="math display">\[f(x) = \lim_{\Delta x \to 0} \frac{P(x &lt; X \leq x + \Delta x)}{\Delta x}\]</span></p>
<p>这里 f(x) 表示在 x 附近的概率密度。主要性质如下：</p>
<ol type="1">
<li>对所有 x，f(x) ≥ 0</li>
<li><span class="math inline">\(\int_{-\infty}^{\infty} f(x) dx = 1\)</span></li>
</ol>
<p>典型的例子包括正态分布、指数分布和伽玛分布。</p>
<p>正态分布的概率密度函数如下：</p>
<p><span class="math display">\[f(x) = \frac{1}{\sigma\sqrt{2\pi}} e^{-\frac{(x-\mu)^2}{2\sigma^2}}\]</span></p>
<p>这里 μ 是均值，σ 是标准差。</p>
<p>连续概率分布在回归问题、信号处理、时间序列分析等各种机器学习和深度学习应用中起着重要作用。</p>
<div id="cell-27" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_02.statistics <span class="im">import</span> plot_normal_distribution</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>plot_normal_distribution()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="02_深度学习的数学_files/figure-html/cell-8-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="期望值" class="level4">
<h4 class="anchored" data-anchor-id="期望值">期望值</h4>
<p>期望值是表示概率分布中心趋势的一个重要概念。它可以解释为随机变量所有可能值的加权平均。对于离散概率分布，期望值可以如下计算。</p>
<p><span class="math display">\[E[X] = \sum_{i} x_i P(X = x_i)\]</span></p>
<p>其中 <span class="math inline">\(x_i\)</span> 是随机变量 X 的可能取值，<span class="math inline">\(P(X = x_i)\)</span> 是该值的概率。对于连续概率分布，期望值通过积分计算。</p>
<p><span class="math display">\[E[X] = \int_{-\infty}^{\infty} x f(x) dx\]</span></p>
<p>其中 <span class="math inline">\(f(x)\)</span> 是概率密度函数。期望值具有以下重要性质：</p>
<ol type="1">
<li>线性：<span class="math inline">\(E[aX + b] = aE[X] + b\)</span></li>
<li>独立随机变量乘积的期望值：<span class="math inline">\(E[XY] = E[X]E[Y]\)</span> （当 X 和 Y 相互独立时）</li>
</ol>
<p>在深度学习中，期望值用于损失函数最小化或模型参数估计的核心部分。例如，均方误差 (MSE) 定义如下。</p>
<p><span class="math display">\[MSE = E[(Y - \hat{Y})^2]\]</span></p>
<p>其中 <span class="math inline">\(Y\)</span> 是实际值，<span class="math inline">\(\hat{Y}\)</span> 是预测值。</p>
<p>期望值的概念为诸如随机梯度下降（Stochastic Gradient Descent）等优化算法提供了理论基础，并在强化学习中的价值函数估计中发挥了重要作用。</p>
<div id="cell-29" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_02.statistics <span class="im">import</span> calculate_dice_expected_value</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>calculate_dice_expected_value()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Expected value of dice roll: 3.5</code></pre>
</div>
</div>
<p>这些概率和统计的基本概念在深度学习模型的设计、学习和评估过程中起着核心作用。在下一节中，我们将基于此了解贝叶斯定理和最大似然估计。</p>
</section>
</section>
<section id="贝叶斯定理和最大似然估计" class="level3">
<h3 class="anchored">2.3.2 贝叶斯定理和最大似然估计</h3>
<blockquote class="blockquote">
<p><strong>挑战任务:</strong> 如何利用有限的数据最好地估计模型的参数？</p>
<p><strong>研究者的困扰:</strong> 初期的统计学家和机器学习研究人员经常面临只能使用有限数据构建模型的情况。在数据不足的情况下准确估计模型参数是非常困难的问题。除了依赖数据，还需要利用先验知识或信念来提高估计的准确性。</p>
</blockquote>
<p>贝叶斯定理和最大似然估计是概率论和统计学的核心概念，在深度学习中广泛应用于模型训练和推理。</p>
<section id="贝叶斯定理" class="level4">
<h4 class="anchored" data-anchor-id="贝叶斯定理">贝叶斯定理</h4>
<p>贝叶斯定理提供了一种计算条件概率的方法。它用于在给定新证据时更新假设的概率。贝叶斯定理的数学表达如下：</p>
<p><span class="math display">\[P(A|B) = \frac{P(B|A)P(A)}{P(B)}\]</span></p>
<p>其中： - <span class="math inline">\(P(A|B)\)</span> 是给定 B 时 A 的概率（后验概率） - <span class="math inline">\(P(B|A)\)</span> 是给定 A 时 B 的概率（似然） - <span class="math inline">\(P(A)\)</span> 是 A 的概率（先验概率） - <span class="math inline">\(P(B)\)</span> 是 B 的概率（证据）</p>
<p>贝叶斯定理在机器学习中如下应用：</p>
<ol type="1">
<li>分类问题：在朴素贝叶斯分类器中计算属于特定类别的概率。</li>
<li>参数估计：用于计算模型参数的后验分布。</li>
<li>决策理论：用于在不确定性下做出最优决策。</li>
</ol>
</section>
<section id="最大似然估计" class="level4">
<h4 class="anchored">最大似然估计</h4>
<p>最大似然估计（Maximum Likelihood Estimation, MLE）是寻找最能解释给定数据的模型参数的方法。在深度学习的背景下，这意味着找到使神经网络能够最好地解释观察到的数据的权重和偏置。也就是说，最大似然估计是找到使模型生成训练数据的概率最大的参数，这直接与模型的学习过程相关联。 数学上，给定数据 <span class="math inline">\(X = (x_1, ..., x_n)\)</span> 时，关于参数 <span class="math inline">\(\theta\)</span> 的似然函数定义如下：</p>
<p><span class="math display">\[L(\theta|X) = P(X|\theta) = \prod_{i=1}^n P(x_i|\theta)\]</span></p>
<p>最大似然估计值 <span class="math inline">\(\hat{\theta}_{MLE}\)</span> 如下计算：</p>
<p><span class="math display">\[\hat{\theta}_{MLE} = \operatorname{argmax}_{\theta} L(\theta|X)\]</span></p>
<p>实际上，最大化对数似然在计算上更为方便。</p>
<p><span class="math display">\[\hat{\theta}_{MLE} = \operatorname{argmax}_{\theta} \log L(\theta|X) = \operatorname{argmax}_{\theta} \sum_{i=1}^n \log P(x_i|\theta)\]</span></p>
<p>使用对数似然有几个重要的数学优势：</p>
<ol type="1">
<li>将乘法转换为加法：根据对数函数的特性 <span class="math inline">\(\log(ab) = \log(a) + \log(b)\)</span>，可以将概率的乘积转换为对数概率的和。这简化了计算并提高了数值稳定性。</li>
<li>提高数值稳定性：处理非常小的概率值时，乘法可能导致下溢。使用对数可以避免这种问题。</li>
<li>简化微分：在优化过程中进行微分计算时，使用对数函数可以使计算更加简单。特别是对于指数分布的情况，这一点尤为突出。</li>
<li>单调递增函数：对数函数是单调递增的，因此最大化似然和最大化对数似然是等效的。</li>
</ol>
<p>由于这些原因，在深度学习和其他许多机器学习算法中，通常使用对数似然进行优化。</p>
<p>最大似然估计在深度学习中如下应用： 1. 模型训练：在学习神经网络的权重时，最小化损失函数的过程实际上等同于最大似然估计。 2. 概率建模：用于生成模型中数据分布的估计。 3. 超参数调优：可以用于选择模型的超参数。</p>
<p>贝叶斯定理和最大似然估计密切相关。在贝叶斯估计中，如果先验概率为均匀分布，则最大后验概率（MAP）估计与最大似然估计相同。数学上表示为，<span class="math inline">\(P(\theta|X) \propto P(X|\theta)P(\theta)\)</span> 中 <span class="math inline">\(P(\theta)\)</span> 为常数时，<span class="math inline">\(\operatorname{argmax}_{\theta} P(\theta|X) = \operatorname{argmax}_{\theta} P(X|\theta)P(\theta)\)</span>。这意味着当先验概率不提供关于参数的额外信息时，基于数据的估计（MLE）与贝叶斯估计（MAP）一致。</p>
<p>这些概念对于理解和优化深度学习模型的训练和推理过程至关重要。下一节将介绍信息论的基础知识。</p>
<div class="callout callout-style-default callout-note callout-titled" title="深度探讨：贝叶斯定理的深入分析">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-7-contents" aria-controls="callout-7" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
深度探讨：贝叶斯定理的深入分析
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-7" class="callout-7-contents callout-collapse collapse">
<section id="贝叶斯定理-bayes-theorem---深度分析" class="level2 callout-body-container callout-body">
<h2 class="anchored" data-anchor-id="贝叶斯定理-bayes-theorem---深度分析">贝叶斯定理 (Bayes’ Theorem) - 深度分析</h2>
<section id="贝叶斯定理的严格推导及概率空间" class="level3">
<h3 class="anchored" data-anchor-id="贝叶斯定理的严格推导及概率空间">1. 贝叶斯定理的严格推导及概率空间</h3>
<ul>
<li><strong>概率空间 (Probability Space):</strong> 贝叶斯定理在概率空间 <span class="math inline">\((\Omega, \mathcal{F}, P)\)</span> 上定义。
<ul>
<li><span class="math inline">\(\Omega\)</span>: 样本空间 (Sample Space, 所有可能结果的集合)</li>
<li><span class="math inline">\(\mathcal{F}\)</span>: 事件空间 (Event Space, 样本空间的部分集族，<span class="math inline">\(\sigma\)</span>-代数)</li>
<li><span class="math inline">\(P\)</span>: 概率测度 (Probability Measure, 将概率分配给事件空间中每个事件的函数)</li>
</ul></li>
<li><strong>条件概率的严格定义:</strong>
<ul>
<li>对于事件 <span class="math inline">\(B \in \mathcal{F}\)</span> 且 <span class="math inline">\(P(B) &gt; 0\)</span>，事件 <span class="math inline">\(A \in \mathcal{F}\)</span> 的条件概率 <span class="math inline">\(P(A|B)\)</span> 定义如下。 <span class="math inline">\(P(A|B) = \frac{P(A \cap B)}{P(B)}\)</span></li>
</ul></li>
<li><strong>联合概率:</strong>
<ul>
<li>两个事件 <span class="math inline">\(A, B \in \mathcal{F}\)</span> 的联合概率 <span class="math inline">\(P(A \cap B)\)</span> 表示这两个事件同时发生的概率。</li>
<li>利用条件概率的定义，可以如下表示。
<ul>
<li><span class="math inline">\(P(A \cap B) = P(A|B)P(B)\)</span></li>
<li><span class="math inline">\(P(A \cap B) = P(B|A)P(A)\)</span></li>
</ul></li>
</ul></li>
<li><strong>贝叶斯定理推导:</strong>
<ol type="1">
<li><span class="math inline">\(P(A|B)P(B) = P(B|A)P(A)\)</span> (联合概率的两种表示)</li>
<li><span class="math inline">\(P(A|B) = \frac{P(B|A)P(A)}{P(B)}\)</span> (两边同时除以 <span class="math inline">\(P(B)\)</span>, <span class="math inline">\(P(B) &gt; 0\)</span>)</li>
</ol></li>
</ul>
</section>
<section id="贝叶斯定理各项的深度意义及统计解释" class="level3">
<h3 class="anchored" data-anchor-id="贝叶斯定理各项的深度意义及统计解释">2. 贝叶斯定理各项的深度意义及统计解释</h3>
<ul>
<li><strong><span class="math inline">\(P(A|B)\)</span>: 后验概率 (Posterior Probability)</strong>
<ul>
<li><strong>解释:</strong> 在获得观测数据 <span class="math inline">\(B\)</span> 后，关于假设 <span class="math inline">\(A\)</span> 的更新后的概率分布。表示基于数据的推理(inference)结果。</li>
<li><strong>贝叶斯观点:</strong> 后验概率通过先验概率和似然函数的结合来量化不确定性，并为决策(decision making)提供基础。</li>
</ul></li>
<li><strong><span class="math inline">\(P(B|A)\)</span>: 似然，条件密度 (Likelihood)</strong>
<ul>
<li><strong>解释:</strong> 在假设 <span class="math inline">\(A\)</span> 成立的情况下，观测数据 <span class="math inline">\(B\)</span> 出现的概率。表示假设 <span class="math inline">\(A\)</span> 对数据 <span class="math inline">\(B\)</span> 的解释能力。</li>
<li><strong>频率学派 vs.&nbsp;贝叶斯观点:</strong>
<ul>
<li><strong>频率学派:</strong> 似然是关于固定参数(parameter)的函数，用于描述数据的分布。</li>
<li><strong>贝叶斯:</strong> 似然是在给定数据的情况下提供关于参数的信息的函数。</li>
</ul></li>
</ul></li>
<li><strong><span class="math inline">\(P(A)\)</span>: 先验概率 (Prior Probability)</strong>
<ul>
<li><strong>解释:</strong> 在获得观测数据 <span class="math inline">\(B\)</span> 之前，表示对假设 <span class="math inline">\(A\)</span> 的先验信念(prior belief)的概率分布。</li>
<li><strong>主观 vs.&nbsp;客观先验概率:</strong>
<ul>
<li><strong>主观 (Subjective):</strong> 基于专家知识、先前经验等设定。</li>
<li><strong>客观 (Objective):</strong> 使用均匀分布(uniform distribution)或无信息先验分布(non-informative prior)等包含最少信息的先验分布。</li>
</ul></li>
</ul></li>
<li><strong><span class="math inline">\(P(B)\)</span>: 证据 (Evidence) 或者 边缘似然度 (Marginal Likelihood)</strong>
<ul>
<li><strong>解释:</strong> 在所有可能的假设下观察数据 <span class="math inline">\(B\)</span> 出现的概率。作为将 <span class="math inline">\(P(A|B)\)</span> 转化为概率分布的归一化常数(normalizing constant)。</li>
<li><strong>计算:</strong> <span class="math inline">\(P(B) = \sum_{A'} P(B|A')P(A')\)</span> (离散随机变量) <span class="math inline">\(P(B) = \int P(B|A)p(A) dA\)</span> (连续随机变量, <span class="math inline">\(p(A)\)</span> 是概率密度函数)</li>
<li><strong>模型比较:</strong> 用于计算贝叶斯因子(Bayes factor)等，以比较不同模型的证据。</li>
</ul></li>
</ul>
</section>
<section id="贝叶斯定理与贝叶斯推断-bayesian-inference" class="level3">
<h3 class="anchored" data-anchor-id="贝叶斯定理与贝叶斯推断-bayesian-inference">3. 贝叶斯定理与贝叶斯推断 (Bayesian Inference)</h3>
<ul>
<li><strong>核心:</strong> 贝叶斯定理是贝叶斯推断的核心原理，它在给定数据的情况下推理参数(parameter)或假设的概率分布。</li>
<li><strong>过程:</strong>
<ol type="1">
<li><strong>先验:</strong> 设定参数 <span class="math inline">\(\theta\)</span> 的先验分布 <span class="math inline">\(p(\theta)\)</span>。</li>
<li><strong>似然:</strong> 定义在给定参数 <span class="math inline">\(\theta\)</span> 下数据 <span class="math inline">\(x\)</span> 被观察到的概率 <span class="math inline">\(p(x|\theta)\)</span> (似然函数)。</li>
<li><strong>后验:</strong> 利用贝叶斯定理计算后验分布 <span class="math inline">\(p(\theta|x)\)</span>。 <span class="math inline">\(p(\theta|x) = \frac{p(x|\theta)p(\theta)}{p(x)} = \frac{p(x|\theta)p(\theta)}{\int p(x|\theta')p(\theta') d\theta'}\)</span></li>
<li><strong>推断:</strong> 基于后验分布进行参数估计、区间估计、假设检验等。</li>
</ol></li>
<li><strong>迭代更新:</strong> 每次有新数据进来时，可以使用之前的后验分布作为新的先验分布不断更新信念。(顺序贝叶斯更新)</li>
</ul>
</section>
<section id="贝叶斯定理的扩展与应用" class="level3">
<h3 class="anchored" data-anchor-id="贝叶斯定理的扩展与应用">4. 贝叶斯定理的扩展与应用</h3>
<ul>
<li><strong>连续随机变量:</strong> 利用概率密度函数的贝叶斯定理</li>
<li><strong>共轭先验 (Conjugate Prior):</strong>
<ul>
<li>使后验分布和先验分布属于同一分布族(family)的先验分布。由于计算上的便利性，被广泛使用。(例如：Beta 分布 - Bernoulli 分布, Gamma 分布 - Poisson 分布)</li>
</ul></li>
<li><strong>变分贝叶斯 (Variational Bayes):</strong>
<ul>
<li>近似复杂后验分布的方法。</li>
<li>找到与后验分布相似的、易于处理的分布，并通过最小化两个分布之间的 Kullback-Leibler divergence 来近似。</li>
</ul></li>
<li><strong>马尔可夫链蒙特卡洛 (Markov Chain Monte Carlo, MCMC):</strong>
<ul>
<li>从后验分布中抽取样本(sample)，以估计后验分布的特性。</li>
<li>Metropolis-Hastings 算法、Gibbs sampling 等。</li>
</ul></li>
<li><strong>在深度学习中的应用:</strong>
<ul>
<li><strong>贝叶斯神经网络:</strong> 将神经网络的权重(weight)视为随机变量，量化预测的不确定性。</li>
<li><strong>高斯过程:</strong> 利用核(kernel)定义函数空间上的先验分布，并通过贝叶斯定理计算预测分布。</li>
</ul></li>
</ul>
</section>
</section>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled" title="深度探讨：最大似然估计（MLE）的深入分析及与MAP的比较（硕士及以上）">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-8-contents" aria-controls="callout-8" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
深度探讨：最大似然估计（MLE）的深入分析及与MAP的比较（硕士及以上）
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-8" class="callout-8-contents callout-collapse collapse">
<section id="最大似然估计-maximum-likelihood-estimation-mle---深度分析及与map的比较" class="level2 callout-body-container callout-body">
<h2 class="anchored" data-anchor-id="最大似然估计-maximum-likelihood-estimation-mle---深度分析及与map的比较">最大似然估计 (Maximum Likelihood Estimation, MLE) - 深度分析及与MAP的比较</h2>
<section id="mle计算的具体示例" class="level3">
<h3 class="anchored" data-anchor-id="mle计算的具体示例">1. MLE计算的具体示例</h3>
<p>MLE是一种寻找最能解释给定数据的参数的方法。它找到使观察数据的似然性（likelihood）最大化的参数值。</p>
<ul>
<li><p><strong>似然函数 (Likelihood Function):</strong></p>
<ul>
<li>假设数据 <span class="math inline">\(x_1, x_2, ..., x_n\)</span> 是独立同分布(i.i.d)地从同一个概率分布中抽取，那么似然函数可以定义为： <span class="math display">\[L(\theta; x_1, ..., x_n) = \prod_{i=1}^{n} p(x_i | \theta)\]</span>
<ul>
<li><span class="math inline">\(\theta\)</span>: 参数 (parameter)</li>
<li><span class="math inline">\(p(x_i | \theta)\)</span>: 在给定参数 <span class="math inline">\(\theta\)</span> 的情况下，数据 <span class="math inline">\(x_i\)</span> 出现的概率（或概率密度）</li>
</ul></li>
</ul></li>
<li><p><strong>对数似然函数 (Log-Likelihood Function):</strong></p>
<ul>
<li>为了计算方便，通常使用取自然对数后的对数似然函数。 <span class="math display">\[l(\theta; x_1, ..., x_n) = \log L(\theta; x_1, ..., x_n) = \sum_{i=1}^{n} \log p(x_i | \theta)\]</span></li>
<li>取自然对数不会改变最大值的位置，因此也可以通过最大化对数似然来寻找参数。</li>
</ul></li>
<li><p><strong>MLE计算步骤:</strong></p>
<ol type="1">
<li>定义给定数据和概率分布模型的似然函数。</li>
<li>对似然函数取自然对数以获得对数似然函数。</li>
<li>对参数 <span class="math inline">\(\theta\)</span> 求导对数似然函数。</li>
<li>寻找使导数值为0的 <span class="math inline">\(\theta\)</span> 值。（必要时使用二阶导数来判断极大/极小值）</li>
<li>找到的 <span class="math inline">\(\theta\)</span> 值即为MLE估计值。</li>
</ol></li>
<li><p><strong>具体示例:</strong></p>
<ul>
<li><strong>正态分布 (Normal Distribution):</strong>
<ul>
<li>假设数据 <span class="math inline">\(x_1, ..., x_n\)</span> 遵循均值为 <span class="math inline">\(\mu\)</span>，方差为 <span class="math inline">\(\sigma^2\)</span> 的正态分布。</li>
<li>对数似然函数： <span class="math display">\[l(\mu, \sigma^2; x_1, ..., x_n) = -\frac{n}{2}\log(2\pi\sigma^2) - \frac{1}{2\sigma^2}\sum_{i=1}^{n}(x_i - \mu)^2\]</span></li>
<li>分别对 <span class="math inline">\(\mu\)</span> 和 <span class="math inline">\(\sigma^2\)</span> 求偏导并找到使它们为0的点，MLE估计值如下：
<ul>
<li><span class="math inline">\(\hat{\mu}_{MLE} = \frac{1}{n}\sum_{i=1}^{n} x_i\)</span> （样本均值）</li>
<li><span class="math inline">\(\hat{\sigma}^2_{MLE} = \frac{1}{n}\sum_{i=1}^{n} (x_i - \hat{\mu}_{MLE})^2\)</span> （样本方差）</li>
</ul></li>
</ul></li>
<li><strong>伯努利分布 (Bernoulli Distribution):</strong>
<ul>
<li>假设数据 <span class="math inline">\(x_1, ..., x_n\)</span> 遵循成功概率为 <span class="math inline">\(p\)</span> 的伯努利分布。(<span class="math inline">\(x_i = 1\)</span> 表示成功，<span class="math inline">\(x_i = 0\)</span> 表示失败)</li>
<li>对数似然函数： <span class="math display">\[ l(p; x_1, ..., x_n) = \sum_{i=1}^n [x_i \log p + (1-x_i) \log (1-p)] \]</span></li>
<li>对 <span class="math inline">\(p\)</span> 求导并找到使它为0的点，MLE估计值如下：
<ul>
<li><span class="math inline">\(\hat{p}_{MLE} = \frac{1}{n}\sum_{i=1}^{n} x_i\)</span> （成功次数 / 总试验次数）</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="mle的优点和缺点" class="level3">
<h3 class="anchored" data-anchor-id="mle的优点和缺点">2. MLE的优点和缺点</h3>
<ul>
<li><strong>优点:</strong>
<ul>
<li><strong>计算的简便性:</strong> 可以通过相对简单的计算进行参数估计。特别是在指数族（exponential family）分布的情况下。</li>
<li><strong>渐近性质 (Asymptotic Properties):</strong> （以下详细说明）
<ul>
<li><strong>一致性 (Consistency):</strong> 随着样本量增大，MLE 估计值会收敛于实际参数。</li>
<li><strong>渐近正态性 (Asymptotic Normality):</strong> 随着样本量增大，MLE 估计值趋近于正态分布。</li>
<li><strong>效率 (Efficiency):</strong> 渐近地具有最小方差的无偏估计（Cramér–Rao 下限）。</li>
</ul></li>
</ul></li>
<li><strong>缺点:</strong>
<ul>
<li><strong>过拟合 (Overfitting) 的可能性:</strong> 特别是当样本量较小时，可能过度适应数据而导致泛化性能下降。</li>
<li><strong>对异常值(Outlier)敏感:</strong> 存在异常值时，MLE 估计值可能会严重扭曲。</li>
<li><strong>并非适用于所有分布:</strong> MLE 需要给定概率模型（probabilistic model）才能应用（不适用于非参数方法）。</li>
<li><strong>可能存在偏倚 (Bias):</strong> 在某些情况下，MLE 估计量可能是有偏的（例如，正态分布的方差估计）。</li>
</ul></li>
</ul>
</section>
<section id="最大后验概率估计-maximum-a-posteriori-map-的比较" class="level3">
<h3 class="anchored" data-anchor-id="最大后验概率估计-maximum-a-posteriori-map-的比较">3. 最大后验概率估计 (Maximum A Posteriori, MAP) 的比较</h3>
<ul>
<li><p><strong>MAP:</strong> 基于贝叶斯定理，结合先验概率(prior probability)和似然性(likelihood)，寻找使后验概率(posterior probability)最大化的参数。</p></li>
<li><p><strong>MAP 估计:</strong> <span class="math display">\[
  \hat{\theta}_{MAP} = \arg\max_{\theta} p(\theta|x) = \arg\max_{\theta} \frac{p(x|\theta)p(\theta)}{p(x)} = \arg\max_{\theta} p(x|\theta)p(\theta)
  \]</span></p>
<ul>
<li><span class="math inline">\(p(\theta|x)\)</span>: 后验概率 (Posterior Probability)</li>
<li><span class="math inline">\(p(x|\theta)\)</span>: 似然性 (Likelihood)</li>
<li><span class="math inline">\(p(\theta)\)</span>: 先验概率 (Prior Probability)</li>
<li><span class="math inline">\(p(x)\)</span>: 证据 (Evidence, 是一个常数，因此可以忽略)</li>
</ul></li>
<li><p><strong>MLE vs.&nbsp;MAP:</strong> | 特征 | MLE | MAP | | ————– | ——————————————————————– | ———————————————————————- | | <strong>基础</strong> | 频率学派 (Frequentist) | 贝叶斯学派 (Bayesian) | | <strong>目标</strong> | 似然最大化 | 后验概率最大化 | | <strong>先验概率</strong> | 不考虑 | 考虑 | | <strong>结果</strong> | 点估计 (Point Estimate) | 点估计（通常）或分布估计（贝叶斯推理情况下） | | <strong>过拟合</strong> | 过拟合可能性高 | 通过先验概率防止过拟合可能（例如，正则化效果） | | <strong>计算复杂度</strong> | 一般较低 | 根据先验概率的复杂度可能会增加（特别是当没有共轭先验分布时） |</p></li>
<li><p><strong>先验概率的影响:</strong></p>
<ul>
<li><strong>非信息性先验分布 (Non-informative Prior):</strong> 当先验概率遵循均匀分布，例如 <span class="math inline">\(p(\theta) \propto 1\)</span>（常数），MAP估计与MLE估计相同。</li>
<li><strong>信息性先验分布 (Informative Prior):</strong> 当先验概率遵循特定分布时（如正态分布、贝塔分布），MAP估计会受到先验概率的影响，与MLE估计不同。 先验分布表示的先验信念越强，后验就越接近先验。</li>
</ul></li>
</ul>
</section>
<section id="mle的渐近性质-asymptotic-property" class="level3">
<h3 class="anchored" data-anchor-id="mle的渐近性质-asymptotic-property">4. MLE的渐近性质 (Asymptotic Property)</h3>
<ul>
<li><strong>一致性 (Consistency):</strong>
<ul>
<li>当样本大小 <span class="math inline">\(n\)</span> 趋向于无穷大时，MLE估计量 <span class="math inline">\(\hat{\theta}_{MLE}\)</span> 概率收敛（converge in probability）到实际参数 <span class="math inline">\(\theta_0\)</span>。 <span class="math display">\[\hat{\theta}_{MLE} \xrightarrow{p} \theta_0 \text{ as } n \rightarrow \infty\]</span></li>
</ul></li>
<li><strong>渐近正态性 (Asymptotic Normality):</strong>
<ul>
<li>当样本大小 <span class="math inline">\(n\)</span> 足够大时，MLE 估计量 <span class="math inline">\(\hat{\theta}_{MLE}\)</span> 的分布可以近似为以下正态分布。 <span class="math display">\[\sqrt{n}(\hat{\theta}_{MLE} - \theta_0) \xrightarrow{d} N(0, I(\theta_0)^{-1})\]</span>
<ul>
<li><span class="math inline">\(I(\theta_0)\)</span>: Fisher Information Matrix (FIM)
<ul>
<li><span class="math inline">\(I(\theta) = -E[\frac{\partial^2}{\partial \theta^2} l(\theta; x_1, ...,x_n)]\)</span>（单参数情况）</li>
<li>FIM 表示对数似然函数的曲率(curvature)，反映了关于参数的信息量。</li>
</ul></li>
</ul></li>
</ul></li>
<li><strong>效率 (Efficiency):</strong>
<ul>
<li>MLE 是渐近地达到 Cramér–Rao 下限(Cramér–Rao lower bound, CRLB) 的有效估计量。与其他无偏估计量(unbiased estimator)相比，它在渐近时具有最小的方差。</li>
</ul></li>
</ul>
</section>
</section>
</div>
</div>
</section>
</section>
<section id="信息论基础" class="level3">
<h3 class="anchored">2.3.3 信息论基础</h3>
<blockquote class="blockquote">
<p><strong>挑战：</strong> 如何测量信息量并量化不确定性？</p>
<p><strong>研究者的困惑：</strong> 克劳德·香农面临关于通信系统中信息高效传输和压缩的基本问题。他需要一种理论依据来量化信息，确定在不失真信息的情况下可以将数据压缩到什么程度，以及通过噪声信道可以稳定地传输多少信息。</p>
</blockquote>
<p>信息论是关于数据压缩、传输和存储的数学理论，在深度学习中对模型性能评估和优化起着重要作用。本节我们将探讨信息论的核心概念：熵、互信息量和KL散度。</p>
<section id="熵" class="level4">
<h4 class="anchored" data-anchor-id="熵">熵</h4>
<p>熵是衡量信息不确定性的指标。概率分布P的熵H(P)定义如下：</p>
<p><span class="math display">\[H(P) = -\sum_{x} P(x) \log P(x)\]</span></p>
<p>其中，x表示所有可能事件。熵的主要特性包括：</p>
<ol type="1">
<li>非负性: <span class="math inline">\(H(P) ≥ 0\)</span></li>
<li>均匀分布时最大：当所有事件的概率相等时，熵达到最大。</li>
<li>确定性事件的熵为0: 当<span class="math inline">\(P(x) = 1\)</span>时，<span class="math inline">\(H(P) = 0\)</span></li>
</ol>
<p>在深度学习中，熵主要作为分类问题损失函数的基础——交叉熵。以下示例计算了不同概率分布的熵，并可视化了二项分布的熵。</p>
<div id="cell-35" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_02.information_theory <span class="im">import</span> calculate_entropy</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>calculate_entropy()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Entropy of fair coin: 0.69
Entropy of biased coin: 0.33
Entropy of fair die: 1.39</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="02_深度学习的数学_files/figure-html/cell-10-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="互信息" class="level4">
<h4 class="anchored" data-anchor-id="互信息">互信息</h4>
<p>互信息（Mutual Information）测量两个随机变量X和Y之间的相互依赖性。数学上定义如下。</p>
<p><span class="math display">\[I(X;Y) = \sum_{x}\sum_{y} P(x,y) \log \frac{P(x,y)}{P(x)P(y)}\]</span></p>
<p>互信息的主要特性包括：</p>
<ol type="1">
<li>非负性: <span class="math inline">\(I(X;Y) \ge 0\)</span></li>
<li>对称性: <span class="math inline">\(I(X;Y) = I(Y;X)\)</span></li>
<li>X和Y独立时为0: 如果X和Y独立，则<span class="math inline">\(I(X;Y) = 0\)</span></li>
</ol>
<p>互信息在特征选择、降维等机器学习任务中得到广泛应用。下面的示例计算并可视化了一个简单的联合概率分布的互信息。</p>
<div id="cell-37" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_02.information_theory <span class="im">import</span> mutual_information_example</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>mutual_information_example()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Mutual Information: 0.0058</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="02_深度学习的数学_files/figure-html/cell-11-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="kl-散度" class="level4">
<h4 class="anchored">KL 散度</h4>
<p>KL(Kullback-Leibler)散度是一种衡量两个概率分布 P 和 Q 之间差异的方法。P 关于 Q 的 KL 散度定义如下。</p>
<p><span class="math display">\[D_{KL}(P||Q) = \sum_{x} P(x) \log \frac{P(x)}{Q(x)}\]</span></p>
<p>KL 散度的主要特性包括：</p>
<ol type="1">
<li>非负性: <span class="math inline">\(D_{KL}(P||Q) \ge 0\)</span></li>
<li>当且仅当 P = Q 时为 0: <span class="math inline">\(D_{KL}(P||Q) = 0\)</span> if and only if <span class="math inline">\(P = Q\)</span></li>
<li>非对称性: 通常情况下，<span class="math inline">\(D_{KL}(P||Q) \ne D_{KL}(Q||P)\)</span></li>
</ol>
<p>在深度学习中，KL 散度有以下应用：</p>
<ol type="1">
<li>变分推断：用于最小化近似分布与实际分布之间的差异。</li>
<li>模型压缩：在教师-学生网络中用于知识蒸馏。</li>
<li>异常检测：用于衡量与正常数据分布的差异。</li>
</ol>
<p>信息论的概念之间是密切相关的。例如，互信息可以表示为熵和条件熵之差。</p>
<p><span class="math inline">\(I(X;Y) = H(X) - H(X|Y)\)</span></p>
<p>此外，KL 散度可以表示为交叉熵和熵之差。</p>
<p><span class="math inline">\(D_{KL}(P||Q) = H(P,Q) - H(P)\)</span></p>
<p>其中 <span class="math inline">\(H(P,Q)\)</span> 是 P 和 Q 的交叉熵。以下计算两个概率分布之间的 KL 散度并可视化这些分布。</p>
<div id="cell-39" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dldna.chapter_02.information_theory <span class="im">import</span> kl_divergence_example</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>kl_divergence_example()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>KL(P||Q): 0.0823
KL(Q||P): 0.0872</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="02_深度学习的数学_files/figure-html/cell-12-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>这些信息理论的概念在深度学习模型的设计和优化中得到了广泛的应用。例如，使用重构误差和KL散度的组合作为自编码器的损失函数，或者在强化学习中将KL散度用作策略优化的约束条件等，这些都是应用方式。</p>
<p>在下一章中，我们将探讨这些概率、统计和信息理论的概念如何在实际的深度学习模型中得到应用。</p>
<div class="callout callout-style-default callout-note callout-titled" title="深度潜水：信息理论核心概念">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-9-contents" aria-controls="callout-9" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
深度潜水：信息理论核心概念
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-9" class="callout-9-contents callout-collapse collapse">
<section id="信息理论核心概念---information-content-cross-entropy-kl-divergence-mutual-information" class="level2 callout-body-container callout-body">
<h2 class="anchored" data-anchor-id="信息理论核心概念---information-content-cross-entropy-kl-divergence-mutual-information">信息理论核心概念 - Information Content, Cross Entropy, KL-Divergence, Mutual Information</h2>
<section id="信息量-self-information" class="level3">
<h3 class="anchored" data-anchor-id="信息量-self-information">1. 信息量 (Self-information)</h3>
<ul>
<li><p><strong>定义:</strong> 信息量（Information Content, Self-information）表示特定事件发生时可以获得的信息量。发生的事件越罕见，其信息量就越高。</p></li>
<li><p><strong>公式:</strong> <span class="math display">\[I(x) = -\log(P(x))\]</span></p>
<ul>
<li><span class="math inline">\(x\)</span>: 事件</li>
<li><span class="math inline">\(P(x)\)</span>: 事件<span class="math inline">\(x\)</span>发生的概率</li>
<li><span class="math inline">\(\log\)</span>: 对数的底（base）可以是2（单位：bits），<span class="math inline">\(e\)</span>（单位：nats），或者10等。通常在深度学习中使用自然对数（<span class="math inline">\(e\)</span>）。</li>
</ul></li>
<li><p><strong>直观解释:</strong></p>
<ul>
<li><strong>稀有性:</strong> 概率低的事件（罕见事件）的信息量更大。例如，“太阳从东方升起”是一个显而易见的事实，因此信息量几乎为零；而“今天赢得了彩票一等奖”是一个非常罕见的事件，因此信息量很大。</li>
<li><strong>不确定性减少:</strong> 信息量可以解释为在事件发生前后的不确定性减少了多少。</li>
</ul></li>
<li><p><strong>性质:</strong></p>
<ul>
<li><span class="math inline">\(0 \le P(x) \le 1\)</span> 因此，<span class="math inline">\(I(x) \ge 0\)</span>。</li>
<li><span class="math inline">\(P(x) = 1\)</span>（确定性事件）时，<span class="math inline">\(I(x) = 0\)</span>。</li>
<li><span class="math inline">\(P(x)\)</span>越小，<span class="math inline">\(I(x)\)</span>越大。</li>
<li>对于两个独立的事件<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>，有<span class="math inline">\(I(x, y) = I(x) + I(y)\)</span>。（信息量的可加性）</li>
</ul></li>
</ul>
</section>
<section id="交叉熵-cross-entropy" class="level3">
<h3 class="anchored" data-anchor-id="交叉熵-cross-entropy">2. 交叉熵 (Cross Entropy)</h3>
<ul>
<li><p><strong>定义:</strong> 交叉熵（Cross Entropy）是衡量两个概率分布<span class="math inline">\(P\)</span>和<span class="math inline">\(Q\)</span>差异的指标。当<span class="math inline">\(P\)</span>为真实分布，<span class="math inline">\(Q\)</span>为估计分布时，使用<span class="math inline">\(Q\)</span>表示<span class="math inline">\(P\)</span>所需的平均比特数。</p></li>
<li><p><strong>推导:</strong></p>
<ol type="1">
<li><strong>信息量:</strong> 真实分布<span class="math inline">\(P\)</span>下的事件<span class="math inline">\(x\)</span>的信息量：<span class="math inline">\(I(x) = -\log P(x)\)</span></li>
<li><strong>平均信息量（熵）:</strong> 真实分布<span class="math inline">\(P\)</span>的平均信息量（熵）: <span class="math inline">\(H(P) = -\sum_{x} P(x) \log P(x)\)</span></li>
<li><strong>使用估计分布:</strong> 使用估计分布<span class="math inline">\(Q\)</span>表示真实分布<span class="math inline">\(P\)</span>时，每个事件<span class="math inline">\(x\)</span>的信息量：<span class="math inline">\(-\log Q(x)\)</span></li>
<li><strong>交叉熵:</strong> 使用估计分布<span class="math inline">\(Q\)</span>表示真实分布<span class="math inline">\(P\)</span>时的平均信息量: <span class="math display">\[H(P, Q) = -\sum_{x} P(x) \log Q(x)\]</span></li>
</ol></li>
<li><p><strong>直观解释:</strong></p>
<ul>
<li><span class="math inline">\(P\)</span>和<span class="math inline">\(Q\)</span>越相似，交叉熵就越小。</li>
<li>当<span class="math inline">\(P = Q\)</span>时，交叉熵达到最小值（熵<span class="math inline">\(H(P)\)</span>）。</li>
<li><span class="math inline">\(P\)</span>和<span class="math inline">\(Q\)</span>相差越大，交叉熵就越大。也就是说，估计分布与实际分布的吻合度越低，信息损失就越高。</li>
</ul></li>
<li><p><strong>二元交叉熵 (BCE):</strong></p>
<ul>
<li>用于具有两个类（0或1）的二分类问题。</li>
<li><span class="math inline">\(P = [p, 1-p]\)</span>（实际类别概率分布，<span class="math inline">\(p\)</span>是类别1的概率）</li>
<li><span class="math inline">\(Q = [q, 1-q]\)</span>（预测类别概率分布，<span class="math inline">\(q\)</span>是预测为类别1的概率）</li>
<li><span class="math display">\[H(P, Q) = -[p \log q + (1-p) \log (1-q)]\]</span></li>
</ul></li>
<li><p><strong>类别交叉熵 (CCE):</strong></p>
<ul>
<li>在具有多个类别的多分类问题中使用。</li>
<li><span class="math inline">\(P = [p_1, p_2, ..., p_k]\)</span>（实际类别概率分布，<span class="math inline">\(p_i\)</span>是第<span class="math inline">\(i\)</span>个类别的概率，one-hot 编码）</li>
<li><span class="math inline">\(Q = [q_1, q_2, ..., q_k]\)</span>（预测类别概率分布，<span class="math inline">\(q_i\)</span>是预测为第<span class="math inline">\(i\)</span>个类别的概率，softmax）</li>
<li><span class="math display">\[H(P, Q) = -\sum_{i=1}^{k} p_i \log q_i\]</span></li>
</ul></li>
</ul>
</section>
<section id="交叉熵与似然" class="level3">
<h3 class="anchored" data-anchor-id="交叉熵与似然">3. 交叉熵与似然</h3>
<ul>
<li><strong>似然 (可能性):</strong> 给定数据在特定模型（参数）下发生的概率。</li>
<li><strong>负对数似然 (NLL):</strong> 对似然取对数后再取负值。</li>
<li><strong>交叉熵与NLL的关系:</strong>
<ul>
<li>在分类问题中，将模型的输出（预测概率分布）记为<span class="math inline">\(Q\)</span>，实际标签（one-hot 编码）记为<span class="math inline">\(P\)</span>时，交叉熵等于负对数似然。</li>
<li>最小化交叉熵等同于最大化似然（最大似然估计，MLE）。</li>
</ul></li>
<li><strong>在深度学习中的应用:</strong>
<ul>
<li>在深度学习中使用交叉熵作为分类问题的损失函数（loss function），相当于使模型的输出遵循实际标签分布的学习过程（从MLE的角度看）。</li>
</ul></li>
</ul>
</section>
<section id="kl-散度与交叉熵的关系" class="level3">
<h3 class="anchored" data-anchor-id="kl-散度与交叉熵的关系">4. KL 散度与交叉熵的关系</h3>
<ul>
<li><p><strong>KL 散度 (Kullback-Leibler Divergence):</strong></p>
<ul>
<li>是衡量两个概率分布<span class="math inline">\(P\)</span>和<span class="math inline">\(Q\)</span>差异的另一种方法（不是距离概念，具有非对称性）。</li>
<li><span class="math inline">\(P\)</span>到<span class="math inline">\(Q\)</span>的KL散度表示使用<span class="math inline">\(Q\)</span>来表达<span class="math inline">\(P\)</span>时额外需要的信息量。</li>
<li><span class="math display">\[D_{KL}(P||Q) = \sum_{x} P(x) \log \frac{P(x)}{Q(x)} = \sum_{x} P(x)[\log P(x) - \log Q(x)]\]</span></li>
</ul></li>
<li><p><strong>KL 散度与交叉熵的关系:</strong></p>
<p><span class="math display">\[D_{KL}(P||Q) = \sum_{x} P(x) \log P(x) - \sum_{x} P(x) \log Q(x) =  -\sum_{x} P(x) \log Q(x)  - (-\sum_{x} P(x) \log P(x))\]</span> <span class="math display">\[D_{KL}(P||Q) = H(P, Q) - H(P)\]</span></p>
<ul>
<li><p><span class="math inline">\(H(P,Q)\)</span>: 交叉熵</p></li>
<li><p><span class="math inline">\(H(P)\)</span>: 熵</p></li>
<li><p>KL 散度是交叉熵减去<span class="math inline">\(P\)</span>的熵。</p></li>
<li><p>当<span class="math inline">\(P\)</span>固定时，最小化交叉熵等同于最小化KL散度。</p></li>
</ul></li>
</ul>
</section>
<section id="互信息与条件熵的关系" class="level3">
<h3 class="anchored" data-anchor-id="互信息与条件熵的关系">5. 互信息与条件熵的关系</h3>
<ul>
<li><strong>互信息 (Mutual Information):</strong>
<ul>
<li>是衡量两个概率变量<span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>之间共享了多少信息的尺度。</li>
<li>表示已知<span class="math inline">\(X\)</span>时，关于<span class="math inline">\(Y\)</span>的不确定性减少的程度（或反之亦然）。</li>
<li><span class="math display">\[I(X;Y) = \sum_{x, y} P(x, y) \log \frac{P(x, y)}{P(x)P(y)}\]</span>
<ul>
<li><span class="math inline">\(P(x,y)\)</span>: 联合概率分布 (Joint Probability Distribution)</li>
<li><span class="math inline">\(P(x)\)</span>, <span class="math inline">\(P(y)\)</span>: 边缘概率分布 (Marginal Probability Distribution)</li>
</ul></li>
</ul></li>
<li><strong>条件熵 (Conditional Entropy):</strong>
<ul>
<li>当给定概率变量 <span class="math inline">\(Y\)</span> 时，表示概率变量 <span class="math inline">\(X\)</span> 的不确定性。 <span class="math display">\[H(X|Y) = -\sum_{y} P(y) \sum_{x} P(x|y) \log P(x|y) =  -\sum_{x,y} P(x,y) \log P(x|y)\]</span></li>
</ul></li>
<li><strong>互信息与条件熵的关系</strong>: <span class="math display">\[I(X;Y) = H(X) - H(X|Y) = H(Y) - H(Y|X)\]</span>
<ul>
<li><span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 的互信息量等于从 <span class="math inline">\(X\)</span> 的熵中减去已知 <span class="math inline">\(Y\)</span> 时的 <span class="math inline">\(X\)</span> 的条件熵。</li>
<li>表示因得知 <span class="math inline">\(Y\)</span> 而使 <span class="math inline">\(X\)</span> 的不确定性减少的程度。</li>
</ul></li>
</ul>
</section>
<section id="jensenshannon-散度" class="level3">
<h3 class="anchored" data-anchor-id="jensenshannon-散度">6. Jensen–Shannon 散度</h3>
<ul>
<li><strong>Jensen–Shannon 散度 (JSD):</strong>
<ul>
<li>另一种测量两个概率分布 <span class="math inline">\(P\)</span> 和 <span class="math inline">\(Q\)</span> 之间距离的方法。与 KL 散度不同，它是对称的 (symmetric) 并且有界（在 0 和 1 之间）。</li>
<li><span class="math display">\[JSD(P||Q) = \frac{1}{2}D_{KL}(P||M) + \frac{1}{2}D_{KL}(Q||M)\]</span>
<ul>
<li><span class="math inline">\(M = \frac{1}{2}(P + Q)\)</span>: <span class="math inline">\(P\)</span> 和 <span class="math inline">\(Q\)</span> 的平均分布</li>
</ul></li>
</ul></li>
<li><strong>特性:</strong>
<ul>
<li>对称性: <span class="math inline">\(JSD(P||Q) = JSD(Q||P)\)</span></li>
<li>有界性: <span class="math inline">\(0 \le JSD(P||Q) \le 1\)</span> (使用以 2 为底的对数时)</li>
<li>JSD 的平方根满足距离函数 (metric) 的条件。</li>
</ul></li>
</ul>
</section>
</section>
</div>
</div>
</section>
</section>
<section id="损失函数" class="level3">
<h3 class="anchored" data-anchor-id="损失函数">2.3.4 损失函数</h3>
<p>损失函数（Loss Function）是衡量机器学习模型的预测值与实际值之间差异的函数。模型训练的目标是找到使该损失函数值最小化的参数（权重和偏置）。选择合适的损失函数对模型性能有很大影响，因此需要根据问题类型和数据特性谨慎选择。</p>
<section id="损失函数的定义" class="level4">
<h4 class="anchored" data-anchor-id="损失函数的定义">损失函数的定义</h4>
<p>通常，损失函数 <span class="math inline">\(L\)</span> 可以在将模型参数表示为 <span class="math inline">\(\theta\)</span>，数据点表示为 <span class="math inline">\((x_i, y_i)\)</span> 时，如下所示表达。（这里 <span class="math inline">\(y_i\)</span> 是实际值，<span class="math inline">\(f(x_i; \theta)\)</span> 是模型的预测值）</p>
<p><span class="math inline">\(L(\theta) = \frac{1}{N} \sum_{i=1}^{N} l(y_i, f(x_i; \theta))\)</span></p>
<p><span class="math inline">\(N\)</span> 是数据点的数量，<span class="math inline">\(l\)</span> 是表示单个数据点损失的函数（loss term）。</p>
</section>
<section id="主要损失函数" class="level4">
<h4 class="anchored" data-anchor-id="主要损失函数">主要损失函数</h4>
<p>以下是机器学习和深度学习中常用的损失函数。</p>
<section id="均方误差-mean-squared-error-mse" class="level5">
<h5 class="anchored" data-anchor-id="均方误差-mean-squared-error-mse">1. 均方误差 (Mean Squared Error, MSE)</h5>
<ul>
<li><strong>公式:</strong> <span class="math inline">\(MSE = \frac{1}{N} \sum_{i=1}^N (y_i - \hat{y}_i)^2\)</span> (<span class="math inline">\(y_i\)</span>: 实际值, <span class="math inline">\(\hat{y}_i\)</span>: 预测值)</li>
<li><strong>特点:</strong>
<ul>
<li>因为误差被平方，所以对异常值（outlier）敏感。</li>
<li>可微，并且是凸函数（convex function），因此容易使用梯度下降法找到最优解。</li>
</ul></li>
<li><strong>用途:</strong> 主要用于回归（Regression）问题。</li>
</ul>
</section>
<section id="平均绝对误差-mean-absolute-error-mae" class="level5">
<h5 class="anchored" data-anchor-id="平均绝对误差-mean-absolute-error-mae">2. 平均绝对误差 (Mean Absolute Error, MAE)</h5>
<ul>
<li><strong>公式:</strong> <span class="math inline">\(MAE = \frac{1}{N} \sum_{i=1}^N |y_i - \hat{y}_i|\)</span></li>
<li><strong>特点:</strong>
<ul>
<li>比MSE对异常值不那么敏感。</li>
<li>在x=0处不可微，但在深度学习框架中可以使用自动微分处理。</li>
</ul></li>
<li><strong>用途</strong>: 用于回归问题</li>
</ul>
</section>
<section id="交叉熵损失-cross-entropy-loss" class="level5">
<h5 class="anchored" data-anchor-id="交叉熵损失-cross-entropy-loss">3. 交叉熵损失 (Cross-Entropy Loss)</h5>
<ul>
<li><strong>公式:</strong>
<ul>
<li><strong>二分类 (Binary Classification):</strong> <span class="math inline">\(L = -\frac{1}{N} \sum_{i=1}^N [y_i \log(\hat{y}_i) + (1-y_i) \log(1-\hat{y}_i)]\)</span></li>
<li><strong>多类分类 (Multi-class Classification):</strong> <span class="math inline">\(L = -\frac{1}{N} \sum_{i=1}^N \sum_{j=1}^C y_{ij} \log(\hat{y}_{ij})\)</span> (<span class="math inline">\(C\)</span>: 类别数)</li>
</ul></li>
<li><strong>特点:</strong>
<ul>
<li>衡量模型预测的概率分布与实际分布之间的差异。</li>
<li>在分类问题中，比MSE收敛更快。</li>
<li>输出层使用softmax激活函数时使用。</li>
</ul></li>
<li><strong>用途:</strong> 分类问题（二分类、多类分类）</li>
</ul>
</section>
<section id="铰链损失-hinge-loss" class="level5">
<h5 class="anchored" data-anchor-id="铰链损失-hinge-loss">4. 铰链损失 (Hinge Loss)</h5>
<ul>
<li><strong>公式:</strong> <span class="math inline">\(L = \max(0, 1 - y \cdot f(x))\)</span> (<span class="math inline">\(y\)</span>: {-1, 1} 实际类别, <span class="math inline">\(f(x)\)</span>: 模型预测值)</li>
<li><strong>特点:</strong>
<ul>
<li>最大化“正确”与“错误”之间的边界（margin）。</li>
<li>在x=1处不可微</li>
</ul></li>
<li><strong>用途:</strong> 主要用于支持向量机（SVM）等二分类问题。</li>
</ul>
</section>
</section>
<section id="损失函数选择标准" class="level4">
<h4 class="anchored" data-anchor-id="损失函数选择标准">损失函数选择标准</h4>
<ul>
<li><strong>问题类型:</strong> 根据是回归问题还是分类问题，合适的损失函数会有所不同。</li>
<li><strong>数据特性:</strong> 需要考虑异常值、类别不平衡等因素来选择适当的损失函数。</li>
<li><strong>模型</strong>: 使用的模型不同，合适的损失函数也会不同。</li>
</ul>
</section>
<section id="其他损失函数" class="level4">
<h4 class="anchored">其他损失函数</h4>
<ul>
<li><strong>Kullback-Leibler Divergence (KLD):</strong> 测量两个概率分布 P 和 Q 之间的差异。主要用于变分自编码器(VAE)等生成模型。</li>
<li><strong>Focal Loss:</strong> 调整了交叉熵的损失函数，以在不平衡数据中更好地工作。主要应用于对象检测问题。</li>
<li><strong>Huber Loss:</strong> 结合了MSE和MAE的形式，对异常值具有鲁棒性同时保持可微分。</li>
<li><strong>Log-Cosh Loss:</strong> 与Huber Loss类似，但优点是在所有点上都是二阶可微的。</li>
<li><strong>Contrastive Loss:</strong> 在Siamese Network等中使用，用于学习嵌入，使相似样本对更接近，不相似样本对远离。</li>
<li><strong>Triplet Loss:</strong> 使用Anchor、Positive和Negative三个样本，以使Anchor与Positive样本之间的距离变近，Anchor与Negative样本之间的距离变远来学习嵌入。</li>
<li><strong>CTC Loss:</strong> 在语音识别、手写识别等任务中使用的损失函数，用于输入序列和输出序列长度不同时的情况。</li>
</ul>
<div class="callout callout-style-default callout-note callout-titled" title="点击查看内容（深入探讨：损失函数深度分析）">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-10-contents" aria-controls="callout-10" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
点击查看内容（深入探讨：损失函数深度分析）
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-10" class="callout-10-contents callout-collapse collapse">
<section id="损失函数深入分析" class="level3 callout-body-container callout-body">
<h3 class="anchored" data-anchor-id="损失函数深入分析">损失函数深入分析</h3>
<section id="损失函数与最大似然估计maximum-likelihood-estimation-mle" class="level4">
<h4 class="anchored" data-anchor-id="损失函数与最大似然估计maximum-likelihood-estimation-mle">损失函数与最大似然估计（Maximum Likelihood Estimation, MLE）</h4>
<p>许多机器学习模型的训练可以从最大似然估计(MLE)的角度进行解释。MLE是一种寻找最能解释给定数据的模型参数的方法。假设数据是独立同分布(i.i.d.)的，那么似然函数(Likelihood Function)可以定义如下。</p>
<p><span class="math inline">\(L(\theta) = P(D|\theta) = \prod_{i=1}^{N} P(y_i | x_i; \theta)\)</span></p>
<p>这里，<span class="math inline">\(D = \{(x_1, y_1), (x_2, y_2), ..., (x_N, y_N)\}\)</span>是训练数据，<span class="math inline">\(\theta\)</span>是模型参数。<span class="math inline">\(P(y_i | x_i; \theta)\)</span>是在输入<span class="math inline">\(x_i\)</span>时，模型输出<span class="math inline">\(y_i\)</span>的概率（或概率密度）。</p>
<p>MLE的目标是找到使似然函数<span class="math inline">\(L(\theta)\)</span>最大化的参数<span class="math inline">\(\theta\)</span>。实际上，最大化对数似然函数(log-likelihood function)在计算上更为方便。</p>
<p><span class="math inline">\(\log L(\theta) = \sum_{i=1}^{N} \log P(y_i | x_i; \theta)\)</span></p>
<ul>
<li><p><strong>MSE与MLE：</strong> 在线性回归模型中，如果假设误差服从均值为0、方差为<span class="math inline">\(\sigma^2\)</span>的正态分布，则MLE等同于最小化MSE。</p>
<p><span class="math inline">\(P(y_i | x_i; \theta) = \frac{1}{\sqrt{2\pi\sigma^2}} \exp\left(-\frac{(y_i - f(x_i; \theta))^2}{2\sigma^2}\right)\)</span></p>
<p>对数似然函数如下。 <span class="math inline">\(\log L(\theta) = -\frac{N}{2}\log(2\pi\sigma^2) - \frac{1}{2\sigma^2}\sum_{i=1}^{N}(y_i - f(x_i;\theta))^2\)</span></p>
<p>除了常数项外，假设<span class="math inline">\(\sigma^2\)</span>为常数，则最大化对数似然函数等同于最小化MSE。</p></li>
<li><p><strong>交叉熵与MLE：</strong> 在分类问题中，可以将输出<span class="math inline">\(\hat{y}_i\)</span>解释为伯努利分布（二分类）或多项分布（多类别分类）的参数。在这种情况下，MLE等同于最小化交叉熵损失。</p>
<ul>
<li><p><strong>二分类（伯努利分布）</strong>：假设<span class="math inline">\(\hat{y_i}\)</span>是模型预测的<span class="math inline">\(y_i=1\)</span>的概率， <span class="math inline">\(P(y_i|x_i;\theta) = \hat{y_i}^{y_i} (1 - \hat{y_i})^{(1-y_i)}\)</span> 对数似然：<span class="math inline">\(\log L(\theta) = \sum_{i=1}^{N} [y_i \log(\hat{y}_i) + (1 - y_i)\log(1 - \hat{y}_i)]\)</span></p></li>
<li><p><strong>多类别分类（Categorical/Multinoulli 分布）</strong>： <span class="math inline">\(P(y_i | x_i; \theta) = \prod_{j=1}^{C} \hat{y}_{ij}^{y_{ij}}\)</span>（one-hot 编码） 对数似然：<span class="math inline">\(\log L(\theta) = \sum_{i=1}^N \sum_{j=1}^C y_{ij} \log(\hat{y}_{ij})\)</span></p></li>
</ul>
<p>因此，最小化交叉熵损失的过程等同于寻找最能建模数据分布的参数的MLE。</p></li>
</ul>
</section>
<section id="其他损失函数kld-focal-loss" class="level4">
<h4 class="anchored" data-anchor-id="其他损失函数kld-focal-loss">其他损失函数（KLD, Focal Loss）</h4>
<ul>
<li><p><strong>Kullback-Leibler 散度 (KLD)：</strong></p></li>
<li><p><strong>描述:</strong> 测量两个概率分布P和Q之间的差异。P表示实际数据的分布，Q表示模型估计的分布。</p>
<ul>
<li><strong>公式:</strong> <span class="math inline">\(D_{KL}(P||Q) = \sum_{x} P(x) \log \frac{P(x)}{Q(x)}\)</span></li>
<li><strong>特性:</strong>
<ul>
<li>非对称性(asymmetric): <span class="math inline">\(D_{KL}(P||Q) \neq D_{KL}(Q||P)\)</span></li>
<li>总是非负的: <span class="math inline">\(D_{KL}(P||Q) \ge 0\)</span>, 只有当<span class="math inline">\(P=Q\)</span>时，<span class="math inline">\(D_{KL}(P||Q) = 0\)</span></li>
<li>在P(x) = 0的地方未定义的问题</li>
</ul></li>
<li><strong>与VAE的关系:</strong>
<ul>
<li>在变分自编码器(Variational Autoencoder, VAE)中，使用KL散度来使潜在变量(latent variable)的后验分布(posterior distribution)接近正态分布等先验分布(prior distribution)。</li>
<li>VAE的损失函数由重构损失(reconstruction loss)和KL散度项组成。</li>
</ul></li>
</ul></li>
<li><p><strong>Focal Loss:</strong></p>
<ul>
<li><strong>描述:</strong> 为了解决类别不平衡问题，特别是“简单”样本(easy examples)与“困难”样本(hard examples)之间的不平衡而提出的交叉熵损失(Cross-Entropy Loss)的变体。</li>
<li><strong>公式:</strong> <span class="math inline">\(FL(p_t) = -\alpha_t (1 - p_t)^\gamma \log(p_t)\)</span>
<ul>
<li><span class="math inline">\(p_t\)</span>: 模型预测的正确类别的概率</li>
<li><span class="math inline">\(\gamma\)</span>: 聚焦参数(<span class="math inline">\(\gamma \ge 0\)</span>，通常为2)</li>
<li><span class="math inline">\(\alpha_t\)</span>: 类别权重（可选）</li>
</ul></li>
<li><strong>特性:</strong>
<ul>
<li>当<span class="math inline">\(\gamma = 0\)</span>时，与普通的交叉熵损失相同。</li>
<li>当<span class="math inline">\(\gamma &gt; 0\)</span>时，对于分类良好的样本(<span class="math inline">\(p_t\)</span>较大)，其损失减少；而对于分类不良的样本(<span class="math inline">\(p_t\)</span>较小)，其损失相对保持较高。即，更多地关注困难样本的学习。</li>
<li>可以使用<span class="math inline">\(\alpha_t\)</span>来调整每个类别的权重（例如：给数量较少的类别更大的权重）。</li>
</ul></li>
<li><strong>在对象检测(Object Detection)中的应用:</strong>
<ul>
<li>对象检测问题中，背景区域(negative)比对象区域(positive)多得多，导致严重的类别不平衡。</li>
<li>Focal Loss缓解了这种不平衡，使对象检测模型更专注于学习实际对象而非背景。</li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="各种损失函数高级" class="level4">
<h4 class="anchored" data-anchor-id="各种损失函数高级">各种损失函数（高级）</h4>
<ul>
<li><p><strong>Huber Loss:</strong> 结合了MSE和MAE优点的损失函数。当误差小于某个值(<span class="math inline">\(\delta\)</span>)时使用平方误差(MSE)，当误差较大时使用绝对误差(MAE)。对异常值具有鲁棒性，同时可微分。</p>
<p><span class="math inline">\(L_\delta(y, \hat{y}) = \begin{cases}
\frac{1}{2}(y - \hat{y})^2 &amp; \text{if } |y - \hat{y}| \le \delta \\
\delta(|y - \hat{y}| - \frac{1}{2}\delta) &amp; \text{otherwise}
\end{cases}\)</span></p></li>
<li><p><strong>Log-Cosh Loss:</strong> 定义为<span class="math inline">\(\log(\cosh(y - \hat{y}))\)</span>。与Huber Loss类似，对异常值具有鲁棒性，并且在所有点上都可二阶微分。</p></li>
<li><p><strong>Quantile Loss:</strong> 用于最小化特定分位数(quantile)的预测误差。</p></li>
<li><p><strong>对比损失，三元组损失：</strong> 用于Siamese Network、Triplet Network等，用于调整相似样本对/三元组之间的距离。（详情参见相关论文）</p></li>
<li><p><strong>连接时序分类（CTC）损失</strong>：在语音识别、手写识别等输入序列与输出序列之间的对齐(alignment)不明确的情况下使用。</p></li>
</ul>
</section>
<section id="损失函数选择指南进阶" class="level4">
<h4 class="anchored" data-anchor-id="损失函数选择指南进阶">损失函数选择指南（进阶）</h4>
<ul>
<li><strong>异常值处理：</strong> 如果存在大量异常值，且需要对异常值具有鲁棒性(robust)，可以考虑MAE、Huber Loss、Quantile Loss等。</li>
<li><strong>可微分性：</strong> 为了基于梯度下降的优化，需要一个可微分的损失函数。但是，即使像Hinge Loss、MAE这样存在不可微分点的情况，也可以通过使用次梯度(subdifferential)或深度学习框架中的自动微分来解决。</li>
<li><strong>概率建模：</strong> 如果希望将模型的输出解释为概率分布，Cross-Entropy Loss是合适的。</li>
<li><strong>类别不平衡：</strong> 在类别严重不平衡的情况下，可以考虑Focal Loss、Weighted Cross-Entropy等。</li>
<li><strong>多输出</strong>：如果有多个输出且输出之间存在相关性，则可以结合使用每个输出的损失函数。</li>
</ul>
<p>损失函数是决定深度学习模型性能的重要因素之一。根据问题的特性、数据的分布以及模型的结构选择合适的损失函数，并在必要时设计新的损失函数，这是对深度学习工程师的要求。</p>
</section>
</section>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled" title="点击查看内容（深入探讨：新的损失函数设计）">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-11-contents" aria-controls="callout-11" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
点击查看内容（深入探讨：新的损失函数设计）
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-11" class="callout-11-contents callout-collapse collapse">
<section id="新的损失函数设计" class="level3 callout-body-container callout-body">
<h3 class="anchored" data-anchor-id="新的损失函数设计">新的损失函数设计</h3>
<p>现有的损失函数（MSE、交叉熵等）并不总是最佳选择。根据问题的特定需求、数据分布和模型结构，可能需要设计新的损失函数。设计新的损失函数是深度学习研究的重要组成部分，并且具有显著提升模型性能的潜力。</p>
<section id="需要新损失函数的情况" class="level4">
<h4 class="anchored" data-anchor-id="需要新损失函数的情况">需要新损失函数的情况</h4>
<ul>
<li><strong>数据的特殊结构：</strong> 数据不符合常见的分布（高斯、伯努利等），或者具有特殊的结构（例如：排序、稀疏性、层次结构、图结构）。</li>
<li><strong>问题的特定约束条件：</strong> 希望对模型预测施加特定的约束条件（例如：单调性、稀疏性、公平性、鲁棒性）。</li>
<li><strong>现有损失函数的局限性：</strong> 现有损失函数在某些问题上表现不佳（例如：对异常值敏感、类别不平衡），或者不能充分反映目标。希望直接优化特定指标的情况。</li>
<li><strong>多目标优化 (Multi-objective optimization)：</strong> 需要结合多个损失函数同时进行优化的情况。（例如：预测准确率与模型复杂度之间的平衡）</li>
<li><strong>生成模型</strong>：生成模型（Generative Models）的目标是学习数据的分布，因此需要不同于常规分类/回归问题的损失函数。</li>
</ul>
</section>
<section id="新损失函数设计原则" class="level4">
<h4 class="anchored" data-anchor-id="新损失函数设计原则">新损失函数设计原则</h4>
<p>在设计新的损失函数时，应考虑以下原则：</p>
<ol type="1">
<li><p><strong>问题定义和目标：</strong> 必须明确定义要解决的问题以及模型的最终目标。损失函数是定义模型应该学习什么的核心要素。（例如：仅仅提高分类准确率、更好地预测特定类别、调整False Positive/False Negative比率等）</p></li>
<li><p><strong>数学合理性：</strong></p>
<ul>
<li><strong>可微性 (Differentiability)：</strong> 为了基于梯度下降法的优化，损失函数应在几乎所有点上都是可微的。即使在不可微的点，也应能够使用次梯度(subdifferential)。</li>
<li><strong>凸性 (Convexity)：</strong> 如果损失函数是凸函数，则可以保证找到全局最优解(global minimum)。对于非凸(non-convex)函数，也应设计为能找到良好的局部最优解(local minimum)。</li>
<li><strong>防止梯度消失/爆炸 (Gradient Vanishing/Exploding Prevention)：</strong> 过大或过小的梯度会使得学习不稳定。需要注意在特定情况下（如ReLU的“死亡ReLU”问题、sigmoid/tanh的梯度消失问题），梯度不会变为0或非常小。</li>
<li><strong>尺度不变性 (Scale Invariance)：</strong> 损失函数的设计应不受输入数据或参数尺度的影响。</li>
</ul></li>
<li><p><strong>可解释性 (Interpretability)：</strong> 如果能够直观地理解损失函数的意义，将有助于分析和调试模型的学习过程。每个项(term)的作用及其意义必须明确。超参数的意义和影响也必须明确。</p></li>
<li><p><strong>计算效率 (Computational Efficiency)：</strong> 损失函数在每次迭代(iteration)中以及对所有（或小批量）数据点进行计算，因此如果计算成本过高，则会导致学习速度变慢。</p></li>
</ol>
</section>
<section id="新损失函数设计方法论" class="level4">
<h4 class="anchored" data-anchor-id="新损失函数设计方法论">新损失函数设计方法论</h4>
<ol type="1">
<li><p><strong>现有损失函数的修改/组合:</strong></p>
<ul>
<li><strong>添加权重:</strong> 对特定数据点、类别或输出赋予更大的权重（例如：加权交叉熵，Focal Loss）。</li>
<li><strong>增加正则化项:</strong> 添加正则化项以限制模型复杂度或促进某些属性（例如：L1 正则化，L2 正则化，Elastic Net）。也可以添加平滑输出的正则化项。</li>
<li><strong>多个损失函数组合:</strong> 线性组合或以其他方式组合多个现有的损失函数。（例如：多任务学习）</li>
<li><strong>软/硬标签平滑</strong>: 标签平滑正则化防止模型对正确答案过于自信。</li>
</ul></li>
<li><p><strong>基于概率建模的设计:</strong></p>
<ul>
<li><strong>最大似然估计 (MLE):</strong> 假设数据分布，并从该分布的参数估计的角度设计损失函数。（例如：MSE 是高斯分布假设下的 MLE，交叉熵是伯努利/多项分布假设下的 MLE）</li>
<li><strong>变分推断:</strong> 使用近似推理（variational inference）方法来设计逼近不可解后验分布（posterior distribution）的损失函数（ELBO, Evidence Lower Bound）。(例如：变分自编码器)</li>
<li><strong>隐式似然</strong>: 在生成模型中难以显式计算似然时，使用无似然方法（例如：GAN）</li>
</ul></li>
<li><p><strong>问题特定损失函数设计:</strong></p>
<ul>
<li><strong>排序损失:</strong> 设计适用于排序问题的损失函数（例如：成对排名损失，列表级排名损失，边缘排名损失）。</li>
<li><strong>目标检测损失:</strong> 在目标检测问题中，设计同时考虑边界框回归和类别分类的损失函数（例如：YOLO、SSD、Faster R-CNN 的损失函数）。</li>
<li><strong>分割损失:</strong> 在图像分割问题中，设计预测每个像素类别的损失函数，并最小化与真实分割图的差异（例如：Dice Loss, IoU Loss, Tversky Loss）。</li>
<li><strong>生成模型损失:</strong> 设计用于生成器和判别器的损失函数，在 GAN、VAE 等生成模型中使用（例如：Wasserstein 距离，对抗性损失）。</li>
<li><strong>度量学习损失</strong>: Contrastive Loss, Triplet Loss, N-pair Loss 等。</li>
<li><strong>序列损失:</strong> CTC 损失，序列到序列模型的交叉熵等。</li>
<li><strong>图数据损失</strong>: 在图神经网络中使用的设计用于节点分类、链接预测、图分类等任务的损失函数</li>
</ul></li>
</ol>
</section>
<section id="设计新的损失函数时的注意事项" class="level4">
<h4 class="anchored" data-anchor-id="设计新的损失函数时的注意事项">设计新的损失函数时的注意事项</h4>
<ul>
<li><strong>过度复杂性:</strong> 过于复杂的损失函数会使学习变得困难，并可能导致过拟合(overfitting)。最好从简单的损失函数开始，逐渐增加复杂度。</li>
<li><strong>超参数调整:</strong> 新的损失函数通常包含额外的超参数（例如：Focal Loss的<span class="math inline">\(\gamma\)</span>，权重组合时的权重）。正确地调整这些超参数非常重要，需要通过交叉验证(cross-validation)等方法找到最优值。</li>
<li><strong>理论/经验依据:</strong> 提出新的损失函数时，应提供其为何有效工作的理论依据（例如：特定问题的数学特性，与MLE的关系）或经验依据（例如：实验结果）。</li>
</ul>
<p>设计新的损失函数是一个创造性的过程，但同时也需要谨慎。深入理解问题的本质，基于数学/统计原理进行设计，并通过严格的实验验证性能是非常重要的。</p>
</section>
</section>
</div>
</div>
<p>在本章中，我们探讨了深度学习的数学基础。我们研究了线性代数、微积分、概率与统计、信息论等不同领域的概念如何应用于深度学习模型的设计、学习和分析。这些数学工具对于理解复杂的神经网络结构、开发高效的学习算法以及评估和改进模型性能至关重要。此外，它们在深度学习研究的最前沿寻找新的突破方面也发挥着重要作用。</p>
</section>
</section>
</section>
<section id="练习题" class="level2">
<h2 class="anchored" data-anchor-id="练习题">练习题</h2>
<section id="线性代数" class="level3">
<h3 class="anchored">1. 线性代数</h3>
<section id="基础" class="level4">
<h4 class="anchored" data-anchor-id="基础">基础</h4>
<ol type="1">
<li><p>计算两个向量 <span class="math inline">\(\mathbf{a} = \begin{bmatrix} 1 \\ 2 \end{bmatrix}\)</span> 和 <span class="math inline">\(\mathbf{b} = \begin{bmatrix} 3 \\ 4 \end{bmatrix}\)</span> 的内积（dot product）。</p></li>
<li><p>计算矩阵 <span class="math inline">\(\mathbf{A} = \begin{bmatrix} 1 &amp; 2 \\ 3 &amp; 4 \end{bmatrix}\)</span> 和向量 <span class="math inline">\(\mathbf{b} = \begin{bmatrix} 5 \\ 6 \end{bmatrix}\)</span> 的乘积 <span class="math inline">\(\mathbf{Ab}\)</span>。</p></li>
<li><p>创建一个 2x2 单位矩阵（identity matrix）。</p></li>
<li><p>写出向量的 L1 范数和 L2 范数的定义，并计算向量 <span class="math inline">\(\mathbf{v} = \begin{bmatrix} 3 \\ -4 \end{bmatrix}\)</span> 的 L1 范数和 L2 范数。</p></li>
</ol>
</section>
<section id="应用" class="level4">
<h4 class="anchored" data-anchor-id="应用">应用</h4>
<ol type="1">
<li><p>求矩阵 <span class="math inline">\(\mathbf{A} = \begin{bmatrix} 2 &amp; 1 \\ 1 &amp; 2 \end{bmatrix}\)</span> 的特征值（eigenvalue）和特征向量（eigenvector）。</p></li>
<li><p>判断给定矩阵的逆矩阵是否存在，如果存在，则计算其逆矩阵。 <span class="math inline">\(\mathbf{A} = \begin{bmatrix} 1 &amp; 2 \\ 3 &amp; 4 \end{bmatrix}\)</span></p></li>
<li><p>给出线性变换 <span class="math inline">\(T(\mathbf{x}) = \mathbf{Ax}\)</span> 时，解释基向量（basis）<span class="math inline">\(\mathbf{e_1} = \begin{bmatrix} 1 \\ 0 \end{bmatrix}\)</span> 和 <span class="math inline">\(\mathbf{e_2} = \begin{bmatrix} 0 \\ 1 \end{bmatrix}\)</span> 如何变换，并可视化其结果。（给定 <span class="math inline">\(\mathbf{A} = \begin{bmatrix} 2 &amp; -1 \\ 1 &amp; 1 \end{bmatrix}\)</span>）</p></li>
<li><p>计算下列矩阵的秩（rank）。 <span class="math inline">\(\mathbf{A} = \begin{bmatrix} 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6 \\ 7 &amp; 8 &amp; 9 \end{bmatrix}\)</span></p></li>
</ol>
</section>
<section id="深化" class="level4">
<h4 class="anchored">深化</h4>
<ol type="1">
<li><p>写出奇异值分解（Singular Value Decomposition, SVD）的定义，并将给定矩阵 <span class="math inline">\(\mathbf{A}\)</span> 进行 SVD 分解。 <span class="math inline">\(\mathbf{A} = \begin{bmatrix} 1 &amp; 2 \\ 3 &amp; 4 \\ 5 &amp; 6 \end{bmatrix}\)</span></p></li>
<li><p>解释主成分分析（Principal Component Analysis, PCA）的目的和过程，并对给定数据集进行 PCA，将其降维到一维。</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> np.array([[<span class="dv">1</span>, <span class="dv">2</span>], [<span class="dv">2</span>, <span class="dv">3</span>], [<span class="dv">3</span>, <span class="dv">4</span>], [<span class="dv">4</span>, <span class="dv">5</span>], [<span class="dv">5</span>, <span class="dv">6</span>]])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
<li><p>求下列矩阵的零空间（null space）和列空间（column space）的基向量。 <span class="math inline">\(\mathbf{A} = \begin{bmatrix} 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6 \\ 7 &amp; 8 &amp; 9 \end{bmatrix}\)</span></p></li>
<li><p>写出 QR 分解的定义，并将给定矩阵 <span class="math inline">\(\mathbf{A}\)</span> 进行 QR 分解。（QR 分解是一种数值上稳定的方法，用于求解线性方程组或解决特征值问题。） <span class="math inline">\(\mathbf{A} = \begin{bmatrix} 1 &amp; 2 \\ 3 &amp; 4 \end{bmatrix}\)</span></p></li>
</ol>
<div class="callout callout-style-default callout-note callout-titled" title="点击查看内容（答案）">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-12-contents" aria-controls="callout-12" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
点击查看内容（答案）
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-12" class="callout-12-contents callout-collapse collapse">
<section id="练习题解答" class="level2 callout-body-container callout-body">
<h2 class="anchored" data-anchor-id="练习题解答">练习题解答</h2>
<section id="线性代数-1" class="level3">
<h3 class="anchored" data-anchor-id="线性代数-1">1. 线性代数</h3>
<section id="基础-1" class="level4">
<h4 class="anchored" data-anchor-id="基础-1">基础</h4>
<ol type="1">
<li><p><strong>内积计算:</strong> <span class="math inline">\(\mathbf{a} \cdot \mathbf{b} = (1)(3) + (2)(4) = 3 + 8 = 11\)</span></p></li>
<li><p><strong>矩阵-向量乘法:</strong> <span class="math inline">\(\mathbf{Ab} = \begin{bmatrix} 1 &amp; 2 \\ 3 &amp; 4 \end{bmatrix} \begin{bmatrix} 5 \\ 6 \end{bmatrix} = \begin{bmatrix} (1)(5) + (2)(6) \\ (3)(5) + (4)(6) \end{bmatrix} = \begin{bmatrix} 17 \\ 39 \end{bmatrix}\)</span></p></li>
<li><p><strong>2x2 单位矩阵:</strong> <span class="math inline">\(\mathbf{I} = \begin{bmatrix} 1 &amp; 0 \\ 0 &amp; 1 \end{bmatrix}\)</span></p></li>
<li><p><strong>L1, L2 范数:</strong></p>
<ul>
<li>L1 范数（曼哈顿距离）: <span class="math inline">\(||\mathbf{v}||_1 = \sum_{i} |v_i|\)</span></li>
<li>L2 范数（欧几里得距离）: <span class="math inline">\(||\mathbf{v}||_2 = \sqrt{\sum_{i} v_i^2}\)</span></li>
</ul>
<p><span class="math inline">\(\mathbf{v} = \begin{bmatrix} 3 \\ -4 \end{bmatrix}\)</span> <span class="math inline">\(||\mathbf{v}||_1 = |3| + |-4| = 3 + 4 = 7\)</span> <span class="math inline">\(||\mathbf{v}||_2 = \sqrt{(3)^2 + (-4)^2} = \sqrt{9 + 16} = \sqrt{25} = 5\)</span></p></li>
</ol>
</section>
<section id="应用-1" class="level4">
<h4 class="anchored" data-anchor-id="应用-1">应用</h4>
<ol type="1">
<li><p><strong>特征值，特征向量:</strong> <span class="math inline">\(\mathbf{A} = \begin{bmatrix} 2 &amp; 1 \\ 1 &amp; 2 \end{bmatrix}\)</span></p>
<ul>
<li><p><strong>特征方程:</strong> <span class="math inline">\(\det(\mathbf{A} - \lambda\mathbf{I}) = 0\)</span> <span class="math inline">\((2-\lambda)^2 - (1)(1) = 0\)</span> <span class="math inline">\(\lambda^2 - 4\lambda + 3 = 0\)</span> <span class="math inline">\((\lambda - 3)(\lambda - 1) = 0\)</span> <span class="math inline">\(\lambda_1 = 3\)</span>, <span class="math inline">\(\lambda_2 = 1\)</span></p></li>
<li><p><strong>特征向量 (λ = 3):</strong> <span class="math inline">\((\mathbf{A} - 3\mathbf{I})\mathbf{v} = 0\)</span> <span class="math inline">\(\begin{bmatrix} -1 &amp; 1 \\ 1 &amp; -1 \end{bmatrix} \begin{bmatrix} x \\ y \end{bmatrix} = \begin{bmatrix} 0 \\ 0 \end{bmatrix}\)</span> <span class="math inline">\(x = y\)</span>, <span class="math inline">\(\mathbf{v_1} = \begin{bmatrix} 1 \\ 1 \end{bmatrix}\)</span> （或任意常数倍）</p></li>
<li><p><strong>特征向量 (λ = 1):</strong> <span class="math inline">\((\mathbf{A} - \mathbf{I})\mathbf{v} = 0\)</span> <span class="math inline">\(\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 1 \end{bmatrix} \begin{bmatrix} x \\ y \end{bmatrix} = \begin{bmatrix} 0 \\ 0 \end{bmatrix}\)</span> <span class="math inline">\(x = -y\)</span>, <span class="math inline">\(\mathbf{v_2} = \begin{bmatrix} -1 \\ 1 \end{bmatrix}\)</span> （或任意常数倍）</p></li>
</ul></li>
<li><p><strong>逆矩阵:</strong> <span class="math inline">\(\mathbf{A} = \begin{bmatrix} 1 &amp; 2 \\ 3 &amp; 4 \end{bmatrix}\)</span></p></li>
</ol>
<ul>
<li><strong>存在判断:</strong> <span class="math inline">\(\det(\mathbf{A}) = (1)(4) - (2)(3) = 4 - 6 = -2 \neq 0\)</span>. 逆矩阵存在。</li>
<li><strong>逆矩阵计算:</strong> <span class="math inline">\(\mathbf{A}^{-1} = \frac{1}{\det(\mathbf{A})} \begin{bmatrix} 4 &amp; -2 \\ -3 &amp; 1 \end{bmatrix} = \frac{1}{-2} \begin{bmatrix} 4 &amp; -2 \\ -3 &amp; 1 \end{bmatrix} = \begin{bmatrix} -2 &amp; 1 \\ 1.5 &amp; -0.5 \end{bmatrix}\)</span></li>
</ul>
<ol start="3" type="1">
<li><strong>线性变换可视化:</strong>
<ul>
<li><span class="math inline">\(T(\mathbf{e_1}) = \mathbf{A}\mathbf{e_1} = \begin{bmatrix} 2 &amp; -1 \\ 1 &amp; 1 \end{bmatrix} \begin{bmatrix} 1 \\ 0 \end{bmatrix} = \begin{bmatrix} 2 \\ 1 \end{bmatrix}\)</span></li>
<li><span class="math inline">\(T(\mathbf{e_2}) = \mathbf{A}\mathbf{e_2} = \begin{bmatrix} 2 &amp; -1 \\ 1 &amp; 1 \end{bmatrix} \begin{bmatrix} 0 \\ 1 \end{bmatrix} = \begin{bmatrix} -1 \\ 1 \end{bmatrix}\)</span></li>
<li>可视化: 将原来的基向量 <span class="math inline">\(\mathbf{e_1}\)</span>, <span class="math inline">\(\mathbf{e_2}\)</span> 分别转换为 <span class="math inline">\(\begin{bmatrix} 2 \\ 1 \end{bmatrix}\)</span>, <span class="math inline">\(\begin{bmatrix} -1 \\ 1 \end{bmatrix}\)</span> 并在坐标平面上绘制。</li>
</ul></li>
<li><strong>秩计算:</strong> <span class="math inline">\(\mathbf{A} = \begin{bmatrix} 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6 \\ 7 &amp; 8 &amp; 9 \end{bmatrix}\)</span> 转换为行阶梯形后，有两行含有非零值，因此秩为2。 (第三行可以表示为第一行和第二行的线性组合)</li>
</ol>
</section>
<section id="深化-1" class="level4">
<h4 class="anchored" data-anchor-id="深化-1">深化</h4>
<ol type="1">
<li><p><strong>SVD:</strong> <span class="math inline">\(\mathbf{A} = \mathbf{U\Sigma V^T}\)</span></p>
<ul>
<li><span class="math inline">\(\mathbf{U}\)</span>: 列包含 <span class="math inline">\(\mathbf{A}\mathbf{A}^T\)</span> 的特征向量的正交矩阵</li>
<li><span class="math inline">\(\mathbf{\Sigma}\)</span>: 对角元素为奇异值（<span class="math inline">\(\mathbf{A}\mathbf{A}^T\)</span> 的特征值的平方根）的对角矩阵</li>
<li><span class="math inline">\(\mathbf{V}\)</span>: 列包含 <span class="math inline">\(\mathbf{A}^T\mathbf{A}\)</span> 的特征向量的正交矩阵</li>
</ul>
<p>(计算过程省略。可以使用 NumPy 等库进行计算：<code>U, S, V = np.linalg.svd(A)</code>)</p></li>
<li><p><strong>PCA:</strong></p>
<div class="sourceCode" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> np.array([[<span class="dv">1</span>, <span class="dv">2</span>], [<span class="dv">2</span>, <span class="dv">3</span>], [<span class="dv">3</span>, <span class="dv">4</span>], [<span class="dv">4</span>, <span class="dv">5</span>], [<span class="dv">5</span>, <span class="dv">6</span>]])</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="co"># 1. 数据中心化（减去平均值）</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>mean <span class="op">=</span> np.mean(data, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>centered_data <span class="op">=</span> data <span class="op">-</span> mean</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a><span class="co"># 2. 计算协方差矩阵</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>covariance_matrix <span class="op">=</span> np.cov(centered_data.T)</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a><span class="co"># 3. 计算特征值和特征向量</span></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>eigenvalues, eigenvectors <span class="op">=</span> np.linalg.eig(covariance_matrix)</span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a><span class="co"># 4. 选择主成分（对应最大特征值的特征向量）</span></span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a><span class="co">#    按特征值降序排列，选择最大的特征值对应的特征向量</span></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a>sorted_indices <span class="op">=</span> np.argsort(eigenvalues)[::<span class="op">-</span><span class="dv">1</span>]  <span class="co"># 特征值降序排列索引</span></span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>largest_eigenvector <span class="op">=</span> eigenvectors[:, sorted_indices[<span class="dv">0</span>]]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<h1 id="投影到一维">5. 投影到一维</h1>
<p>projected_data = centered_data.dot(largest_eigenvector)</p></li>
</ol>
<p>print(projected_data)</p>
<pre><code>
3.  **零空间、列空间基底:**
$\mathbf{A} = \begin{bmatrix} 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6 \\ 7 &amp; 8 &amp; 9 \end{bmatrix}$

    *   **零空间 (Null Space):** 找到满足 $\mathbf{Ax} = 0$ 的 $\mathbf{x}$。
        将其转换为行阶梯形来求解，
        $\mathbf{x} = t\begin{bmatrix} 1 \\ -2 \\ 1 \end{bmatrix}$ (t是任意常数) 形式。
        因此，零空间的基底是 $\begin{bmatrix} 1 \\ -2 \\ 1 \end{bmatrix}$

    *   **列空间 (Column Space):** 矩阵 $\mathbf{A}$ 的列向量的线性组合生成的空间。
        在行阶梯形中，对应主元列的原矩阵的列向量成为基底。
         $\begin{bmatrix} 1 \\ 4 \\ 7 \end{bmatrix}$, $\begin{bmatrix} 2 \\ 5 \\ 8 \end{bmatrix}$

4.  **QR 分解:**
$\mathbf{A} = \mathbf{QR}$
    *   $\mathbf{Q}$: 列向量为正交单位(orthonormal)的矩阵
    *   $\mathbf{R}$: 上三角矩阵(upper triangular matrix)

    (计算过程可以使用 Gram-Schmidt 正交化过程，或者使用 NumPy 等库进行计算: `Q, R = np.linalg.qr(A)`)
:::

## 练习题

### 2 微积分与优化

#### 基础

1. 求函数 $f(x) = x^3 - 6x^2 + 9x + 1$ 的导数 $f'(x)$。

2. 求函数 $f(x, y) = x^2y + 2xy^2$ 的偏导数 $\frac{\partial f}{\partial x}$ 和 $\frac{\partial f}{\partial y}$。

3. 使用链式法则求函数 $f(x) = \sin(x^2)$ 的导数 $f'(x)$。

#### 应用

1. 求函数 $f(x, y) = e^{x^2 + y^2}$ 的梯度 $\nabla f$，并计算点 (1, 1) 处的梯度值。

2. 找出函数 $f(x) = x^4 - 4x^3 + 4x^2$ 的所有临界点，并判断每个临界点是极大值、极小值还是鞍点。

3. 求下列函数的雅可比矩阵。
    $f(x, y) = \begin{bmatrix} x^2 + y^2 \\ 2xy \end{bmatrix}$

#### 深化

1. 使用拉格朗日乘数法 (Lagrange multiplier method)，在约束条件 $g(x, y) = x^2 + y^2 - 1 = 0$ 下求函数 $f(x, y) = xy$ 的最大值和最小值。

2. 使用梯度下降法 (Gradient Descent) 求函数 $f(x) = x^4 - 4x^3 + 4x^2$ 的最小值。（初始值 $x_0 = 3$，学习率 $\alpha = 0.01$，迭代次数 100 次）

3. 使用 $\mathbf{A}$ 和 $\mathbf{x}$ 表示函数 $f(\mathbf{x}) = \mathbf{x}^T \mathbf{A} \mathbf{x}$ 的梯度 $\nabla f$。（其中，$\mathbf{A}$ 是对称矩阵）

4. 使用牛顿法 (Newton's method) 求方程 $x^3 - 2x - 5 = 0$ 的根。

::: {.callout-note collapse="true" title="点击查看内容（答案）"}
## 练习题解答

### 2 微积分与优化

#### 基础

1.  **导数:**
    $f(x) = x^3 - 6x^2 + 9x + 1$
    $f'(x) = 3x^2 - 12x + 9$

2.  **偏导数:**
    $f(x, y) = x^2y + 2xy^2$
    $\frac{\partial f}{\partial x} = 2xy + 2y^2$
    $\frac{\partial f}{\partial y} = x^2 + 4xy$

3.  **链式法则:**
    $f(x) = \sin(x^2)$
    $f'(x) = \cos(x^2) \cdot (2x) = 2x\cos(x^2)$

#### 应用

1.  **梯度:**
    $f(x, y) = e^{x^2 + y^2}$
    $\nabla f = \begin{bmatrix} \frac{\partial f}{\partial x} \\ \frac{\partial f}{\partial y} \end{bmatrix} = \begin{bmatrix} 2xe^{x^2 + y^2} \\ 2ye^{x^2 + y^2} \end{bmatrix}$
    $\nabla f(1, 1) = \begin{bmatrix} 2e^2 \\ 2e^2 \end{bmatrix}$

2.  **临界点、极值判断:**
    $f(x) = x^4 - 4x^3 + 4x^2$
    $f'(x) = 4x^3 - 12x^2 + 8x = 4x(x-1)(x-2)$
    临界点: $x = 0, 1, 2$

    $f''(x) = 12x^2 - 24x + 8$
    *   $f''(0) = 8 &gt; 0$: 极小值
    *   $f''(1) = -4 &lt; 0$: 极大值
    *   $f''(2) = 8 &gt; 0$: 极小值

3.  **雅可比矩阵:**
    $f(x, y) = \begin{bmatrix} x^2 + y^2 \\ 2xy \end{bmatrix}$
    $\mathbf{J} = \begin{bmatrix} \frac{\partial f_1}{\partial x} &amp; \frac{\partial f_1}{\partial y} \\ \frac{\partial f_2}{\partial x} &amp; \frac{\partial f_2}{\partial y} \end{bmatrix} = \begin{bmatrix} 2x &amp; 2y \\ 2y &amp; 2x \end{bmatrix}$

#### 深化

1.  **拉格朗日乘数法:**
    $L(x, y, \lambda) = xy - \lambda(x^2 + y^2 - 1)$
    $\frac{\partial L}{\partial x} = y - 2\lambda x = 0$
    $\frac{\partial L}{\partial y} = x - 2\lambda y = 0$
    $\frac{\partial L}{\partial \lambda} = x^2 + y^2 - 1 = 0$

    *   $x = \pm \frac{1}{\sqrt{2}}$, $y = \pm \frac{1}{\sqrt{2}}$, $\lambda = \pm \frac{1}{2}$
    *   最大值: $f(\frac{1}{\sqrt{2}}, \frac{1}{\sqrt{2}}) = f(-\frac{1}{\sqrt{2}}, -\frac{1}{\sqrt{2}}) = \frac{1}{2}$
    *   最小值: $f(\frac{1}{\sqrt{2}}, -\frac{1}{\sqrt{2}}) = f(-\frac{1}{\sqrt{2}}, \frac{1}{\sqrt{2}}) = -\frac{1}{2}$

2.  **梯度下降法:**

    ```python
    def gradient_descent(f, df, x0, alpha, iterations):
        x = x0
        for i in range(iterations):
            x = x - alpha * df(x)
        return x
    ```
f = lambda x: x**4 - 4*x**3 + 4*x**2
df = lambda x: 4*x**3 - 12*x**2 + 8*x

x_min = gradient_descent(f, df, 3, 0.01, 100)
print(x_min) # 大约收敛到2</code></pre>
<ol start="3" type="1">
<li><p><strong>梯度（矩阵形式）:</strong> <span class="math inline">\(f(\mathbf{x}) = \mathbf{x}^T \mathbf{A} \mathbf{x}\)</span> <span class="math inline">\(\nabla f = (\mathbf{A} + \mathbf{A}^T)\mathbf{x}\)</span>. 由于 <span class="math inline">\(\mathbf{A}\)</span> 是对称矩阵，因此 <span class="math inline">\(\nabla f = 2\mathbf{A}\mathbf{x}\)</span></p></li>
<li><p><strong>牛顿法:</strong> <span class="math inline">\(f(x) = x^3 - 2x - 5\)</span> <span class="math inline">\(f'(x) = 3x^2 - 2\)</span> <span class="math inline">\(x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)}\)</span></p></li>
</ol>
<div class="sourceCode" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> newton_method(f, df, x0, iterations):</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> x0</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(iterations):</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> x <span class="op">-</span> f(x) <span class="op">/</span> df(x)</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> <span class="kw">lambda</span> x: x<span class="op">**</span><span class="dv">3</span> <span class="op">-</span> <span class="dv">2</span><span class="op">*</span>x <span class="op">-</span> <span class="dv">5</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> <span class="kw">lambda</span> x: <span class="dv">3</span><span class="op">*</span>x<span class="op">**</span><span class="dv">2</span> <span class="op">-</span> <span class="dv">2</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>root <span class="op">=</span> newton_method(f, df, <span class="dv">2</span>, <span class="dv">5</span>) <span class="co"># 初始值 x0 = 2, 迭代5次</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(root)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
</section>
</div>
</div>
</section>
</section>
</section>
<section id="练习题-1" class="level2">
<h2 class="anchored" data-anchor-id="练习题-1">练习题</h2>
<section id="概率与统计-1" class="level3">
<h3 class="anchored">3 概率与统计</h3>
<section id="基本" class="level4">
<h4 class="anchored" data-anchor-id="基本">基本</h4>
<ol type="1">
<li><p>抛三次硬币时，正面出现两次的概率是多少？</p></li>
<li><p>掷骰子时，出现偶数的概率是多少？</p></li>
<li><p>写出正态分布的概率密度函数(PDF)，并解释均值和方差的意义。</p></li>
</ol>
</section>
<section id="应用-2" class="level4">
<h4 class="anchored" data-anchor-id="应用-2">应用</h4>
<ol type="1">
<li><p>解释贝叶斯定理(Bayes’ theorem)，并应用于以下问题：</p>
<ul>
<li>某种疾病的发病率是1%，诊断该疾病的测试的准确度（敏感性和特异性）为99%。如果检测结果为阳性，实际患有该疾病的可能性是多少？</li>
</ul></li>
<li><p>解释最大似然估计(Maximum Likelihood Estimation, MLE)的概念，并在抛五次硬币正面出现三次的情况下，求出硬币正面向上的概率的MLE。</p></li>
<li><p>写出期望值(expectation)的定义，并分别写出离散随机变量和连续随机变量的期望值计算公式。</p></li>
</ol>
</section>
<section id="深化-2" class="level4">
<h4 class="anchored">深化</h4>
<ol type="1">
<li><p>写出熵(entropy)的定义，并计算以下概率分布的熵：</p>
<ul>
<li>P(X=1) = 0.5, P(X=2) = 0.25, P(X=3) = 0.25</li>
</ul></li>
<li><p>当两个随机变量X和Y的联合概率分布(joint probability distribution)如下时，计算互信息量(mutual information) I(X;Y)。</p>
<pre><code>P(X=0, Y=0) = 0.1, P(X=0, Y=1) = 0.2
P(X=1, Y=0) = 0.3, P(X=1, Y=1) = 0.4</code></pre></li>
<li><p>当两个概率分布P和Q如下时，计算KL散度(Kullback-Leibler divergence) <span class="math inline">\(D_{KL}(P||Q)\)</span>。</p>
<ul>
<li>P(X=1) = 0.6, P(X=2) = 0.4</li>
<li>Q(X=1) = 0.8, Q(X=2) = 0.2</li>
</ul></li>
<li><p>写出泊松分布(Poisson distribution)的概率质量函数(PMF)，并举例说明在什么情况下使用。</p></li>
</ol>
<div class="callout callout-style-default callout-note callout-titled" title="点击查看内容（答案）">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-13-contents" aria-controls="callout-13" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
点击查看内容（答案）
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-13" class="callout-13-contents callout-collapse collapse">
<section id="练习题解答-1" class="level2 callout-body-container callout-body">
<h2 class="anchored" data-anchor-id="练习题解答-1">练习题解答</h2>
<section id="概率与统计-2" class="level3">
<h3 class="anchored" data-anchor-id="概率与统计-2">3 概率与统计</h3>
<section id="基础-2" class="level4">
<h4 class="anchored" data-anchor-id="基础-2">基础</h4>
<ol type="1">
<li><p><strong>掷硬币:</strong> 概率 = (3次中2次正面出现的情况数) * (正面概率)^2 * (反面概率)^1 = 3C2 * (1/2)^2 * (1/2)^1 = 3 * (1/4) * (1/2) = 3/8</p></li>
<li><p><strong>掷骰子:</strong> 概率 = (出现偶数的情况数) / (总情况数) = 3 / 6 = 1/2</p></li>
<li><p><strong>正态分布:</strong> <span class="math inline">\(f(x) = \frac{1}{\sigma\sqrt{2\pi}} e^{-\frac{(x-\mu)^2}{2\sigma^2}}\)</span></p>
<ul>
<li><span class="math inline">\(\mu\)</span>: 均值 (分布的中心)</li>
<li><span class="math inline">\(\sigma\)</span>: 标准差 (分布的离散程度)</li>
</ul></li>
</ol>
</section>
<section id="应用-3" class="level4">
<h4 class="anchored" data-anchor-id="应用-3">应用</h4>
<ol type="1">
<li><p><strong>贝叶斯定理:</strong> <span class="math inline">\(P(A|B) = \frac{P(B|A)P(A)}{P(B)}\)</span></p>
<ul>
<li><span class="math inline">\(P(A)\)</span>: 患病的概率 (先验概率) = 0.01</li>
<li><span class="math inline">\(P(B|A)\)</span>: 患病时检测结果为阳性的概率 (灵敏度) = 0.99</li>
<li><span class="math inline">\(P(B|\neg A)\)</span>: 未患病时检测结果为阳性的概率 (1 - 特异度) = 0.01 (假设特异度为0.99)</li>
<li><span class="math inline">\(P(B)\)</span>: 检测结果为阳性的概率 = <span class="math inline">\(P(B|A)P(A) + P(B|\neg A)P(\neg A) = (0.99)(0.01) + (0.01)(0.99) = 0.0198\)</span></li>
</ul>
<p><span class="math inline">\(P(A|B) = \frac{(0.99)(0.01)}{0.0198} = 0.5\)</span> (50%)</p></li>
<li><p><strong>最大似然估计 (MLE):</strong></p></li>
</ol>
<ul>
<li>似然函数: <span class="math inline">\(L(p) = p^3 (1-p)^2\)</span> (p是硬币正面出现的概率)</li>
<li>对数似然函数: <span class="math inline">\(\log L(p) = 3\log p + 2\log(1-p)\)</span></li>
<li><span class="math inline">\(\frac{d}{dp} \log L(p) = \frac{3}{p} - \frac{2}{1-p}\)</span>
<ul>
<li>解方程得 <span class="math inline">\(p = 0.6\)</span></li>
</ul></li>
</ul>
<ol start="3" type="1">
<li><p><strong>KL散度:</strong> <span class="math inline">\(D_{KL}(P||Q) = \sum_{x} P(x) \log \frac{P(x)}{Q(x)}\)</span> <span class="math inline">\(D_{KL}(P||Q) = 0.6 \log \frac{0.6}{0.8} + 0.4 \log \frac{0.4}{0.2} \approx 0.083\)</span></p></li>
<li><p><strong>泊松分布:</strong></p>
<ul>
<li><strong>概率质量函数 (PMF):</strong> <span class="math inline">\(P(X=k) = \frac{\lambda^k e^{-\lambda}}{k!}\)</span> (<span class="math inline">\(k\)</span>是发生次数, <span class="math inline">\(\lambda\)</span>是在单位时间/空间内的平均发生次数)</li>
<li><strong>用途示例</strong>:
<ul>
<li>特定时间内呼叫中心接到的电话数量</li>
<li>某一地区发生的交通事故数量</li>
<li>某本书中发现的错字数</li>
<li>访问某个网站的访客数量</li>
<li>放射性衰变，基因突变</li>
</ul></li>
</ul></li>
</ol>
</section>
</section>
</section>
</div>
</div>
</section>
</section>
</section>
<section id="参考文献" class="level2">
<h2 class="anchored" data-anchor-id="参考文献">参考文献</h2>
<section id="必要参考资料" class="level4">
<h4 class="anchored" data-anchor-id="必要参考资料">必要参考资料</h4>
<ol type="1">
<li><strong>Linear Algebra and Its Applications (Gilbert Strang, 4th Edition)</strong>:
<ul>
<li>这是一本介绍线性代数基本概念和应用的教科书。清晰地解释了深度学习所需的核⼼内容。</li>
<li><a href="https://www.google.com/url?sa=E&amp;source=gmail&amp;q=https://ocw.mit.edu/courses/mathematics/18-06-linear-algebra-spring-2010/">Gilbert Strang’s Linear Algebra Course (MIT OCW)</a></li>
</ul></li>
<li><strong>Calculus (James Stewart, 8th Edition)</strong>:
<ul>
<li>这是一本详细解释微积分基本原理的教科书。提供了理解深度学习优化算法所需的背景知识。</li>
</ul></li>
<li><strong>Probability and Statistics for Engineering and the Sciences (Jay L. Devore, 9th Edition)</strong>:
<ul>
<li>这是一本介绍概率和统计学基本概念及其工程应用的教科书。有助于理解深度学习的概率模型和不确定性推理。</li>
</ul></li>
<li><strong>Pattern Recognition and Machine Learning (Christopher Bishop)</strong>:
<ul>
<li>这是一本关于模式识别和机器学习的经典教科书。深入讨论了概率建模、贝叶斯推断、信息理论等深度学习的理论背景。</li>
</ul></li>
<li><strong>The Elements of Statistical Learning (Trevor Hastie, Robert Tibshirani, Jerome Friedman)</strong>:
<ul>
<li>这是一本清晰解释统计学习理论核心概念的教科书。对于理解深度学习模型的泛化性能和过拟合问题非常有用。</li>
<li><a href="https://www.google.com/url?sa=E&amp;source=gmail&amp;q=https://hastie.su.domains/ElemStatLearn/">The Elements of Statistical Learning (Free PDF)</a></li>
</ul></li>
<li><strong>Deep Learning (Ian Goodfellow, Yoshua Bengio, Aaron Courville)</strong>:
<ul>
<li>这是一本全面覆盖深度学习基本概念和最新技术的教科书。简要介绍了深度学习所需的数学基础。</li>
<li>Deep Learning Book (Free PDF)](https://www.deeplearningbook.org/)</li>
</ul></li>
<li><strong>Understanding Machine Learning: From Theory to Algorithms (Shai Shalev-Shwartz, Shai Ben-David)</strong>:
<ul>
<li>这是一本牢固奠定机器学习理论基础的教科书。解释了PAC学习理论、VC维度、偏差-方差权衡等对于理解深度学习模型泛化性能重要的概念。</li>
</ul></li>
<li><strong>Information Theory, Inference, and Learning Algorithms (David J.C. MacKay)</strong>:
<ul>
<li>这是一本以信息论和贝叶斯推断为中心解释机器学习原理的教科书。有助于理解深度学习的概率解释和生成模型。</li>
<li><a href="https://www.google.com/url?sa=E&amp;source=gmail&amp;q=http://www.inference.org.uk/itprnn/book.pdf">Information Theory, Inference, and Learning Algorithms (Free PDF)</a></li>
</ul></li>
<li><strong>Mathematics for Machine Learning (Marc Peter Deisenroth, A. Aldo Faisal, and Cheng Soon Ong)</strong>
<ul>
<li>这是一本广泛介绍机器学习所需数学背景知识的教科书。</li>
</ul></li>
<li><strong>Matrix Computations (Gene H. Golub, Charles F. Van Loan, 4th Edition)</strong>:
<ul>
<li>这是一本深入讨论矩阵运算相关数值方法的教科书。提供了实现和改进深度学习优化算法所需的知識。</li>
</ul></li>
<li><strong>Linear Algebra and Its Applications (Gilbert Strang, 4th Edition)</strong>:
<ul>
<li>这是一本涵盖线性代数的基本概念及其应用的教科书。清晰地解释了深度学习所需的核⼼内容。 - <a href="https://www.google.com/url?sa=E&amp;source=gmail&amp;q=https://ocw.mit.edu/courses/mathematics/18-06-linear-algebra-spring-2010/">Gilbert Strang 的线性代数课程 (MIT OCW)</a></li>
</ul></li>
<li><strong>Calculus (James Stewart, 8th Edition)</strong>:
<ul>
<li>这是一本详细解释微积分基本原理的教科书。提供了理解深度学习优化算法所需的背景知识。</li>
</ul></li>
<li><strong>Probability and Statistics for Engineering and the Sciences (Jay L. Devore, 9th Edition)</strong>:
<ul>
<li>这是一本解释概率和统计的基本概念及其工程应用的教科书。有助于理解深度学习的概率建模和不确定性推理。</li>
</ul></li>
<li><strong>Pattern Recognition and Machine Learning (Christopher Bishop)</strong>:
<ul>
<li>这是一本经典的模式识别与机器学习教科书。深入探讨了概率模型、贝叶斯推断、信息论等深度学习的理论背景。</li>
</ul></li>
<li><strong>The Elements of Statistical Learning (Trevor Hastie, Robert Tibshirani, Jerome Friedman)</strong>:
<ul>
<li>这是一本清晰解释统计学习理论核心概念的教科书。对于理解深度学习模型的泛化性能和过拟合问题非常有用。 - <a href="https://www.google.com/url?sa=E&amp;source=gmail&amp;q=https://hastie.su.domains/ElemStatLearn/">The Elements of Statistical Learning (Free PDF)</a></li>
</ul></li>
<li><strong>Deep Learning (Ian Goodfellow, Yoshua Bengio, Aaron Courville)</strong>:
<ul>
<li>这是一本全面涵盖深度学习基本概念和最新技术的教科书。简要介绍了深度学习所需的数学基础。 - Deep Learning Book (Free PDF)](https://www.deeplearningbook.org/)</li>
</ul></li>
<li><strong>Understanding Machine Learning: From Theory to Algorithms (Shai Shalev-Shwartz, Shai Ben-David)</strong>:
<ul>
<li>这是一本巩固机器学习理论基础的教科书。解释了对理解深度学习模型泛化性能至关重要的概念，如 PAC 学习理论、VC 维度和偏差-方差权衡。</li>
</ul></li>
<li><strong>Information Theory, Inference, and Learning Algorithms (David J.C. MacKay)</strong>:
<ul>
<li>这是一本以信息论和贝叶斯推断为中心解释机器学习原理的教科书。有助于理解深度学习的概率解释和生成模型。 - <a href="https://www.google.com/url?sa=E&amp;source=gmail&amp;q=http://www.inference.org.uk/itprnn/book.pdf">Information Theory, Inference, and Learning Algorithms (Free PDF)</a></li>
</ul></li>
<li><strong>Mathematics for Machine Learning (Marc Peter Deisenroth, A. Aldo Faisal, and Cheng Soon Ong)</strong>
<ul>
<li>广泛涵盖了机器学习所需的数学背景知识。 10. <strong>Matrix Computations (Gene H. Golub, Charles F. Van Loan, 4th Edition)</strong>: - 这是一本深入探讨与矩阵运算相关的数值方法的教科书。它提供了实现和改进深度学习优化算法所需的知识。</li>
</ul></li>
</ol>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>